{
  "/community/": {
    "title": null,
    "subtitle": null,
    "body": ""
  },
  "/guides/advanced/introduction/": {
    "title": "Introduction",
    "subtitle": "Advanced Topics",
    "body": "Advanced Topics Introduction The following are marked as Advanced Topics . These topics cover aspects that go beyond the general Origen usage\nof chip modeling and test pattern/program generation. However, power users or those wishing to have a more intricate\nknowledge of Origen may find these topics interesting and handy. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/advanced/invocations/": {
    "title": "Invocation Customization",
    "subtitle": "Advanced Topics",
    "body": "Advanced Topics Invocation Customization When installing Origen as an individual user in an environment where\nthe user has full admin privileges, its quite straightforward: just install Origen as any other Ruby gem.\nHowever, when used on system where the user does not have these admin privileges, as most company’s Linux servers will\nbe, installing Origen such that its available for all can be a bit daunting and individuals lose ways of customizing\ntheir global Origen installs. Assuming that a central IT or admin user has installed Origen in some central location, this guide goes though Origen’s\nvarious invocations and what can be done for users to regain full control over their Origen install or for experienced users\nto build and maintain custom installs. Invocations When you install the origen gem, the origen executable will be registered on your system. Alternatively,\nthe origen repository can be downloaded directly to your system, then the executable sourced from the bin/origen directory. It is also possible to create your own script to source Origen any way you want. However you choose to do so,\nthat Origen executable becomes your Universal Origen Install . Origen invocations stemming from this location are\ninvoked universally . This generally uses the System Install and the System Gems . Universal invocations provide a common, site-wide means to start up Origen or allow for an experienced user or IT department \nto setup an Origen install in a project or tools workspace. However, normal users lose the ability to customize their \ninstallations as these installations are generally not writable by the user base at large. For example, in order to add global commands to Origen, you must add additional dependencies to Origen’s Gemfile .\nHowever, if Origen is living in some tool directory, changing the Gemfile will affect everyone’s installation\n(for better or worse) and individual users lose control over their global installation. The Site Config can help us with this. Dependencies Using The System Gems The simplest and quickest way to add dependencies to Origen is to just use gem install and install any gems\nyou want. Dependencies brought in this way will be able to register global commands to Origen, even\nwhen brought in as seperate gems. Under the hood, all this doing is going through the system installed gems and seeing which have a dependency\non Origen . If the gem does, it is loaded as if it were a plugin, registering all global\ncommands it may have. Some drawbacks of this are: You (or someone) must be able to install gems on the system. For most Windows users who control their own\nPCs, this is not an issue. But for more locked-down PCs, or the most likely scenerio of using a centralized Linux server,\nyou will need advanced permissions to add system gems. You are stuck with whatever version of the gem you pull. Newer ones will need to be updated as above. Developing these are clumsier than using Bundler. But, to this last note, using User Installations (the next section) boots global commands the\nsame way. So, you can develop the plugin using User Installations and still install it\nas a system gem and get the same affect. This methodology is better suited for managing a global installation (obvisouly). All users using\nthis installation will be able to see these plugins when running universally . Note that if a user install , tool repo install , or if running from\nwithin an application, these plugins will be bypassed, and must be added to the Gemfile . Site Config For User Installations You can switch up Origen to instead invoke from your own home directory. Recall that the Site Config from earlier in the guides\ncan set global parameters for Origen and that the site configs will stack upon themselves, overwriting parameters\nuntil the root site config at the Origen invocation directory is reached. The top-most site config is the one that is\nlocated in your home_dir , which is ~/.origen by default. This means that you\ncan overwrite anything in Origen’s site config by providing one yourself. To enable user installations, add a couple parameters to your site config. Again, your user’s site config will be the\ntop-most site config, but as long as the parameters are set somewhere and not overriden it will be fine. This could\neven be at the universal install’s site config if it’s their wish that all users have their own global environments. To enable, add these parameters to your site config: user_install_enable: true # Set to false by default Origen site config\nuser_install_dir: ~/.origen # Or where you want it to be. \n # If this is undefined, it is equal to <home_dir> in the site config\n # This is undefined by default This will first enable the user install, then indicate that the user install should be installed at user_install_dir . user_install_dir is actually undefined by default, and thus points to home_dir . If this\nlocation works for you, you need not update that parameter (unless some other site config is overwriting it\nand you want to change it back). Now, when you run origen -v , you will see Bundler busy itself creating some files in your home\ninstall. What exactly is it doing? Its giving you your own Gemfile to use when running Origen globally.\nAfter Bundler completes, you can ls on your ~/.origen directory (or wherever\nyour user_install_dir is pointing) and you will see a Gemfile sitting there. Right now, \nall its going to have is origen . It should look something like this: # frozen_string_literal: true\nsource \"https://rubygems.org\"\n\n# gem \"rails\"\ngem 'origen' However, you can add anything you want to this Gemfile. Adding additional dependencies here enables them in\nyour global Origen. You can also point this Gemfile to a specific version of Origen or even\nto a local copy of it. This gives your application-external Origen installation the same flexibility that you have\nin your applications. Site Config For Toolset Installations It is likely that different users will want different global Origen setups. Having multiple universal setups\ncan get messy, difficult to maintain, and depending on your organization’s structure, may not even be able to be built\nby standard users. Tool Repository Installations allow for what is essentially a user installation to be built at any given\nlocation and enabled without needing to flip any enable switch. Additionally, this allows for all of the gems\nto be built in that same directory. The purpose of these installations is to allow all users to use a common installation\nwithout needing to build gems or mess with their site configs but allow any standard user to build and maintain one\nwithout having to dig into the universal install. To setup a toolset installation, just point the site config’s tool_repo_install_dir to wherever you\nwish to install it. Running origen -v will install a tool repo installation at that location. Now,\nwhen users point their tool_repo_install_dir to that same directory, they will be running with the same\ndependencies. At the end of day, what this allows for is Origen invocations at the global level (external to an application, \nthat is) to stem off from the univeral install and branch out to either toolset-specific setups or to the \nuser’s own setup. The purpose of these installs is to allow a project toolset manager, or other experienced Origen user, to define a\nglobal install’s dependencies to be used by a project, a team, or etc. Since only a site config and Gemfile is needed,\nmaintenance is very low. The install manager need only update the Gemfile with whatever dependencies and versions\nrequired. Users of this install then just need to source this site config either by making sure the site config\nis in their invocation path (again, see the Site Config for this), or \nby sourcing a script that sets the environment variable ORIGEN_TOOL_REPO_INSTALL_DIR (recall that site\nconfigs can be overwritten by settting environment variables with the same name and ORIGEN prepended).\nThis provides a quick and easy way of setting up, using, and managing a custom install at the global level from a single\nuniversal setup. In theory, these installs will be rock solid. That is, the dependencies used are tried-and-tested and these installs\nare slower to pick up the latest versions, or to provide a standard dependency set for the course of the project. It is\nultimately up to the install’s manager to define how it will be used though. The user-level site config will still take precendence though. Meaning that even if the tool_repo_install_dir is defined, if the user_install_enable is set, a custom user install will be used instead. Then, if user_install_dir is be disabled again, the toolset directory will be used. A potential pitfall here would be a power user that may normally want to use their home directory’s install but also wants\nto use a specific Origen install when working on a specific project. The environment variables will still reign supreme over\nthe site config. Thus, by, for example, having their site config set user_install_enable and by\nsetting tool_repo_install_dir they can use the environment variable ORIGEN_USER_INSTALL_ENABLE to switch between their own install and the tool repo’s install. For safety, a site config or source script that sets the tool_repo_install_dir could also disable the user_install_enable . However, normal users probably won’t have their own site config file anyway so this\nshould only be needed if the universal site config, or another site config, is setting user_install_enable .\nLikewise, that source script could also set the environment variables directly, guaranteeing that the shell will use\nthat setup. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/advanced/newapps/": {
    "title": "Creating Custom Application Generators",
    "subtitle": "Advanced Topics",
    "body": "Advanced Topics Creating Custom Application Generators When initially getting started with Origen, it is sufficient to use the generic\nset of new application generators that are built into the origen new command. However, over time you may start to identify common configuration or setups that\nare used regularly within many of your own applications or those created by your\ncompany.\nOrigen provides the ability to extend the origen new command on an individual user\nor a per-company basis, so that newly created applications come with much more customized\nsetup and configuration out-of-the-box than is provided by the generic starter applications. To extend the origen new command with your own custom application generators,\nfirst run origen new to create an application generator plugin by selecting the following options: 1 - Origen Infrastructure 0 - A plugin to make your own application templates available through the ‘origen new’ command To hook your plugin into the origen new command, either release it to your private gem server, check it into your\nGit server, or copy it to a central location that is accessible to all of your users.\nThen update the app_generators attribute within your site_config file to point to wherever you have put it. If you don’t see it straight away, run origen new with the --fetch option to force it to\nfetch the latest versions of the generators. There now follows a guide on how to add a new generator to your custom generators plugin… Quickstart To create a new application generator run the following command: origen app_gen:new This will create a new generator within the lib directory and then update the top-level file in the lib directory\nto properly hook it into the origen new system.\nBy default, this new generator will create the same empty application or plugin starter that you would get from\nselecting option 0 in the origen new command. You can test run your new generator by running the following command: origen app_gen:test This will build a new app in the application’s tmp directory, and when complete you can cd into that directory\nand run origen -v to verify that it can boot. At this point you can further interact with the application in the\nnormal way to test out anything else. During the creation of a new generator, you will likely repeat this many times as you go through the process of modifying the\ngenerator and then observing the new output. To make this easier, a system is built in that allows you to automate the\nanswers to the questions that are given to the user when creating a new application. Within the top-level lib file you will see a set of test inputs something like this: TEST_INPUTS = [ # 0 - TestEngineering::MicroTestBlock [ ' 1 ' , ' 0 ' , :default , :default , ' A cool plugin ' , ' yes ' , :default ]\n] # END_OF_TEST_INPUTS Don't remove this comment, it is used by the app_gen:new command! The last item in the array will be a starter set of inputs that has been created for the new genrator that was just added.\nTo test the new generator with these inputs supply the -i option and supply the index number of the set of inputs you\nwish to apply: origen app_gen:test -i 0 Modify the inputs as required as you further develop the generator, making sure to add a value for any additional questions\nthat you add. The :default keyword can be used for any questions which have a default option that you wish to select, this\nis equivalent to just pressing return in response to the given question. In all cases an additional argument must be supplied at the end, this tells the test command about any commands that you want\nto run within the generated application to test it.\nSupplying the :default keyword for this argument will execute the following tests: origen -v origen lint –no-correct Test that the default target loads cleanly origen web compile –no-serve If you want to run no tests, set this final argument to nil . Alternatively you can specify your own set of operations by supplying an array of commands: [ ' 1 ' , ' 0 ' , :default , :default , ' A cool plugin ' , ' yes ' , [ ' origen -v ' , ' origen g my_pattern ' ]] Within the array of custom commands you can also supply the :default and :load_target keywords to execute the default\nset of tests or the load target test respectively, for example: [ ' 1 ' , ' 0 ' , :default , :default , ' A cool plugin ' , ' yes ' , [ :default , ' origen g my_pattern ' ]] To run a regression test which will execute all sets of test inputs, run: origen app_gen:test -r You should find the generator file itself (the one created for you in a sub-folder of the lib directory) well commented\nand with pointers towards examples from existing generators. Once you are happy with your new generator release your application generators plugin in the normal way. The version of the\ngenerators picked up by the origen new command is automatically refreshed on a per-user basis every 24 hours, or if you\nneed access to it immediately run origen new with the --fetch option to force it. There now follows a more detailed guide on how to create the generator itself. Notes on Creating Generators The application generators use a code generator API from Origen core which itself leans heavily on a 3rd party gem library called\nThor. This gem is used quite widely in the Ruby community for this kind of thing, not least by the code generators\nprovided by the Ruby on Rails web application platform. The code generator API allows the user to do things like: Run code to collect user input Compile templates to produce dynamic output based on the user’s responses Copy files verbatim Create directories and symlinks Delete and inject lines into existing files Each application type that can be generated by this plugin is an example of a code generator. The new application generators are organized into the following hierarchy: OrigenAppGenerators::Application\n |\n -> MyAppGenerators::Application (Mixes in MyAppGenerators::Base)\n |\n -> OrigenAppGenerators::Plugin\n |\n -> MyAppGenerators::Plugin (Mixes in MyAppGenerators::Base) All generators must be a subclass of either OrigenAppGenerators::Application or OrigenAppGenerators::Plugin depending on whether the end application is intended to be a plugin or not. The new application generators should all perform the following functions: Prompt the user with some questions to get the new application name and so on Create the new application files by either copying or compiling source files and creating\nsymlinks or directories as required Make any final modifications to the resulting files Display any information that the user should know about their new application Generator Execution When a generator is executed any methods defined in it will be called in the order that they are\ndefined.\nAny methods that are marked as protected will not be called. For example when the following generator is executed: module MyAppGenerators class MyGenerator < Application def say_hello puts \" Hello \" end def call_a_helper puts \" About to call \" a_helper_method\n puts \" Returned from call \" end protected def a_helper_method puts \" Helper method called! \" end def this_does_nothing puts \" Another method called! \" end end end Then you would see this: Hello\nAbout to call\nHelper method called!\nReturned from call Note that any methods defined by the parent classes will get called first. The\nparent OrigenAppGenerators::Application and OrigenAppGenerators::Plugin classes implement methods to get the user\ninput that will be common to all applications. You can disable this behavior if required by re-defining the relevant methods within the child generator class. Source Files All template or static source files for the generators live in templates/app_generators and from\nthere in sub folders based on the name of the particular generator. All path references to source files made in your generator should be relative to its source file folder, and in\npractice what this means is that if you want to refer to the source file of what will become Origen.root/config/application.rb then you just refer to config/application.rb . When looking for a particular source file the generator will search in the various source directories\nbelonging to your generator’s parent classes.\nFor example let’s say you make a test engineering generator that has the following class hierarchy: OrigenAppGenerators::Application\n |\n -> OrigenAppGenerators::Plugin\n |\n -> MyAppGenerators::Plugin (Mixes in MyAppGenerators::Base)\n |\n -> TestEngineering::TestBlock Then the following source paths will be searched in this order: <my_app_generators>/templates/app_generators/test_engineering/test_block\n<my_app_generators>/templates/app_generators/plugin\n<my_app_generators>/templates/app_generators/base\n<origen_app_generators>/templates/app_generators/plugin\n<origen_app_generators>/templates/app_generators/application This means that if you create a file called config/application.rb within <my_app_generators>/templates/app_generators/test_engineering/test_block then this will override the corresponding\nfile from origen_app_generators. However see the warning in The Filelist section below before doing this! Lean Environment When the generator is run by a user to generate a new application, it will not run within the scope of an\nOrigen application.\nThis means that any references to Origen.app within the generator code are meaningless and will\nresult in an error. Furthermore, because there is no application there is also no associated gem bundle, so the generator must\nbe able to run within the lean Ruby environment that is used to boot Origen. In practice what this means is\nthat you can use any gems that Origen itself relies on (these will be installed in the base Ruby installation),\nbut you cannot use any others. The origen app_gen:test command that is provided for testing the generators will run them within the lean environment, so if it\nworks there you can be confident that it will also run in production. The Filelist Each generator should return the list of files to be created in the new application via its filelist method.\nIf you don’t make any changes to this then it will simply inherit the list of files defined\nby the generator’s parent class. The filelist is also used to define any directories or symlinks that should be created.\nThe generator class created by the origen app_gen:new command contains a commented example of how to add or\nremove the various elements from the filelist. Some application generators may not make any changes to the filelist and will simply augment\nthe basic application/plugin shell by adding additional code to some of the existing files. This can be done by either overriding the source file by defining it in the generator’s own\nsource directory, or by post-modifying the files after the filelist has been rendered as described further\ndown. Warning! While it is tempting (and easier) to simply copy a source file and then\nedit it as required for your target application, this will make your generator harder to maintain as it\nwill not automatically pick up changes and improvements to the master templates that will occur over time.\nTherefore it is always preferable to post-modify the file to delete sections or to modify or add additional code\nwhenever possible. Note that developers should not add logic to the application/plugin master source files to\nimplement generator specific output. This approach is not scalable as in the future this plugin\nis expected to support many different application types. Instead, individual generators must either completely override or post-modify the master files\nas appropriate. Templates All files in the file list will be compiled unless explicitly marked with copy: true or if the destination file name ends in .erb . ERB markup can be used the same way as in regular Origen templates with the following exceptions: Whole line Ruby is not enabled (a limitation imposed by Thor), therefore instead of this: % if x_is_true\nInclude something\n% end You must do: <% if x_is_true -%> Include something <% end -%> Access to variables collected by your generator at runtime is done by assigning them to instance\nvariables (instead of the options hash used by the Origen compiler). So for example if you have your user input a product name, then you should assign that to an\ninstance variable: @product_name = get_product_name Then in the template: The product name is <%= @product_name %> By convention, templates in this plugin do not end in .erb and this is reserved\nfor files that would become .erb files in the end application. Post Generation Modifications It is better to customize any files that are common to all applications\nby post modification rather than by completely overriding the entire file. To do this you have access to the Thor Action methods described here: Thor Action API You can see some examples of these being used in the enable method in lib/app_generators/new.rb where they are used to add the new generator details\nto lib/origen_app_generators.rb . As a quick example say you wanted to add a method to config/application.rb , this\ncould be achieved by injecting it at the end of the class like this: # Always ensure the filelist has been rendered first def generate_files build_filelist end # Add a custom domain method to config/application.rb def add_method_to_application # Define a regular expression to define a point in the file where you want to inject, in this # case the 'end' of the class definition (the only 'end' that occurs at the beginning of a line) end_of_class = / ^end / # Define the code snippet code = <<-END def some_domain_specific_method\n do_something\n end END # Now inject it inject_into_file \" config/application.rb \" , code, before : end_of_class end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/compiler/creating/": {
    "title": "Creating Templates",
    "subtitle": "Compiler (Views)",
    "body": "Compiler (Views) Creating Templates A template is created by taking an existing ASCII file and embedding Ruby\nsnippets to either conditionally include/exclude parts of it or to actually\ngenerate content into the output file. By convention all template files associated with an Origen application live\nin a sub-directory of the templates directory. However it is also\npossible to compile templates that live outside of the application as long as\nthey are accessible via a path from the Origen application workspace. Normally templates are identified by appending the extension .erb to the filename. So for example a template for the file dut_regs.h would be called dut_regs.h.erb . Appending the .erb extension has the following advantages: When Origen is asked to compile a directory only those files ending with the .erb extension will be processed through the compiler. The other\nfiles will be copied across to the output directory unmodified. This can be\nuseful if you want to store binaries or some other non-compiler friendly files\nalongside your template files. If you use an editor like Vim it can be setup to recognize the .erb extension and then syntax highlight the embedded Ruby snippets as\nRuby, while highlighting the rest of the template in its native format. If you would prefer not to have to add the .erb extension add the\nfollowing to your application configuration, this will cause all files presented\nto the compiler to be evaluated for embedded Ruby regardless of their name. # config/application.rb config.compile_only_dot_erb_files = false Template Syntax The compiler uses a markup language called ERB (embedded Ruby) which ships as\npart of the Ruby language and has a very minimal and easy to learn syntax.\nThis makes the entire Ruby language available to conditionally include or\nexclude portions of the file, to expand sections of the file via loops, or to\ninject dynamic snippets that will be evaluated at runtime. Most importantly of all\nof course the runtime ERB environment will have full access to the models that\nhave been instantiated by the current target. Here is an example of a text file to which some ERB has been added: The ERB syntax is very simple:\n% # Lines that start with % (no spaces allowed before it) will be interpreted\n% # as Ruby. Since these lines start with a comment character they will simply be\n% # deleted by the compilation process - very useful for annotating your source files!\n\nRuby logic can be used to conditionally include/exclude lines:\n% if 1 == 1\n You will see me in the compiled file\n% else\n But you won't see me :-(\n% end\n\nLoops can be used to expand the content:\n% 3.times do\n I must not talk in class\n% end\n\nInject dynamic content like this: 4 + 4 = <%= 4 + 4 %> Whatever is returned by a Ruby snippet <%= ' like this ' %> will be converted to a\nstring and output to the compiled file.\n\nAnd not forgetting the best part, you can access any objects that your\ntarget instantiates:\n\nMemory block details:\n% $dut.nvm.memories.each_with_index do |mem, i|\n Memory <%= i %> : Version <%= mem.version %> % end When this file is processed by the compiler it will look something like this: The ERB syntax is very simple:\n\nRuby logic can be used to conditionally include/exclude lines:\n You will see me in the compiled file\n\nLoops can be used to expand the content:\n I must not talk in class\n I must not talk in class\n I must not talk in class\n\nInject dynamic content like this: 4 + 4 = 8\n\nWhatever is returned by a Ruby snippet like this will be converted to a\nstring and output to the compiled file.\n\nAnd not forgetting the best part, you can access any objects that your\ntarget instantiates:\n\nMemory block details:\n Memory 0: Version 12\n Memory 1: Version 12\n Memory 2: Version 12\n Memory 3: Version 12 A Note on State When compiling multiple templates at once the target will be re-loaded\nprior to processing each template. This means that state cannot be carried forward from one template to the\nnext and generally prevents compile order dependent bugs from creeping\nin due to intentionally or otherwise relying on state that has been setup from a previous\ntemplate. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/compiler/helpers/": {
    "title": "Helpers",
    "subtitle": "Compiler (Views)",
    "body": "Compiler (Views) Helpers By default your templates have access to a small number of template specific\nmethods, such as the options hash, and the usual global scope. This means that your device attributes are normally accessed via\nthe global top-level objects that were instantiated in the target like this: % if $dut.analog.atd\n\nThe <%= $dut .part_number %> device has a <%= $dut .analog.atd.bits %> bit analog to\ndigital converter block which provides superior conversion accuracy... \n\n% end However you can easily create additional helper methods by opening the Origen::Generator::Compiler class\nand defining methods which can then be called directly from any template. As a trivial example if I was writing a large document about the ATD module it might\nbecome tedious having to keep writing $dut.analog.atd every time I wanted to access an ATD attribute. In that case the following helper method could be created to give me a shorthand access to the ATD\nmodel: # config/boot.rb require \" #{ Origen .root } /templates/helpers \" # templates/helpers.rb module Origen class Generator class Compiler def atd $dut .analog.atd end end end end The above template could now be re-written as: % if atd\n\nThe <%= $dut .part_number %> device has a <%= atd.bits %> bit analog to\ndigital converter block which provides superior conversion accuracy... \n\n% end These helper methods can become very powerful depending on what you are trying to generate\nwith your template.\nFor example the J750 test program sheets for the flagship Origen application were originally\ngenerated via templates\nand we built up quite a large library of helper methods to generate entire test instance lines\nand flow sheet entries. These helpers have since been incorporated into the Origen J750 generator and you should definitely\nuse that in preference to templates if you are generating a test program for that platform.\nHowever it shows that with templates + custom helper methods you can very easily build\npowerful ASCII generators for your specific domain. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/compiler/inline/": {
    "title": "Inline Compiler",
    "subtitle": "Compiler (Views)",
    "body": "Compiler (Views) Inline Compiler The conventional use of the compiler generates an output file for every template\nthat is compiled. Sometimes though it can be useful to invoke the compiler and get the output back\nas a string so that you can further process it, embed it in another file, or\notherwise work with it in some way. Use the following API\nto invoke the compiler in an in-line manner such that it will return a string\nrather than generate a file: Origen .compile( \" #{ Origen .root } /templates/my_template.txt.erb \" , some_option : 10 ) Any options given as shown above will be available in the options hash within the template in the usual way. The inline compiler will also accept the template in the form of a string: template = <<-END X is: END Origen .compile(template, string : true , x : 10 ) Changing Scope The compile command will accept a :scope option to\nhave the template compile such that ‘self’ inside the template will refer to an\nexisting object. i.e. to give the template direct access to all of that objects methods and attributes: Origen .compile( \" #{ Origen .root } /templates/my_template.txt.erb \" , scope : $dut ) For example let’s say we had a simple template like this to display some information\nabout an ATD block: # templates/atd.txt.erb\n\nType: <%= type %> Bits: <%= bits %> Then in our model let’s say we have two ATD instances: $dut .atd[ 0 ].type # => :sar $dut .atd[ 0 ].bits # => 16 $dut .atd[ 1 ].type # => :sigma_delta $dut .atd[ 1 ].bits # => 8 We can compile our template for each ATD as follows: template = \" #{ Origen .root } /templates/atd.txt.erb \" Origen .compile(template, scope : $dut .atd[ 0 ]) # => \"Type: sar Bits: 16 \" Origen .compile(template, scope : $dut .atd[ 1 ]) # => \"Type: sigma_delta Bits: 8 \" Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/compiler/introduction/": {
    "title": "Introduction",
    "subtitle": "Compiler (Views)",
    "body": "Compiler (Views) Introduction The compiler is probably the most versatile component of Origen and which will\nallow you to dynamically customize any ASCII file to the\ncurrent target. This is often called ‘creating a view’ of the current model/target.\nFor example this can be used to compile device-specific versions of your documentation,\nC code, RTL, test program sheets, Visual Basic, .csv files, etc, etc, etc. When employed in this capacity Origen is often used to replace traditional\npre-compilers (the place where your #ifdefs are evaluated) to provide\nthe benefit of being able to manage device configurations in an object oriented\nfashion. Additional benefits of the Origen compiler are: It is universal It could be the last compiler you ever need to learn Ideal for managing source files for different tool chains under a\ncentrally managed configuration e.g. compile RTL and firmware against\na common target model It is generally more powerful than domain-specific compilers The entire Ruby language is available to implement build logic It can actually generate content into the template as well as\nconditionally including/excluding sections of it It supplements Origen to cover gaps in the generation APIs e.g. the J750 test\nprogram generator does not currently provide a DC spec generator API, that\ngap can be easily plugged by using a template for that sheet Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/compiler/running/": {
    "title": "Running The Compiler",
    "subtitle": "Compiler (Views)",
    "body": "Compiler (Views) Running The Compiler The compiler is launched via the Origen compile command, see the command line\nhelp to get details of the most up to date options: origen compile -h As this is such a common command it has a short cut alias: origen c -h The compiler can be run on a single file: origen c templates/bench/dut_regs.h.erb or on a whole directory: origen c templates/bench In the case of running on a directory the compiler will recursively compile the\ncontents of all contained sub-directories.\nThe sub-directory structure will be maintained and mirrored in the compiler output directory. The given path can even be somewhere outside of the Origen application: origen c /proj/c28/eagle/jim/rtl_v A commonly used option is to specify the output directory: origen c templates/bench -o output/compiled_bench_code By default the compiled files will be put in output or whatever directory\nis returned by the config.output_directory attribute defined by config/application.rb . Submit to the LSF, by appending -l and optionally interactively\nwait for completion: origen c templates/bench -l -w Regression Testing Every time Origen compiles a file it will check to see if it has compiled it before, and\nif so it will compare the current version to the previous version and alert if there is a\ndifference. This can be used to check for regressions when making changes that you don’t want\nto affect the output, or to verify that the change is what you intended in cases where you\nare intentionally modifying the output. In the case of a difference being found Origen will automatically present you with the diff command\nto run if you want to view the change. To accept changes or to start tracking the differences in a file (or files) run the following command\nafter compiling: origen save all Programmatically Launching the Compiler If you start writing your own commands you may want\nto launch the compiler from Ruby, do that as follows: Origen .app.runner.launch action : :compile , files : \" path/to/input/file.erb \" Additionally the following options can be supplied: output : \" path/to/output/dir \" , # Override the default output directory output_file_name : \" my_name.txt \" , # Specify the output file name, by default is the name of the input file output_sub_dir : \" testflow \" , # Specify a subdirectory to be appended to the default output directory # The combination of these two options will run the compiler silently, allowing your application # code to handle all presentation of information about the created file to the user quiet : true , # Don't log to the console check_for_changes : false , # Don't check the output file for changes to a previous version # You can supply a hash of options that will be accessible within the template as 'options' options : { some_attr : true , some_other_attr : 20 } This can be combined with Target Loops to run the\ncompiler for multiple targets. A compile job can also be posted to the LSF by supplying the same options that you would use\non the command line like this: Origen .lsf.submit_origen_job( \" c path/to/input \" ) Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/compiler/subtemplates/": {
    "title": "Using Sub-Templates",
    "subtitle": "Compiler (Views)",
    "body": "Compiler (Views) Using Sub-Templates Sub-templates can be used to make parameterizable snippets that can then be\nre-used throughout your main templates. A sub-template is like a regular template with the following differences: Its name must begin with an underscore It has access to an options hash which contains any parameters\npassed in by the parent template The underscore is used in the name to identify the file as a sub-template\nto Origen and this will prevent it from trying to compile the file standalone\nwhen it is working through a directory. Here is an example sub-template in file templates/_sub_template.txt.erb : This is a sub-template.\n\n% options[:x].times do\n You will see this X times\n% end \n\nThe value of Y is: <%= options[ :y ] %> Sub-templates are called from a top-level template by using the render method, here is an example top-level template that calls this sub-template, this file\nis templates/example.txt.erb : This is a top-level template <%= render ' sub_template ' , x : 3 , y : 10 %> This would compile to: This is a top-level template\n\nThis is a sub-template.\n\n You will see this X times\n You will see this X times\n You will see this X times\n\nThe value of Y is: 10 import can also be used as an alias for render , this may\nbe more intuitive if the sub-template originates from a plugin for example. A Note on Path References Origen is fairly flexible when it comes to working out the path to a sub-template\nfrom a render method call. Generally the following rules apply: The leading underscore does not need to be added The .erb does not need to be added The filetype extension does not need to be added if it is the same as the calling\ntemplate’s extension Paths can be either: Relative to the calling template Relative to Origen.root Absolute Paths can also be a reference to a plugin’s shared directory, see here for\ndetails - Sharing Templates Defining Defaults A sub-template can define parameter defaults similar to a regular Ruby method,\nhere is the above example re-written to add default values that will be used\nif the parent template does not specify one of both of the options: % # Default option values...\n% options = {\n% x: 5,\n% y: 20,\n% }.merge(options)\nThis is a sub-template.\n\n% options[:x].times do\n You will see this X times\n% end \n\nThe value of Y is: <%= options[ :y ] %> Note: There are reserved options keys that should not be altered when passing options\nto a sub-template, otherwise the compiler will not function correctly. [ :scope , :file , :top_level_file ] Using Sub-Templates for Layout The render method also supports a block form which can be used\nto surround content from the parent template with header and footer content\nfrom the sub-template.\nDefine where the parent content should go using the yield keyword\nwithin the sub-template: This is some header content from the sub-template. <%= yield %> This is some footer content from the sub-template. Call in a parent template like this: % render \"sub_template\" do\n\nThis is some content from the parent template.\n\n% end This will compile to: This is some header content from the sub-template.\n\nThis is some content from the parent template.\n\nThis is some footer content from the sub-template. Options can be passed to the block form as you would expect: % render \"sub_template\", x: 5 do Nesting Sub-templates can themselves render other sub-templates. There is no limit on\nthe depth of template nesting and this can be used to build complex output from\nlayers of building blocks. Indenting Render will accept an :indent option to indent the compiled text\nby the given number of spaces: <%= render ' sub_template ' %> <%= render ' sub_template ' , indent : 2 %> <%= render ' sub_template ' , indent : 4 %> This would produce: Some lines from\nthe sub template\n Some lines from\n the sub template\n Some lines from\n the sub template A Note on Performance Sub-templates are much slower to process than content generated from a helper . Normally this is not\na problem but if for example a sub-template is rendered 1000 times within\na template file then you might be waiting quite some time for it to process. Normally this type of situation would occur when the sub-template is only generating\na single line and replacing it with a helper would immediately solve the\nperformance problem. As a general rule of thumb if you need to generate one or two lines of content\nthen use a helper, otherwise use a sub-template. A Note on State A sub-template is always evaluated with a fresh target load which means that state\ncannot be carried forward from the parent template via the target models. Generally this makes for more predictable behavior and ensures that customization of\nthe sub-template output can only be done via option arguments. Over time use of the model state to customize the sub-template output can result\nin compile order dependencies starting to creep in, and potentially this can be\nvery dangerous when it comes to compiling production critical output like test\nprogram sheets. However in cases where rendering performance is an issue and the implications of preserving\nmodel state into the sub-template are understood, the target refresh can be inhibited\nby using the following option: <%= render ' sub_template ' , preserve_target : true %> Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/controllers/direct/": {
    "title": "Direct Controllers",
    "subtitle": "Controllers",
    "body": "Controllers Direct Controllers Direct controllers provide identical functionality to Shadow controllers and you should read that guide first to understand the background here. Direct controllers are designed to work in the case where the model for a given IP block\nis managed by a 3rd party and not the test engineer responsible for the given block. Often\nthis may exist as part of a complete device model as shown here: From the perspective of the ATD test engineer, how the model is constructed is unimportant and\nthe main thing they need to know is what is the path to their sub-model of interest.\nLet’s say in our example that the model is instantiated as $model and the path to the\nATD model is $model.atd . Controller Implementation Creation of the controller is almost identical to the example Shadow controller . The key difference is that instead of linking the controller to a model class who’s instances it should shadow,\nit is instead linked to a model instance: # lib/atd_test_block/atd_controller.rb module ATDTestBlock class ATDController include Origen :: Controller model path : \" $model.atd \" # ATD pattern API implementation as before end end Instantiating the Controller This is where the main difference between Shadow and Direct controllers exists, the direct controller\nneeds to be instantiated directly: $model = SoC :: Eagle .new # Instantiates a model of the target device atd = ATDTestBlock :: ATDController .new\n\natd.convert( 10 ) # => <BitCollection> Once instantiated the atd object above will otherwise behave identically to the Shadow controller example . Typical Integration Application environments designed in this manner are a fairly recent development, and the best\npractices for how to build them are probably still to emerge. However here is one approach that would work;\nfirst the top-level controller would be created and managed by the top-level test engineer: class EagleController include Origen :: Controller model path : \" $model \" # Instantiate a model whenever a new controller is instantiated def initialize (options = {}) $model = Eagle .new(options) end # Instantiate an ATD controller as required def atd @atd ||= ATDTestBlock :: ATDController .new end end The target would instantiate the top-level controller, not the model: $dut = EagleController .new The ATD API is now available within the ecosystem as per the Shadow controller example : $dut .atd.convert( 10 ) # => <BitCollection> Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/controllers/introduction/": {
    "title": "Introduction",
    "subtitle": "Controllers",
    "body": "Controllers Introduction Controllers are a concept used for pattern generation and they are responsible for\ncontrolling a given model. As will be discussed in more detail in the pattern generation section ,\nit is bad practice for any 3rd party to reach into a model and directly\naccess its registers. This is because it tightly couples the 3rd party to the current\nimplementation of the given IP, which means that if the IP changes in the future then all\nof the 3rd parties who directly access the model’s internals may need to understand the\nchange. This can lead to test bugs, brittle\nenvironments, and significant maintenance issues as an application begins to scale. Instead it is better for the model to expose a consistent API (a set of methods) to allow the\n3rd party to invoke the functionality provided by the given IP, while shielding them from\nthe internal implementation details and the impact of future changes.\nOriginally there was no concept of a controller and such an API was created directly\nwithin the model itself,\nhowever this led to the model being used for two distinct concerns: Modelling the properties of the silicon IP and tracking state Implementing an API for pattern generation The first concern can generally be thought of as the responsibility of the design engineer,\nit is an immutable and unambiguous representation of the hardware as it was at the point\nwhen it taped out. As such, it never really changes until a new version of the hardware is released. The second concern has a different owner, the test engineer, and it is also much more fluid - \nnew functions can be added and the implementation of existing functions can change over time. It therefore made sense to separate these two completely different responsibilities given\ntheir completely different ownership models and lifecycles. So a given IP now has the following\ncomponents in the Origen domain: A model - responsible for modelling the hardware properties of the IP and tracking its state A controller - responsible for implementing an API to control the IP within test patterns A significant advantage of this architecture is that it allows the model to be created manually\nat first, and then later swapped out for a fully or partially imported model with no changes required\nto the controller or the wider ecosystem. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/controllers/shadow/": {
    "title": "Shadow Controllers",
    "subtitle": "Controllers",
    "body": "Controllers Shadow Controllers There are two flavors of controller. These provide exactly the same functionality, but\nthey are setup slightly differently and are designed to support two distinct approaches of\ncreating models within a test engineering application. The first type, the so called Shadow Controller, supports the case where the model\nis created and maintained by the test engineer for the given IP block. So for example, let’s say we have a test engineer who is responsible for an analog-to-digital\nconverter (ATD) IP, and they have decided to create an Origen plugin which will provide\na complete test solution for this IP.\nThis plugin will provide both the model and the controller as shown below: Here is a simple ATD model implementation which defines some register: # lib/atd_test_block/atd.rb module ATDTestBlock class ATD include Origen :: Model def initialize (options = {})\n instantiate_registers end def instantiate_registers # ATD control register reg :ctrl , 0x0024 do |reg|\n reg.bit 7 , :coco , access : :ro reg.bit 6 , :aien reg.bit 5 , :diff reg.bit 4 .. 0 , :adch , reset : 0x1F end # ATD data result register reg :result , 0x0028 do |reg|\n reg.bit 15 .. 0 , :d end end end end Controller Implementation A common thing that users of our test block might want to do is to use it to make the ATD perform a conversion. Let’s create a controller to provide the user with the following API: result = $dut .atd.convert( 10 ) # Perform a conversion on the voltage at ATD input channel 10 and return the result # The caller can then process the result as they wish, here for example to capture it to the tester result.store! A controller is implemented as follows, this is just a regular Ruby class that includes the Origen::Controller module: # lib/atd_test_block/atd_controller.rb module ATDTestBlock class ATDController include Origen :: Controller end end Naming of controllers can be significant, here Origen will know that this this the controller for the ATD model since we have followed the naming convention: <model name>Controller If you cannot follow this convention (the main reason would be if the model lives in a different namespace), \nthen you can supply the class of the model like this: # lib/atd_test_block/atd_controller.rb module ATDTestBlock class ATDController include Origen :: Controller model class_name : \" SomeOtherNamespace::ATD_M325 \" end end The controller now gives us the place to create our pattern API, here is the covert method \nimplementation: # lib/atd_test_block/atd_controller.rb module ATDTestBlock class ATDController include Origen :: Controller # Convert the input on the given channel to a digital representation. # # An Origen::Register::BitCollection will be returned containing the result. def convert (channel) # Launch the conversion by setting the channel ctrl.adch.write!(channel) # Wait to complete tester.wait( time_in_us : 100 ) # Verify the conversion has completed ctrl.coco.assert!( 1 ) # Return the result (the data bits from the result register) result.d end end end A key point to note from the above is that the controller has direct access to the registers of\nthe model that it controls, that is you can call ctrl instead of having to drill\ndown through the global namespace ( $dut.atd.ctrl ). Instantiating the Controller Shadow controllers are never instantiated directly, instead Origen will automatically materialize\nthem whenever a new instance of the model comes into being. atd = ATDTestBlock :: ATD .new # Instantiates the model, a controller will also be created automatically This is where the name comes from, whenever a model is created it is shadowed by a corresponding\ncontroller. So how do we invoke our controller API? We simply call the methods on the model: atd = ATDTestBlock :: ATD .new\n\natd.convert( 10 ) # => <BitCollection> Origen employs some Ruby trickery such that the object assigned to atd above will\nrespond to the methods available to the model and the controller - models will proxy (send) methods\nthat they don’t recognize to their controller and vice versa. Most of the time then, it doesn’t matter whether the atd object is actually the model\nor the controller, they will respond the same. However if for some reason you really do need to deal directly with one or the other then you can\nuse the following API: atd.model # => <ATD instance> atd.controller # => <ATDController instance> Typical Integration Such a test block would normally be plugged into a top-level application in order to generate\npatterns for a target device. The ATD test block’s integration guide should instruct the top-level test engineer to instantiate the\nATD model within the top-level model like this: # lib/eagle.rb class Eagle include Origen :: TopLevel def initialize (options = {})\n sub_block :atd , class_name : \" ATDTestBlock::ATD \" , base_address : 0x1000_2000 end end The ATD API provided by the ATD test engineer is now available to the Eagle device’s test\nengineers: $dut = Eagle .new $dut .atd.convert( 10 ) # => <BitCollection> Transitioning to an Imported Model If at some point the ATD test engineer gets access to an XML-based or similar definition of\nthe ATD registers from the design team, then the model can be simplified like this: # lib/atd_test_block/atd.rb module ATDTestBlock class ATD include Origen :: Model include CrossOrigen def initialize (options = {})\n cr_import( path : \" #{ Origen .root! } /ipxact_files/atd_regs.xml \" ) end end end See the Cross Origen plugin for more details on\nimporting 3rd party data formats. If on the other hand someone comes along and says, “ok everyone, from now on a full IP-XACT\nrepresentation will be available for every device”, then it would be time to move to\na Direct Controller… Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/documentation/api/": {
    "title": "API Generation",
    "subtitle": "Documentation Generator",
    "body": "Documentation Generator API Generation Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/documentation/deploying/": {
    "title": "Deploying",
    "subtitle": "Documentation Generator",
    "body": "Documentation Generator Deploying Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/documentation/introduction/": {
    "title": "Introduction",
    "subtitle": "Documentation Generator",
    "body": "Documentation Generator Introduction Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/documentation/linking/": {
    "title": "Linking",
    "subtitle": "Documentation Generator",
    "body": "Documentation Generator Linking Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/documentation/markdown/": {
    "title": "Markdown",
    "subtitle": "Documentation Generator",
    "body": "Documentation Generator Markdown Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/documentation/styling/": {
    "title": "Styling",
    "subtitle": "Documentation Generator",
    "body": "Documentation Generator Styling Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/documentation/testing/": {
    "title": "Testing",
    "subtitle": "Documentation Generator",
    "body": "Documentation Generator Testing Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/appcallbacks/": {
    "title": "Application Callbacks",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Application Callbacks The callback pattern can also be used in application code where it can be used\nto provide applications and plugins with a de-coupled way to hook into each\nother’s processes/flows. A call to all listeners for a specific callback method is made like this: Origen .listeners_for( :my_specific_callback_method ).each do |listener|\n listener.my_specific_callback_method( any : :options , you : :want , to : :pass ) end Callback handlers (the my_specific_callback_method in the example above) can be\nimplemented in the application’s (or plugin’s) application.rb or any instantiated\nobject that includes the Origen::Callbacks module (this is automatically\nincluded by Origen::Model ). Note: If adding the callback handler to the config/application.rb file in a\n plugin, it will only be called when it is considered the current\n plugin within its host application.\n See Current Plugin for\n more information on how to set the current plugin. A Practical Example Let’s say in a test engineering scenario that the top-level model has some logic to generate\nsome vectors to sync the DUT to the tester.\nOnce the DUT has been sync’d individual test block owners may want to take some action within\ntheir models to reflect this change of events. Since this top-level model could potentially be used by many test blocks it is not\npractical for the top-level to maintain a list of them and call them individually.\nInstead it is better to use a callback pattern where the top-level broadcasts that\nan event has just taken place and then anyone who cares can listen for the broadcast\nand anyone who doesn’t care need take no action. To implement such a system the top-level object can do this: class MySoC include Origen :: TopLevel # Sync the DUT to the tester def sync_up # Logic to sync up the DUT goes here # Now let everyone know that the DUT is now sync'd Origen .listeners_for( :on_sync_up ).each do |listener|\n listener.on_sync_up end end end Then in the test block code the test engineer who wants to do something on sync up\ncan simply implement the necessary callback handler: class MyTestBlockModel include Origen :: Model def on_sync_up # Action to take when the DUT has been sync'd end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/callbacks/": {
    "title": "Callbacks",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Callbacks Callbacks provide a way for an application to hook into the Origen process\nand have the opportunity to modify the standard behavior in some way. This could also be accomplished by redefining any of Origen’s code at application-level\nbut that approach\nis not recommended since it leaves the application at risk of breaking if Origen ever\nmakes changes to how things work internally. Callbacks on the other hand are an official API that will always work between releases. Note that it is very easy to add additional callbacks to Origen, so if you can see the need\nfor one that is not already covered please contact us via the community channels to discuss. Registering Listeners Callbacks work by registering listeners with Origen. As the Origen process executes\nit will come across various points where callbacks have been enabled and which will cause\nOrigen to pause and ask all of the listeners if they have any code that they wish to execute.\nIf so control will transfer to the listener who will execute something and who may or may not return\ncontrol back to the Origen process when complete. In other words Origen will call-back to the application at various points during the process. A listener can be any object instance within your application and by default the application\nitself (as defined in config/application.rb ) and any classes which include Origen::TopLevel or Origen::Model are already registered as listeners. Additional custom classes can be registered by simply including the callbacks module: module NVM class CallbackHandlers include Origen :: Callbacks end end Note that listeners have to be object instances, so in the example above the listener is only\nregistered when the application creates a new instance of CallbackHandlers .\nIf an instance is never created then the callbacks implemented in that class will never be\ncalled. This is particularly true of any objects that are defined as sub-blocks since the sub-block is not actually instantiated until the point where it is first referenced\nby an application. Note! One exception to the above rule is the on_create callback.\n Since this is commonly used as a delayed version of initialize, Origen will invoke that method\n at the point when the listener object is instantiated if the on_create callbacks\n have already been called. Persistent Listeners By default the pool of listeners is cleared out before a target load and they will be replaced\nby whatever objects are instantiated by the new target.\nIn most cases this is the desired behavior and everything in the application will behave\nas you would expect. However in some cases it may be desired to setup callback listeners that will persist across\ntarget loads so that they keep listening for the entire duration of an Origen thread.\nThis can be achieved by including the PersistentCallbacks module instead: module NVM class PersistentCallbackHandlers include Origen :: PersistentCallbacks end # Instantiate an instance of this class immediately when this file is loaded, this object will # then listen for the remainder of the Origen thread PersistentCallbackHandlers .new end A common use case is to use a persistent callback listener that implements on_load_target to\nimplement common target behavior - i.e. implement logic that should run for every target.\nMost crucially plugins can take full advantage of this to augment all of the targets of their\nhost application. Implementing a Callback Implementing a callback is simply a matter of implementing an agreed method name within a\nlistener. So at each callback point the Origen code is basically: listeners.each do |listener| if listener.respond_to?(callback_x)\n listener.callback_x(arg_x, arg_y) end end So any listeners which don’t implement a specific callback are simply ignored. To enable the above callback our custom listener would be changed to: module NVM class CallbackHandlers include Origen :: Callbacks def callback_x (arg_x, arg_y) if arg_x == :ft_pattern puts \" Final test not supported yet! \" exit 0 end # Otherwise return to Origen end end end As mentioned the application is already registered as a listener, so the above callback_x method could be added to config/application.rb and it would be called at the appropriate\ntime. Calling Order If an application has mutliple listeners for the same callback then they will all get called,\nhowever the order that they are called in is undefined unless otherwise specified in the\ndocumentation for a particular callback (e.g. startup and shutdown callbacks). Generally if calling order is important the recommended approach is for the application to\nimplement a single callback and then from there co-ordinate calling any additional application\nmethods that need to be run. Available Callbacks There now follows a listing of all available callbacks, these have been split up by function: Environment Setup Environment Teardown Generation Mode Changed Reset Pattern Generation Program Generation Web Compiler Release Process Intializing Models Environment Setup before_load_target This callback is triggered immediately before the target is loaded. The intended use case is to allow any domain specific clean up that needs to be done when reloading\nor changing the target during an Origen thread of execution.\nOrigen will take care of ensuring that the top-level model, the tester and all callback listeners are\nsafely removed and/or re-instantiated between target loads, and in the vast majority of cases the\napplication should never need to use this. on_create This callback is triggered immediately after the target is loaded. The intended use case is to allow the application to complete any target object initialization that may\nbe dependent on other target objects. \nIn other words you can think of this like a regular initialize method but one where\nall objects instaniated by the target are guaranteed to be available. No return value is expected. include Origen :: Callbacks def initialize # Would be creating a target instantiation order dependency by doing this here # tester.do_something end def on_create # But not here tester.do_something end on_load_target This is basically an alias of on_create and it behaves in exactly the same way. Conceptually though it reflects a different way of using this callback: on_create can be thought of\nas an enhanced version of initialize at a model level, whereas on_load_target can be thought of as\na way to augment all targets with common behavior. See the section on Persistent Listeners above for some more discussion on this. on_top_level_instantiated(top_level_object) This callback is triggered immediately after a top-level object (an object that includes the Origen::TopLevel module, normally an object representing the top-level of the SoC)\nis instantiated. No return value is expected. include Origen :: Callbacks # Automatically instantiate a RAM model whenever a DUT model is instantiated, the size will # be determined by the ram_size attribute of the DUT def on_top_level_instantiated (dut) $ram = MyPlugin :: RAM .new size : dut.ram_size end interactive_startup This will be called immediately before giving control to the user when opening an interactive\nconsole session (by running origen i ).\nThe target will already be loaded prior to calling. The intended use case is to give the application a chance to perform a device setup sequence in the\ncase where the environment is connected to an Origen Link compatible tester driver. # This is called automatically at the start of an interactive session (origen i) def interactive_startup # Run the regular pattern startup method upon opening the console to put the device in test mode startup if tester.link? end interactive_shutdown This will be called immediately before shutting down an interactive console session. The intended use case is to shutdown the device in the case where the environment is connected\nto an Origen Link compatible tester driver. # This is called automatically at the end of an interactive session (origen i) def interactive_shutdown # Run the regular pattern shutdown method to put the device in reset shutdown if tester.link? end Environment Teardown on_origen_shutdown This callback is triggered at the very end of an Origen thread of execution and is \nguaranteed to be called even if the thread crashes. An example use cases is to ensure that any temporary files are deleted. Mode Changed on_mode_changed This callback is triggered whenever an object changes its current mode .\nIt takes an options hash as an argument with the recently changed mode being passed. It can be used to change other DUT objects, \nsuch as clocks and register settings. def on_mode_changed (options) if options[ :instance ] == self case options[ :mode ] when :mode1 clocks( :coreclk ).setpoint = 1.2 .Ghz\n clocks( :memclk ).setpoint = 600 .Mhz when :mode2 clocks( :coreclk ).setpoint = 1.0 .Ghz\n clocks( :memclk ).setpoint = 500 .Mhz end end end Generation before_lsf_submission This callback is triggered immediately before submitting a batch of jobs to the LSF. No return value is expected. before_generate(options) This callback is triggered immediately before launching a generate operation, that is before\nstarting the current batch of program generation, pattern generation or compile jobs. No return value is expected. before_generate_local(options) As above but only called when running locally. before_generate_remote(options) As above but only called when running on a remote LSF machine. Reset The reset callbacks will kick in when the reset or reset! method\nis called on the top-level object. They will be executed in the following order: before_top_level_reset shutdown (reset! only) on_top_level_reset! (reset! only) on_top_level_reset registers are reset here startup (reset! only) after_top_level_reset Generally with all reset callbacks the application code is not expected to take care of\nreseting registers or any other Origen-owned objects.\nOnly state specifically setup by the application code should need to be teared down and\nre-established. before_top_level_reset Called as soon as the reset or reset! method is called on the\ntop-level object and before any other reset activity takes place. This callback should not be used to generate reset vectors, use the shutdown callback for that. No return value is expected. def before_top_level_reset @some_state_attribute = nil end on_top_level_reset Called when the reset or reset! method has been called on the\ntop-level object and after the top-level has been shutdown. No return value is expected. def on_top_level_reset @some_state_attribute = nil end on_top_level_reset! Called only when the reset! method has been called on the top-level object,\notherwise the same as reset . after_top_level_reset Called at the very end of a reset sequence initiated by calling reset or reset! on the\ntop-level object at which point the top-level has already been re-started. This callback should not be used to generate reset vectors, use the startup callback for that. No return value is expected. def after_top_level_reset @some_state_attribute = nil end Pattern Generation startup(options) Called at the start of a Pattern.create block, this callback provides an opportunity to\nimplement startup vectors. It will also be called as part of a within-pattern reset sequence initiated by calling reset! on the top-level object. Any options supplied to Pattern.create are passed in as an argument. The top-level (DUT) object is guaranteed to be called first for this callback, this enables\nthe common case where the top-level will generate the mode entry vectors from\nthis callback and then child modules can generate any additional vectors safe in the knowledge\nthat mode has already been entered. No return value is expected. def startup (options)\n tester.set_timeset( \" nvmbist \" , 40 )\n dut.pin( :reset ).drive!( 1 ) end shutdown(options) Called at the very end of a Pattern.create block, this callback provides an opportunity to\nimplement reset vectors. It will also be called as part of a within-pattern reset sequence initiated by calling reset! on the top-level object. Any options supplied to Pattern.create are passed in as an argument. The top-level (DUT) object is guaranteed to be called last for this callback, this enables\nthe common case where the child modules can insert any shutdown/safe-state vectors before\nthe top-level finally pulls reset. No return value is expected. def shutdown (options)\n dut.pin( :reset ).drive!( 0 ) end before_pattern(pattern_name) This callback is triggered immediately before running a Pattern.create block. At this point the target is fully loaded but the pattern is not yet opened - so you can’t\ngenerate vectors from here. The intended use case for this callback is to establish state within your models based on the\npattern name. This can be used in conjunction with a pattern name translator to generate\nvariants of your existing patterns without having to create a new pattern source. No return value is expected. # If the requested pattern has 'trimmed' in the name then look for the equivalent # source file without 'trimmed' in the name. # The output pattern will still contain 'trimmed' in the name. config.pattern_name_translator do |name| if name =~ / trimmed / { source : name.gsub( \" trimmed_ \" , \" \" ), output : name} else name end end # Setup the dut model differently if generating a pattern for a trimmed device def before_pattern (pattern_name) if name =~ / trimmed / dut.apply_default_trims = false end end before_pattern_lookup(requested_pattern) This callback is triggered before Origen searches for the requested pattern source. The intended use case is to give the application a chance to dispatch the pattern itself,\nor to decide to withhold it based on some properties of the current target. If the callback returns a value of false or nil then Origen will abort further processing\nof this pattern and move onto the next one.\nOrigen will proceed to dispatch the pattern as normal\nif any other value is returned. def before_pattern_lookup (requested_pattern) if requested_pattern =~ / blk_1 / # Only proceed with this pattern if the current target has a blk 1 dut.has_blk1? else # Proceed as normal requested_pattern end end pattern_generated(path_to_generated_pattern) This callback is triggered at the end of every pattern that is generated, the path to\nthe generated file (wrapped in a Pathname) is passed to the listener. The intended use case is to give plugins a hook to kick off additional operations at the\nend of a pattern being generated, such as to go and simulate it or to compile it to a\nbinary. Normally this callback would be implemented in a persistent listener within a plugin\nto have the plugin called after every pattern that is generated. No return value is expected. module VirtualTester class PersistentCallbackHandlers include Origen :: PersistentCallbacks def pattern_generated (path_to_generated_pattern) if $vt_simulation_enabled # Set this back when the command was launched or however you want to enable VirtualTester :: Runner .new(path_to_generated_pattern) end end end # Instantiate an instance of this class immediately when this file is required, this object will # then listen for the remainder of the Origen thread PersistentCallbackHandlers .new end Program Generation on_flow_start(options) Called at the start of a top-level Flow.create block, note that it is not called at the\nbeginning of sub-flows that are included by the top-level flow. Any options supplied to Flow.create are passed in as an argument. No return value is expected. on_flow_end(options) Called at the very end of a top-level Flow.create block, note that it is not called at the\nend of sub-flows that are included by the top-level flow. Any options supplied to Flow.create are passed in as an argument. No return value is expected. on_resource_start(options) Logically equivalent to on_flow_start, except this one will be called when the top\nlevel is a Resource.create block instead of a Flow.create block. on_resource_end(options) Logically equivalent to on_flow_end, except this one will be called when the top\nlevel is a Resource.create block instead of a Flow.create block. program_generated This callback is triggered after a test program has been completely generated and all files have been\nwritten.\nNo particular arguments are passed in, however the Origen.interface instance for the program that was\njust generated is still live and the application should be able to retrieve any meta data it might want\nabout the program from there. No return value is expected. Web Compiler before_web_compile(options) This is called immediately prior to running the requested origen web compile operation\nand it provides the application with an opportunity to dynamically generate some templates\nfor the compiler to execute. The command line arguments are decoded and available in the given options hash. No return value is expected. after_web_compile(options) This is called immediately after running the requested origen web compile operation\nand provides the application with an opportunity to add anything else to the web/output\ndirectory. The command line arguments are decoded and available in the given options hash. No return value is expected. after_web_site_compile(options) Similar to after_web_compile , except that this one will only be called when\na request has been made to compile the entire web site, i.e. when origen web compile has been called without a file argument(s). The command line arguments are decoded and available in the given options hash. No return value is expected. Release Process validate_release This is called immediately prior to the release (origen rc tag) process and gives the application\na chance to do any final checks to authorize that the release can go ahead. No return value is expected but the callback handler is expected to exit the process if\nit decides that the release should be aborted. Typically this hook would be used to launch the application’s test suite and if it fails\nabort the process, here is an example: # Ensure that all tests pass before allowing a release to continue def validate_release if !system( \" origen specs \" ) || !system( \" origen examples \" )\n puts \" Sorry but you can't release with failing tests, please fix them and try again. \" exit 1 else puts \" All tests passing, proceeding with release process! \" end end before_release_tag(identifier, note, type, selector, options) This callback is triggered immediately before the application is tagged, all release properties\nare available in the arguments. No return value is expected. before_release_gem This callback is triggered immediately before the gem is built if the application is a plugin.\nIt is not called at all if the application is a top-level app. It can be used to prepare files to be included in the gem package. No return value is expected. after_release_gem This callback is triggered immediately before the gem is built if the application is a plugin.\nIt is not called at all if the application is a top-level app. It can be used to clean up after building the gem package. No return value is expected. after_release_tag(identifier, note, type, selector, options) This callback is triggered immediately after the application has been tagged and before the\nrelease email has been sent. If the callback doesn’t return then the release email will not be sent. No return value is expected. after_release_email(identifier, note, type, selector, options) Called at the very end of the release process. This callback is commonly used to kick off any doc builds or other post release tasks within\nthe application. No return value is expected. # Example of automatically deploying documents after a tag def after_release_email (tag, note, type, selector, options)\n command = \" origen web compile --remote --api \" Dir .chdir Origen .root do system command end end before_deploy_site Called immediately before a web site is deployed. This gives the application a chance to add any additional files to the web site\nbefore it is deployed. No return value is expected. # Generate a test coverage report and add it to the web site def before_deploy_site Dir .chdir Origen .root do system \" origen specs -c \" system \" mv #{ Origen .root } /coverage #{ Origen .root } /web/output/coverage \" end end Initializing Models origen_model_init Called only when a class or module has a class method called origen_model_init AND when said class mixes in Origen::Model . This will be called during the class’ instantiation process, when the class has been allocated but before\nit has been initialized using its own initialize method. This can be used to boot modules or\nclasses using Origen and leaving a module’s included? method alone. This differs from the pre_initialize callback in that origen_model_init will recurse\ninto the inherited modules and classes. This method should accept a single argument, which is the allocated class instance that called origen_model_init . For example: module A def self . origen_model_init (instance_of_caller)\n puts \" init module A - called by #{ instance_of_caller.class } \" end class B def self . origen_model_init (instance_of_caller)\n puts \" init class B in module A - called by #{ instance_of_caller.class } \" end end end class Parent include Origen :: Model include A end Parent .new #=> \"init module A - called by Parent\" #=> \"init class B in module A - called by Parent\" <= this is called prior to any A::B initialization. #=> Instance of Parent class Note that included modules and classes do not need to mix in Origen::Model . Only the class including\nsaid modules and classes. Again, this is for use in booting included classes and modules, not in booting the parent. origen_model_init will NOT be called in following and pre_initialize should be used: class Parent include Origen :: Model include A def self . origen_model_init (instance_of_caller)\n puts \" origen_model_init in Parent \" end def self . pre_initialize puts \" pre_initialize in Parent \" end end Parent .new #=> \"init module A - called by Parent\" #=> \"init class B in module A - called by Parent\" #=> \"pre_initialize in Parent\" #=> Instance of Parent class Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/commands/": {
    "title": "Adding Commands",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Adding Commands Applications can add their own custom commands to the Origen namespace which makes\nit very easy to distribute and document custom scripts that support the application environment.\nOf course like everything else these scripts will have full access to the device models\nby default. Commands should be added to the file config/commands.rb in the first instance\nand as they grow you can extract the larger commands out to their own files. A skeleton config/commands.rb file should already exist in your application and\nwhen an origen command is launched via the command line Origen gives the application\ncommand file the first shot at fulfilling it.\nSo in fact it is also possible to override the built-in commands if you ever have a need to do so. An empty command file has this structure: aliases ={\n} # The requested command is passed in here as @command, this checks it against # the above alias table and should not be removed. @command = aliases[ @command ] || @command # Now branch to the specific task code case @command else @application_commands = <<-END END end When the command is launched the first argument, the command name, will be available in the instance\nvariable @command .\nYour code should interrogate this variable to decide whether the command request is one that should be\nhandled by your application, or else left for Origen to dispatch (in the skeleton commands file all\nrequests are simply passed through to Origen by default). Let’s say for example that we want to implement a command that will print the current time, we could\naccomplish this like so: aliases ={ \" time \" => \" current_time \" } # The requested command is passed in here as @command, this checks it against # the above alias table and should not be removed. @command = aliases[ @command ] || @command # Now branch to the specific task code case @command when \" current_time \" puts Time .now\n exit 0 else @application_commands = <<-END current_time Print the current time (aliased as \"time\") END end The following points are worth noting from this example: We implemented an alias of “time” for the “current_time” command. This means that it\ncan be launched either via origen current_time or the more succinct origen time . The\nuse of aliases is completely at your discretion and they are not required. The command code should always complete with exit 0 . This is to end the current command\nrequest since otherwise the request will then fall through to Origen which will attempt to process it. You can document your commands via the @application_commands variable, this should\nbe a simple one liner that describes what your command does. This information will be available to the\nuser when they run origen -h . More detailed documentation for your command can be added\nby adding support for command options (see below). Loading the Application Such commands will execute very quickly since they don’t bother to load any of your\napplication environment, but what if you need to access your models? The application will load automatically anytime you reference Origen.app , this\nwill load your config/boot.rb file and all of your models and other logic\nwill then become available.\nOne other useful side effect of this for\nscripting purposes is that it will make the root directory of your application available\nvia Origen.root . For example: MyClass .do_something # => I want to access my code here but this is giving an error Origen .app # Make a reference to the application, this will load it if is not already loaded MyClass .do_something # => Now it works Loading the Target See the dedicated section on Programming the Runtime Environment . Handling Command Options Most scripts will benefit from giving the user some options to configure the behavior and this is easy to add.\nAny command arguments or options passed in by the user will be available via the ARGV array. Note! -d is a reserved option which you cannot use, Origen uses this to enable the debugger and will strip it\nout of ARGV before handing it over to your command code. You can actually query this variable manually to decide what to do, but it is recommended that you use\nthe Ruby OptionParser library\nwhich makes it very easy to both parse user options and to document them. Let’s say that we wanted to give the user the ability to specify what format the time should be presented\nin by using the strftime method. This could\nbe accomplished like this: aliases ={ \" time \" => \" current_time \" } # The requested command is passed in here as @command, this checks it against # the above alias table and should not be removed. @command = aliases[ @command ] || @command # Now branch to the specific task code case @command when \" current_time \" options = {}\n opt_parser = OptionParser .new do |opts|\n opts.banner = <<-END_DESC origen time - This command will print the current time using the default Time\n format, alternatively specify your own format via the -f option. END_DESC opts.on( \" -f \" , \" --format FORMAT \" , String , \" FORMAT should use strftime notation \" ) { |t| options[ :format ] = t }\n opts.separator \" \" opts.on( \" -h \" , \" --help \" , \" Show this message \" ) { puts opts; exit } end opt_parser.parse! ARGV if options[ :format ]\n puts Time .now.strftime(options[ :format ]) else puts Time .now end exit 0 else @application_commands = <<-END current_time Print the current time (aliased as \"time\") END end Note the following in the above example: We initially declare an empty hash called options which we will then populate based on the\nuser input. opts.banner can be used to specify a detailed description of how the command works. This is\nused in conjunction with the -h option which we have handled at the bottom. This should be\nincluded in all of your commands to provided a consistent user interface, the user can now\nrun origen time -h to display the command description and a summary of all \navailable options. The -h implementation is an example of how to handle Boolean options. The -f option itself is implemented as an option that accepts a String parameter, which we\ncollect and place in the options hash to make it easily available to downstream code. This allows\nthe user to run origen time -f \"%Y\" for example which will display the current year only. Moving To a New File As your application becomes more complex you will find that you want to organize your commands better instead\nof having them all dumped into a single file. In this case we could extract the command code above into the application library, lib/commands/current_time.rb , \nfor example, and then include it like this: aliases ={ \" time \" => \" current_time \" } # The requested command is passed in here as @command, this checks it against # the above alias table and should not be removed. @command = aliases[ @command ] || @command # Now branch to the specific task code case @command when \" current_time \" require \" commands/current_time \" exit 0 else @application_commands = <<-END current_time Print the current time (aliased as \"time\") END end More Examples This is obviously a very trivial example and real commands can grow to be infinitely complex.\nFor some real world examples you can look at the implementation of the built in Origen commands which have been implemented using the\nsame techniques described above. Also be sure to check out the OptionParser documentation\nwhich contains further examples and documentation on option parsing. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/commandsov/": {
    "title": "Overriding Commands",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Overriding Commands Occasionally you might come across the need to extend Origen’s built in commands\nwith application specific functionality. In extreme cases the entire command can be overridden entirely by using the\nprocedure described in Adding Commands .\nHowever in most scenarios the desire will be to add additional command switches\nto implement the custom behavior. This can be achieved by overriding the command as normal and then setting a flag\n(usually an application attribute or global variable) that your downstream application code can then act on,\nbefore handing control back to Origen to complete the command processing as normal. To document the new option you can pass the details to Origen via the @application_options variable and the new option will appear in the help\nas if it was a built-in part of the command. Additionally, you can provide a block to Origen that will be executed if the option is given. The block should\nbe passed as the last element of the array that is pushed to the @application_options variable and\ncan be specified using a lambda sytax lambda { |options| options[:some_option] = true } or \nalternately ->(options) { options[:some_option] = true } . Example In one application we added an MD5 checksum to the names of all generated patterns\nbut sometimes we needed the ability to revert back to the original names. Such an option could be implemented by using different targets but for something\nso trivial it is not worth the overhead of requiring duplicate versions of all targets\nthat need this functionality. A more efficient implementation is therefore to add a runtime option: # config/application.rb # Add an attribute to disable md5 pattern names attr_accessor :no_md5 # config/commands.rb # Add an additional option to the standard command, important not # to exit here to allow the standard Origen command to run afterwards when \" generate \" # Option definitions must be pushed into the @application_options array, don't re-assign it! @application_options << [ \" --no_md5 \" , \" Don't apply the MD5 checksum to pattern names \" ] # To specify a block to be executed by Origen's option parser (when the option is used), include # a block as the last element @application_options << [ \" --compile \" , \" Compile the pattern \" , ->(options) { options[ :myapp_compile ] = true }] @application_options << [ \" --compiler NAME \" , \" Compiler to use \" , ->(options, compiler) { options[ :myapp_compiler ] = compiler }] # Note that it is important not to delete the argument from ARGV, this is necessary to make Origen # fully aware of it, so that it can be passed on to any additional jobs invoked from this process Origen .app.no_md5 = true if ARGV .include?( \" --no_md5 \" ) # Don't exit here, allow the flow to fall through to Origen to implement the rest of the command In our application code we then implement something to the effect of: def pattern_name if Origen .app.no_md5 # code to generate original name else # code to generate with MD5 end end Now when we run origen g -h we see our new option alongside the standard options: Usage: origen g [space separated patterns or lists] [options]\n -t, --target NAME Override the default target, NAME can be ...\n -l, --lsf [ACTION] Submit jobs to the LSF, optionally specify ...\n -c, --continue Continue on error (to the next pattern)\n -f, --file FILE Override the default log file\n -o, --output DIR Override the default output directory\n -r, --reference DIR Override the default reference directory\n -d, --debugger Enable the debugger\n --no_md5 Don't apply the MD5 checksum to pattern names\n\n -h, --help Show this message Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/coreext/": {
    "title": "Ruby Extensions",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Ruby Extensions Ruby allows for any object, including all of its core classes, to be extended with new or modified\nfunctionality and such modifications are typically known as core extensions. Origen adds a number of methods to Ruby to make it more useful for use in Origen applications and more generally\nwithin the semiconductor domain. For a complete list of the available extensions go to\nthe Origen API , click on Class List in the top-right, and then all of the\nclasses listed under the Top Level Namespace contain extension. For example see\nthe extensions added to the String class. Here now is a summary of some of the most useful helpers that are available: Unit Helpers When engineering semiconductor devices we often have to deal with very large or very small numbers, Ruby’s\nnumeric classes have been extended to support most common units and to make writing spec\nlimits more descriptive, here are some examples: 50 # => 50 50 .V # => 50 50 .mV # => 50E-03 50 .uA # => 50E-06 50 .nS # => 50E-09 50 .pA # => 50E-12 50 .kHz # => 50,000 50 .MHz # => 50,000,000 50 .GHz # => 50,000,000,000 Metric Unit Conversion Helpers Similar to the unit helpers, we have provided a way to convert the number back to a string with units for\ndisplay purposes. All base units supported by the unit helpers are available as native functions. For\nany other arbitrary units, the as_units( ) function is available. 50 .as_V # => '50.0V' 50000 .as_Hz # => '50.0kHz' 5e-5 .as_A # => '50.0uA' 5e-7 .as_units( ' F ' ) # => '500.0nF' Number Formatting Helpers Displaying numbers in hex or binary format is very common, some helpers exist for that: 100 .to_hex # => \"0x64\" 100 .to_bin # => \"0b1100100\" 100 .to_hex.to_dec # => 100 100 .to_bin.to_dec # => 100 Many data sources imported by Origen use Verilog numbers represented as Strings, to represent\nthings such as memory addresses, bit size, etc. that need to be modeled as numbers. \" b10100110 \" .to_dec # => 166 \" o246 \" .to_dec # => 166 \" d166 \" .to_dec # => 166 \" hA6 \" .to_dec # => 166 \" 8'b10100110 \" .to_dec # => 166 \" 8'o246 \" .to_dec # => 166 \" 8'd166 \" .to_dec # => 166 \" 8'hA6 \" .to_dec # => 166 \" 8'o246 \" .is_verilog_number? # => true \" 8'd166 \" .is_verilog_number? # => true \" 8'hA6 \" .is_verilog_number? # => true Part Select Ruby does not natively support a Verilog style part select to allow the numeric value of a subset\nof bits to be extracted.\nUnfortunately the Ruby parser will\nnever consider 0x1234[7:0] to be valid due to Ruby’s use of a colon to pre-fix\nsymbol names.\nHowever with a little compromise we can get very close: number = 0x1234 number[ 3 .. 0 ] # => 0x4 number[ 7 .. 0 ] # => 0x34 number[ 15 .. 8 ] # => 0x12 Try Method All objects within Origen have a try method to allow application developers to preferentially\nselect the source of a given attribute. The first value provided by the first option to return a value\nwill be returned, if none return a value then nil will be returned: # Take the value assigned to db_version if present, if not fall back to version $dut .try( :db_version , :version ) # => 5 $dut .try( :missing_method_x , :missing_method_y ) # => nil Hash Hashes can be transformed to a version which will accept either string or symbol key references: # A standard hash my_hash = { :one => 1 , \" two \" => 2 }\nmy_hash[ :one ] # => 1 my_hash[ \" one \" ] # => nil my_hash[ :two ] # => nil my_hash[ \" two \" ] # => 2 # A hash with indifferent access my_hash = my_hash.with_indifferent_access\nmy_hash[ :one ] # => 1 my_hash[ \" one \" ] # => 1 my_hash[ :two ] # => 2 my_hash[ \" two \" ] # => 2 Over time Origen will transition to returning this kind of hash to application-facing methods by\ndefault, but for now you can easily apply the transform on the application side if you want to use\nthis feature. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/lint/": {
    "title": "Lint Testing",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Lint Testing What is ‘Lint and Style Testing’? Lint testing refers to looking for suspicious or unusual coding patterns which could be an\nindication of buggy or hard to maintain code. Style checking refers to ensuring that the general coding style, for example the use of indentation,\nis consistent and follows generally accepted conventions. Since Origen applications are typically developed and maintained by multiple engineers it is\nimportant to establish common coding practices so that code can be easily read and reasoned\nabout by anyone involved in the project. The Origen lint test uses a 3rd party tool to enforce\nthe Ruby community maintained style guide .\nBest of all this tool can automatically correct many of the common style violations, including\nthe (very common) inconsistent use of indentation. By taking this approach individual preferences are taken out of the equation and adherence\nto the standards are no longer reliant on individuals remembering to use spaces instead\nof tabs (for example). How to Run the Tests Invoke the lint tests via the following command, by default this will run on the application’s lib directory: origen lint To run on individual files, or other directories: origen lint pattern config/application.rb To automatically correct violations where possible: origen lint -c Waivers for Legacy Applications By default the tests will be fairly strict and will enforce most of the requirements of\nthe Ruby style guide . However many of the checks will involve some manual modification of the code to resolve them\nand for legacy applications with large code bases this is probably not worth the effort.\nIn that case an easier set of tests can be run instead: origen lint -e The easier set will mainly limit the tests to those which can be corrected automatically,\nwhich still covers the most annoying issues such as inconsistent indentation and general\ncode formatting problems. However all new applications should use the strict tests and Origen core has already been\nmade clean to the strict checks. Setting Application Defaults An application configuration option can be added to specify the default\noptions that should be applied when the origen lint command is run without\nany arguments. Here is the default value that will be present in all new Origen applications: # config/application.rb config.lint_test = { # Require the lint tests to pass before allowing a release to proceed run_on_tag : true , # Auto correct violations where possible whenever 'origen lint' is run auto_correct : true , # Limit the testing for large legacy applications #level: :easy, # Run on these directories/files by default #files: [\"lib\", \"config/application.rb\"], } Pre-Release Validation The lint test will be run automatically when a user tries to tag/release the application\nwhenever the Origen.config.lint_test[:run_on_tag] attribute is set to true as shown above. In such a case the user will not be allowed to release until the issues are resolved and\nthis should be the approach taken by all new applications. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/logger/": {
    "title": "Logger",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Logger Origen provides an API for applications and plugins to log output data to the console and to\nfiles within the application’s log directory. All log output is always written to the log files , whereas the console can be configured to increase\nor decrease the amount of log output that is displayed. Log output is created by calling the following methods… Information messages will always appear in the console unless it is set to silent: Origen .log.info \" This is an INFO message. \" Success, warning, and error messages are like information messages, except that they will be colored\ngreen, amber and red in the console respectively: Origen .log.success \" This is a SUCCESS message. \" Origen .log.warn \" This is a WARNING message. \" Origen .log.error \" This is an ERROR message. \" Finally, debug messages are like information messages, however they will only appear in the console\nwhen it is set to verbose mode: Origen .log.debug \" This is a DEBUG message. \" Deprecation Warnings It is sometimes helpful to warn your users in advance if a feature they may be using is going to\nbe removed in the future.\nMarking a feature for removal like this is called deprecating it, and a deprecation warning can\nbe generated by using the following API: Origen .deprecate \" Feature X will be removed in the next release, please use Y instead \" Note that the API is Origen.deprecate and not Origen.log.deprecate . While the latter may look like it\nworks, the former is the correct way to call it and this will allow Origen to enhance your message by\ninforming the user about where in their code they have invoked the deprecated API. Changing the Console’s Verbosity Level The console can be run with one of three verbosity levels: verbose , normal and silent . These levels\nonly affect the output which appears in the console window, the log file will always capture everything\nregardless of the verbosity level. You can enable verbose logging by adding the -verbose switch to your Origen command line: origen compile templates/web/index.html.erb -verbose To set the verbosity level to normal , you just run Origen commands without the -verbose option: origen compile templates/web/index.html.erb To set the verbosity level to silent , run Origen commands with the -silent switch: origen compile templates/web/index.html.erb -silent When in silent mode, Origen will NOT output anything to the console window and will save\neverything to the log file only. This is intended to be used when other tools are invoking Origen rather\nthan the user directly. Time Tracking Each log entry will look something like this: [INFO] 0.506[0.474] || Your helpful log message here The type of the log message is obviously shown first, and this is then followed by a timestamp. The first number shows the time in seconds since Origen was started, while the number in square brackets\nis the time since the last message was logged. Log Files All log output generated by an Origen invocation is saved to the file log/last.txt . Every time Origen is invoked this file is saved to log/last.txt.old and then a fresh log is started,\nso you always have the output from the last two invocations of Origen available. Additionally, the output that applies to a specific job is saved to job specific log files. Each test pattern,\nor program flow which is generated (or simulated) is an example of a job, as is each file that is compiled by Origen. The console output will inform you of the location of the job specific files that are generated, as shown\nin this example: [INFO] 0.005[0.005] || **********************************************************************\n[INFO] 0.031[0.026] || Generating... /home/stephen/Code/github/origen/spec/patterns/atp/nvm_j750_workout.atp\n[INFO] 0.506[0.474] ||\n[INFO] 0.509[0.003] || Pattern vectors: 146\n[INFO] 0.511[0.003] || Execution time : 0.019288\n[INFO] 0.512[0.001] || ----------------------------------------------------------------------\n[INFO] 0.576[0.064] || Log file written to: /home/stephen/Code/github/origen/log/pattern_generator/debug/j750_workout.txt\n[INFO] 0.584[0.008] || **********************************************************************\n[SUCCESS] 0.584[0.001] || Total patterns: 1\n[SUCCESS] 0.585[0.001] || Total vectors: 146\n[SUCCESS] 0.586[0.001] || Total duration: 0.019288\n[SUCCESS] 0.587[0.001] || New patterns: 0\n[SUCCESS] 0.588[0.001] || Changed patterns: 0\n[INFO] 0.589[0.001] ||\n[INFO] 0.589[0.001] || ********************************************************************** The location of the job-specific log files is: log/<job type>/<target>/<filename>.txt . No old copy of job-specific log files is automatically maintained and these will be overwritten the\nnext time Origen is asked to perform the same job. Custom Log Files Custom log files can be used to collect a specific type of data in one place. Calling Origen.log.<my_log_name> in place of one of the standard message types will cause the\ngiven message to be logged to a custom file instead. For example, these messages would be written to log/accesses.txt : Origen .log.accesses \" An access was made with this value: #{ my_val } \" By default, such messages will be formatted as per standard Origen log messages, with the message type\nand timestamp appended to the front. To output the message without this additional formatting being applied, add the format: false option: Origen .log.accesses \" An access was made with this value: #{ my_val } \" , format : false Custom log messages are never output to the console and will be captured in the applicable log file only. One old copy of the file will be maintained in the same way as it is done for log/last.txt . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/lsf/": {
    "title": "LSF API",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous LSF API The LSF is an industry standard platform that allows compute jobs, like running Origen, to be run in parallel across a pool\nof computers. As you may know, Origen makes it easy to utilize the LSF to speed up generate or compile jobs\nby simply appending -l (and optionally -w to make it automatically\npoll and wait for completion) to the command. However Origen’s internal LSF API is also available to application developers if they wish\nto leverage the LSF in their application specific functionality.\nIn fact this can even be used to wrap and manage non-Origen jobs (where the command to run\nthe job is not ‘origen …’). Preparing to Run Code Remotely Before submitting a new piece of code for remote execution give some thought as to whether\nit will cause any race conditions or competition for resources between jobs as they\nrun in parallel. When jobs are run remotely they will be executing within the same workspace from which they have been\nlaunched locally. Therefore generally have a think about whether there would be any problems if\nyou were to open up two terminals pointing to the same workspace and then run two instances\nof the same operation in parallel - this is the same as what happens when you submit to the LSF. A good example would be if your job involved importing some data to the workspace from a 3rd\nparty area. In such a case it is better to import it once before launching the jobs rather\nthan have 10 processes running in parallel all trying to import (and write to the same files)\nat the same time. To detect if code is running remotely or not you can use Origen.running_remotely? : if Origen .running_remotely? # Branch to handle something differently to account for parallel execution else # Conventional execution where the code is executing single-threaded locally end Main API Here is a summary of the main API methods, see the LSFManager API for full details. All jobs submitted to the LSF through Origen will be monitored, to abandon monitoring of\nexisting jobs the queue can be cleared like this: # Clear the LSF monitor queue Origen .lsf.clear_all Jobs are submitted like this: # Submit any Origen commands to the queue like this, you should always supply a target Origen .lsf.submit_origen_job \" generate bistcom -t p2_debug \" Origen .lsf.submit_origen_job \" compile templates/j750 -t p3_debug \" # Any application-specific Origen commands will work in the same way Origen .lsf.submit_origen_job \" my_custom_command -t p2_debug \" # Any non-origen commands can also be submitted and monitored using the more generic submit_job # method. The job will be considered passed/failed based on standard unix result codes Origen .lsf.submit_job \" cd path/to/some/dir && do_something \" If a call to submit_origen_job will invoke the same command to that from which the\nsubmission is being made then Origen will automatically forward any command options that were\npassed to the parent process. This also applies to custom commands. The jobs can then be monitored from the command line with the origen l command: > origen l\n\nLSF Status\n----------\nQueuing: 2\nRunning: 5\nLost: 0\n\nPassed: 0\nFailed: 0\n\nCommon tasks\n------------\n\nReset the LSF manager (clear all jobs): origen lsf -c -t all Origen will automatically re-launch any lost jobs and the common tasks section will tell\nyou what command to run if you want to re-launch any failed jobs. You can also wait for job completion within the Ruby/Origen thread from which they were\nlaunched: # Wait for jobs to complete, this will automatically re-try lost jobs and optionally can # retry any failed jobs (should never really be required though, any failures due to the # remote host going down or similar will automatically re-try silently). Origen .lsf.wait_for_completion # By default lost jobs will retry up to 10 times Origen .lsf.wait_for_completion( max_fail_retries : 1 ) # Retry all failures once Advanced Scheduling Sometimes a given job may not be able to run until another one has completed first, the\nAPI allows for such dependencies to be managed using job IDs. First capture the job ID of the parent job(s) when it is launched: # Each submission will return a job id which you can capture id = Origen .lsf.submit_origen_job \" generate global_subs -t p2_debug \" You can deal with the dependency resolution at Origen level by waiting for the\nindividual jobs to complete: # Wait for the parent job(s) to complete Origen .lsf.wait_for_completion id : id Origen .lsf.wait_for_completion ids : [id1, id2] # Now launch the dependent jobs The LSF itself has a mechanism for resolving such dependencies and that functionality\nis exposed via a :depends option when submitting jobs: # Dependencies can also be resolved automatically by supplying a depends argument when # submitting, for example the 3rd job here will only run once the first two have completed id1 = Origen .lsf.submit_origen_job \" g overlay_subs -t p2_debug \" id2 = Origen .lsf.submit_origen_job \" g global_subs -t p2_debug \" Origen .lsf.submit_origen_job \" g master_subs -t p2_debug \" , depends : [id1, id2] Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/remotes/": {
    "title": "Origen Remotes",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Origen Remotes What is a ‘Remote’? In some cases, your application may require access to external data that is \nkept under revision control but not necessarily as part of the Origen environment.\nFor example, you may need access to a design file that is stored with the IP and rather than store\na static copy in the application vault, you want to easy populate a local version based on a \nspecified tag. Then what you need is an Origen Remote. How to Populate a Remote Populating a remote is extremely easy, all that has to be done is to define\nthe required remote within the config/application.rb file. Three of these four details are required (tag and version are mutually exclusive): dir : The sub-directory within the Origen remotes workspace where you want the population to occur, (aka. local) vault or rc_url : The path to the vault/repo, ‘vault’ and ‘rc_url’ can be used interchangeably version : The version that you want to use tag : The tag that you want to use The difference between tag and version is that a version, if semantic, will get a ‘v’ prepended to it. This is due to a DesignSync\nrequirement. A tag will get used as-is. In the examples below the first remote will ask DesignSync for version ‘v1.0.1’, whereas\nthe second remote will ask Perforce for the tag ‘0.1.0’. Once in possession of these details add them to the config.remotes attribute. \nThis accepts an array and any number of remotes can be added, here is an example\nthat populates three remotes: config.remotes = [\n { dir : \" source/include/v_ip_ate \" , vault : \" sync://sync-15000:15000/v_ip_ate/compiler/include \" , version : \" 1.0.1 \" ,\n },\n { dir : \" mydir \" , vault : \" p4://myserver:myport//path/to/my/remote/file/myfile.xlsx \" , tag : ' 0.1.0 ' },\n { dir : \" artwork \" , rc_url : \" git@github.com:Origen-SDK/artwork.git \" , version : \" master \" , development : true } \n] Origen will populate all remotes defined by a top-level application. It will also populate all\nremotes defined by an application’s plugins, except for those which have been marked with development: true as in the 2nd example above. Setting development: true , indicates to Origen that the remote is only required when developing\nthe plugin within a standalone workspace, and that it is not required when the plugin is being\nused by a top-level application. Location Population of the remotes will occur within the remotes workspace located at the top-level \nof the receiving application. For instance, in the above example, the v_ip_ate remote would be\nlocated at: .<top>_remotes_DO_NOT_HAND_MODIFY/source/include/v_ip_ate Please note that the value of dir must be unique for each remote within the application. You can get a handle on the top-level remotes dir via the helper Origen.app.remotes_dir , as shown\nin this example: data = File .read( \" #{ Origen .app.remotes_dir } /source/include/v_ip_ate \" ) Origen Does the Rest With those details added Origen will then take care of ensuring that the dependencies\nare fulfilled every time that the application is invoked. Setting up a Remote Development Environment If you are still developing some parts of your remote, your environment setup may need to be slightly\ndifferent vs. working on a known good remote. You can configure the receiving application to use\na development workspace like this: config.remotes = [\n { dir : \" source/include/v_ip_ate \" , vault : \" sync://sync-15000:15000/v_ip_ate_c90lp/compiler/include \" , version : \" v0.0.0.dev2 \" , path : \" /proj/thao/build.22/common_vip/v_ip_ate \" ,\n }\n] When a path reference is present Origen will override the vault/version reference and\nwill setup up a symbolic link from the regular\nremote location to your development workspace - this means that the receiving application\nis now always looking at your latest development code. Origen will not allow the receiving application to be tagged when a path reference is active,\nso you don’t need to worry too much about forgetting to remove it! Defining Remotes Outside the Application File Some applications need to support multiple products using source files from other repositories, and\ncannot put product specific information in the config/application.rb file. In this case, the remotes\ncan be defined in the DUT initialization or a related callback method. Once defined, the remotes can \nthen be fetched by executing the Origen.remote_manager.resolve_remotes! method. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/revisioncontrol/": {
    "title": "Revision Control",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Revision Control Introduction While Git is fast becoming the de-facto standard revision control tool in many software domains,\nit is likely that some Origen application developers may still want to use something else.\nOrigen provides a revision control system abstraction to help Origen users switch between apps\nthat use different systems, and to help Origen and its plugins work within different revision\ncontrol environments. Currently the following systems are supported by the abstract API: Git Enovia Synchronicity Design Sync Perforce If you would like to see another system supported and you are willing\nto help us develop and pilot the driver for it, then please get in touch via\nthe community channels . Programmable API The programmable API exposes a common set of methods to the application developer that will work\nregardless of the underlying system that is being used. An revision control driver is created by instantiating a new revision controller instance, this\nrequires a reference to the remote repository, and the path to the local root directory (which\ndoesn’t have to exist yet): rc = Origen :: RevisionControl .new remote : \" ssh://git@github.com:myaccount/myproj.git \" , local : \" my/path \" rc.git? # => true rc = Origen :: RevisionControl .new remote : \" sync://sync-15000:15000/myaccount/myproj \" , local : \" my/path \" rc.dssc? # => true rc = Origen :: RevisionControl .new remote : \" p4://server:port//myaccount/myproj \" , local : \" my/path \" rc.p4? # => true In the case of an Origen application, a short cut is available (assuming the application has\nset config.rc_url in config/application.rb ): rc = Origen .app.rc\nrc.git? # => true This revision controller object provides the Revision Control API described here . Here are some examples: rc.local_modifications # => [\"lib/my_app/model1.rb\", \"lib/my_app/model2.rb\", \"lib/my_app/model3.rb\", \"lib/my_app/model4.rb\"] # Check in a single file rc.checkin \" lib/my_app/model2.rb \" rc.local_modifications # => [\"lib/my_app/model1.rb\", \"lib/my_app/model3.rb\", \"lib/my_app/model4.rb\"] # Checkout latest version of a single file, forcing overwrite of local mods rc.checkout \" lib/my_app/model4.rb \" , force : true rc.local_modifications # => [\"lib/my_app/model1.rb\", \"lib/my_app/model3.rb\"] # Check in everything rc.checkin comment : \" Added a cool feature \" rc.local_modifications # => [] Revision Control Command The origen rc command uses this API to provide a universal command line\ninterface for working with revision control systems, thereby providing the following benefits to the user: Intimate knowledge of how the underlying revision control system works is not required,\nthe command maintainers will ensure that you are using it in an efficient and correct way. The workflow remains the same regardless of what underlying revision control tool is used. Here are some examples: origen rc co # Checkout the latest version of the application, local edits will be merged\norigen rc co -v v1.2.3 # As above but a specific version\norigen rc co -f # As above but force overwrite of local edits\norigen rc co file.txt # As above but on a specific file or directory, -v and -f will work to\n\norigen rc ci # Check in the application\norigen rc ci --unman # As above but also include files that are currently unmanaged\norigen rc ci file.txt # Check in a specific file\norigen rc new file.txt # Create the given file and check in an initial version of it\n\norigen rc unman # Show unmanaged files\norigen rc mods # Show modified files in local workspace\norigen rc tag # Tag and release the application See origen rc -h for an up to date list of supported commands. ** Note on Perforce ** The Perforce revision control implementation currently only supports the ‘print’ command, \nwhich just downloads a file to a local path. This was developed to support Origen remotes using\nPerforce. None of the standard commands listed above are implemnted currently. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/session/": {
    "title": "Session Store",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Session Store The session store can be used to persist information (or state) across Origen threads\nof execution within a given workspace. Setting the current target with origen t is a example\nof session information being used to setup some state that will persist into\nfuture Origen commands that are executed within that workspace, while having no bearing on what happens\nin other workspaces. To access the session store: Origen .app.session The session is split into named stores which will be automatically created as soon as data\nis added to them,\nthis gives application developers a namespace level to keep their data organized. The namespace returns a key-value store containing all of the values in that namespace: Origen .app.session.main # => A key-value store Origen .app.session.blah # => A different key-value store Plugin developers should use a store named after their plugin, for example the ATDTest plugin would use: Origen .app.session.atd_test # => A key-value store for use by the ATDTest plugin To store values to the session simply set them like this: Origen .app.session.main[ :exec_count ] = 10 Unlike assigning values to a regular Hash variable, this value will survive between Origen\nthreads - go on fire up an origen i session and try it out: Origen .app.session.main[ :exec_count ] # => 10 Generally you can store hashes, arrays and even objects to the session although your\nmileage-may-vary with particularly rich objects. Note that in the case of storing objects the class\ndefinition must still be around when Origen tries to resurrect it from the session. i.e. you\ncannot store an object, delete the class definition for that object, and then materialize it\nfrom the session later. Similarly binary data cannot be stored to the session. There are a few helper methods for managing the session store. Origen .app.session.main[ :exec_count ] = 10 Origen .app.session.main[ :owner ] = ' Stephen ' Origen .app.session.main.has_key?( :exec_count ) # => true Origen .app.session.main.keys.sort # => [:exec_count, :owner] Origen .app.session.main.delete_key( :exec_count ) # => 10 Origen .app.session.main.keys.sort # => [:owner] A Practical Example In one of our applications, called ‘NVM’, there is a need to program firmware images\nthat are provided by the design team. Rather than duplicate the firmware images in the design and test repositories they are typically\nimported from the design repository into the test workspace at runtime (on as as-required\nbasis).\nIt is critical to keep track of what version of the firmware exists locally so\nthat if the production firmware version changes then the new version will be fetched, but if it\nis the same as what is already there then the user is not made to wait for a redundant import operation. In early Origen applications, significant logic had to be added to the application to implement\nsuch a system, but the availability of the session store now makes this trivial: # Return the associated firmware file, this will automatically fetch the new version # if the production firmware tag has changed since this was last called def firmware_file path_to_local_file = \" #{ Origen .app.imports_dir } /firmware/production.hex \" f = Pathname .new(path_to_local_file) if !f.exist? || Origen .app.session.nvm[ :local_firmware_version ] != production_tag # Clear this up front as we won't know what we will have if the checkout fails Origen .app.session.nvm[ :local_firmware_version ] = nil firmware_rc.checkout( \" production.hex \" , force : true , version : production_tag) Origen .app.session.nvm[ :local_firmware_version ] = production_tag end f end # Returns a revision controller to manage local import of firmware files def firmware_rc @firmware_rc ||= Origen :: RevisionControl .new remote : \" sync://sync-15000:15000/nvm/firmware \" , local : \" #{ Origen .app.imports_dir } /firmware \" end Global Sessions Origen also has a global session that is accessible across all Origen applications, plugins, etc., or from outside \nany of those at all! Note, however, that ‘global’ is in terms of a single user. This is not a shared session across\nthe entire Origen installation (in the case of site-wide Origen installions as referenced in the Origen Installation Guides . Accessing Origen’s global session is similiar to that of the application specific sessions and works in much the same\nway: Origen .session #=> Origen's Global Session Origen .session.globals #=> Create a new database called 'globals' available across all of Origen. # One use case encountered was to store another machine's IP that other applications would SSH into. # This IP is the same for all Origen applications for a given user (i.e., each user has their own # machine to log into). Origen .session.ssh[ :machine_ip ] = \" 255.255.255.0 \" Origen .session.ssh[ :machine_ip ] #=> \"255.255.255.0\" # --Move to another Origen workspace-- Origen .session.ssh[ :machine_ip ] #=> \"255.255.255.0\" The session itself is stored in the same fashion as the application sessions, just at a more accessible location. That\nlocation is at Origen.home , which equates to ~/.origen/ . There lives the global .session . Private Sessions By default, the session databases are accessible to the user and to members of the same group (in Unix speak, that is), and are\nreadable by everyone. The session contains a variable that can be set to instead make the session only accessible by the user.\nThis is accomplished by just setting the permissions to 0600 . To enable a private session, you can, at anytime, run: Origen .session.secret.private = true The next time that a session is updated, the permissions will be modified accordingly. Likewise, you can disable the private\ndatabase by running: Origen .session.secret.private = false If you want to create a new session that is private from the beginning, just set the private variable prior to performing\nthe first session write: # This session doesn't exist yet: Origen .session.always_secret.private = true Origen .session.always_secret[ :my_key ] = \" my value \" You can check whether a session is private or not by querying one of the methods below: Origen .session.secret.private Origen .session.secret.private? It is important to note that this is a per individual session parameter. That is, you must set this for all\nsessions that you want to make private. Another note: under the hood, this uses Ruby’s FileUtils.chmod method, which itself is platform dependent. This\nwas built with a Unix use case in mind, so your milage may vary with other operating systems. But, this is standard Ruby,\nso it should run regardless of OS and its effect. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/users/": {
    "title": "Users, Emails & Maillists",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Users, Emails & Maillists This guide describes some APIs that are available to customize the output or behavior of\nyour application to the current user, or to send emails to the current user or a group\nof users. To access an object representing the current user simply call User.current and from there many attributes can be accessed: User .current # => <user object> User .current.name # => \"John Doe\" User .current.email # => \"johndoe@example.com\" See the User API for a full list of available\nattributes.\nNote that this is contingent on the current user setting up their name and email as described here . User objects for 3rd parties can be created by supplying a name and/or email like this: thao = User .new( \" thao@example.com \" )\nthao = User .new( \" thao@example.com \" , \" Thao Huynh \" ) LDAP Integration Origen can be integrated with an LDAP employee directory, to enable this configure the LDAP\nattributes in your company’s Origen configuration .\nTo look up a user within the LDAP system an ID is required, by default Origen will take the\nlogin name of the current Linux user as there ID. User objects can now be created by supplying a single ID argument: thao = User .new( \" b53254 \" ) To see the full information that is available for a user: User .new( \" b53254 \" ).display # => Prints a listing of all information available All attributes returned by your LDAP system will have accessors, in most cases these will\nreturn an array: User .new( \" b53254 \" ).country # => [\"Vietnam\"] Sending Emails If details of your company’s email server have been added to your company’s Origen configuration , then you can\neasily send emails from your application. An email can be sent to a given user by calling the send method on the user object,\ntry this in the console to send yourself an email: User .current.send subject : \" Hello \" , message : \" Origen is cool! \" Multi-line emails can be composed using Ruby’s multi-line string syntax: user = User .new( \" b53254 \" )\n\nuser.send subject : \" Hello \" , message : <<-END Hi #{ user.name } ,\n\nThis is just a short email, to say hello!\n\nCheers, #{ User .current.name } END Group emails can be sent by talking to the Origen mailer directly, an array of user objects or\nemail addresses can be given to the :to option: message = <<-END Hi All,\n\nJust to say have a nice day!\n\nThanks, #{ User .current.name } END distribution_list = [ User .new( \" r49409 \" ), User .new( \" r6aanf \" )] Origen .mailer.send_email( subject : \" Hello \" , to : distribution_list, body : message) Maillists Origen uses maillists to send notifications of development and production releases. The maillist files\nshould be located at config/maillist_dev.txt and config/maillist_prod.txt Sample lists: # config/maillist_dev.txt\n#\n# Product team X (handles commenting like this)\nfirst.last@company.com\njohn.smith@company.com # config/maillist_prod.txt\n#\n# Some other product team\nmemory.expert@company.com # Memory Test Lead (commenting like this is ok too)\n# Example of an ID only\nlast.first\nx49509 To get a list of your application’s mailists: Origen .app.maillist_dev # => [<first.last@company.com>, <john.smith@company.com>] Origen .app.maillist_prod # => [<memory.expert@company.com>, <last.first@MYcompany.com>, <x49509@MYcompany.com>] You can pass the returned array directly to the send_email method: Origen .mailer.send_email( subject : \" Hello \" , to : Origen .app.maillist_dev, body : \" Hello to all developers! \" ) Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/utilities/": {
    "title": "Utilities & Helpers",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Utilities & Helpers Origen provides some general-purpose utlity classes and modules that can help you to better develop your applications,\nplugins, and other features. The following is a list of the utilities currently implemented by Origen: Block Args Collector CSV Data Diff File Diff Input Capture Mailer Time And Date Block Args Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Collector You may notice some features within Origen, such as registers , bits , or anything\nthat uses componentable to instantiate, are able to take either an options hash or an options block and merge the two, allowing users to work with whichever is preferred. Under the\nhood of these features, is the Collector , which allows for a block to be transformed\ninto a hash and can then be used as options for the given feature. The collector is available at Origen::Utility::Collector , but a shortcut method to create a new instance is\navailable as Origen::Utility.collector . The collector isn’t really meant to be used throughout, rather\nit is an intermediary step to join hashes and blocks. An example of using the collector is: block = Proc .new do |collector|\n collector.arg1 ' argument 1 ' collector.arg2 ' argument 2 ' end collector = Origen :: Utility .collector\nblock.call(collector)\n\ncollector.to_h #=> {arg1: 'argument 1', arg2: 'argument 2'} The result of using the collector is that each argument given as a method is transformed into a hash key/value pair. No Value Given If a method is given without a value, it will be defined and set to nil , as shown below: block = Proc .new do |collector|\n collector.arg1 end collector = Origen :: Utility .collector\nblock.call(collector)\n\ncollector.to_h #=> {arg1: nil} Using An Anonymous Collector As previously stated, one use of the collector is to transform an option block into an option hash and/or merge an existing option hash and the resulting option hash . This allows for options\nto be given either as a hash or as a block or both, depending on the nature of the options and the preference of the user. In\nthese cases, it is common to just instantiate the collector, convert it to a hash, then throw it away. This can\nbe done in a single line as: collector = Origen :: Utility .collector(&block).to_h Danger! This syntax will always work, but other syntaxes have some hidden dangers. See later in this page for details Merging Options The collector allows for automatic hash merging . The intent is to easily allow for an options hash and an options block to merge into a single combined hash . This can be achieved by passing in\ntwo options during collector initialization: hash and merge_method . # Combining a hash and block with no clashes options = { argA : ' arg A ' , argB : ' arg B ' }\nblock = Proc .new do |collector|\n collector.arg1 ' arg 1 ' collector.arg2 ' arg 2 ' end Origen :: Utility .collector( hash : options, &block).to_h #=> {argA: 'arg A', argB: 'arg B', arg1: 'arg 1', arg2: 'arg 2'} # Combining a hash and block with some keys clashing (default merging) options = { arg1 : ' has arg 1 ' , arg2 : ' hash arg 2 ' }\nblock = Proc .new do |collector|\n collector.arg2 ' block arg 2 ' collector.arg3 ' block arg 3 ' end Origen :: Utility .collector( hash : options, &block).to_h #=> {arg1: 'has arg 1', arg2: 'hash arg 2', arg3: 'block arg 3'} # Combining a hash and block with explicit merge method :keep_hash (default) options = { arg1 : ' has arg 1 ' , arg2 : ' hash arg 2 ' }\nblock = Proc .new do |collector|\n collector.arg2 ' block arg 2 ' collector.arg3 ' block arg 3 ' end Origen :: Utility .collector( hash : options, merge_method : :keep_hash , &block).to_h #=> {arg1: 'has arg 1', arg2: 'hash arg 2', arg3: 'block arg 3'} As shown, of the options that were given to both the hash and the block, the options in the hash were kept. This is the\ndefault behavior, or can be explicitly defined by providing merge_method: :keep_hash to avoid confusion. Info! Running the collector without a block will always be just the input hash. Two other merge method exists: :keep_block and :fail . :keep_block is just the\nopposite of :keep_hash and :fail will raise an error if the same option is provided by\nboth the hash and the block. Trying to set the merge_method to anything else will raise an error. options = { arg1 : ' has arg 1 ' , arg2 : ' hash arg 2 ' }\nblock = Proc .new do |collector|\n collector.arg2 ' block arg 2 ' collector.arg3 ' block arg 3 ' end Origen :: Utility .collector( hash : options, merge_method : :keep_block , &block).to_h #=> {arg1: 'has arg 1', arg2: 'block arg 2', arg3: 'block arg 3'} options = { arg1 : ' has arg 1 ' , arg2 : ' hash arg 2 ' }\nblock = Proc .new do |collector|\n collector.arg3 ' block arg 3 ' end Origen :: Utility .collector( hash : options, merge_method : :fail , &block).to_h #=> {arg1: 'has arg 1', arg2: 'hash arg 2', arg3: 'block arg 3'} options = { arg1 : ' has arg 1 ' , arg2 : ' hash arg 2 ' }\nblock = Proc .new do |collector|\n collector.arg2 ' block arg 2 ' collector.arg3 ' block arg 3 ' end Origen :: Utility .collector( hash : options, merge_method : :fail , &block).to_h #=> Origen::OrigenError #=> 'Origen::Utility::Collector detected both the hash and block attempting to set :arg2 (merge_method set to :fail)' Failure Conditions As shown above, trying to merge the same key in the hash and block when merge_method: :fail will cause an exception. There are a few other conditions that will cause the collector to fail. Since the collector tries to transform an options block into a hash, some of the syntactic rules of \nhashes are enforced on blocks. Multiple Sets The collector will fail if the same method is set after multiple times. For example: block = Proc .new do |collector|\n collector.arg1 ' hi ' collector.arg1 = ' hello ' end Origen :: Utility .collector(&block) #=> ArgumentError Even though this is technically allowed in Ruby, its the equalivent of a hash formatted {arg1: 1, arg1: 2} , which just overwrites values. There is no reason for this usage and it just\ncauses confusion (especially in large hashes or blocks), so the collector disallows this. Multiple Values In A Single Set Each method can only set one value. As such, providing any number of arguments greater than one will fail, as\nwill attempting to use both an argument and a block. For example: block = Proc .new do |collector|\n collector.arg1 ' arg1 ' , ' arg2 ' , ' arg3 ' end Origen :: Utility .collector(&block) #=> ArgumentError block = Proc .new do |collector|\n collector.arg1( ' arg1 ' ) do ' nothing ' end end Origen :: Utility .collector(&block) #=> ArgumentError This would be the hash equalivent of {arg1: 'arg1', 'arg2', 'arg3'} which is a syntax error. Also,\nsetting a value to just a block is accepted, just not a block and another value simultaneously. Caveats of Anonymous Collectors For the collector, method_missing actually returns self , instead of the value set. This\nmeans that blocks that only use the collector.arg value notation will always return the collector. The\nadvertised means of using an anonymous collector is: Origen :: Utility .collector(options, &block) However, the following may work, depending on the block: block.call( Origen :: Utility .collector) For the above case, in order to get a collector instance, the block must return the collector. If\njust using collector.arg val syntax, this will work, but collector.arg = val syntax will not.\nThis is due to Ruby’s rules that collector.arg = val will return val . Likewise, adding\nother stuff at the end of the block will also change its return value: block = Proc .new do |collector|\n collector.arg1 ' arg1 ' end block.call( Origen ::utility.collector) #=> Collector Instance block = Proc .new do |collector|\n collector.arg1 = ' arg1 ' end block.call( Origen ::utility.collector) #=> 'arg1' block = Proc .new do |collector|\n collector.arg1 ' arg1 ' ' random stuff ' end block.call( Origen ::utility.collector) #=> 'random stuff' However, if the block returns the collector itself, as below: block = Proc .new do |collector|\n collector.arg1 ' arg1 ' ' random stuff ' collector end block.call( Origen ::utility.collector) #=> Collector Instance then this will work as expected. But, this relies on the block being written in a way that is impossible to detect\nfrom the collector itself. The correct way to work around this is to use the advertised means of initializing an anonymous collector. This will\ngive you the desired result regardless of the block’s return value. block = Proc .new do |collector|\n collector.arg1 ' arg1 ' end Origen ::utility.collector(&block) #=> Collector Instance block = Proc .new do |collector|\n collector.arg1 = ' arg1 ' end Origen ::utility.collector(&block) #=> Collector Instance block = Proc .new do |collector|\n collector.arg1 ' arg1 ' ' random stuff ' end Origen ::utility.collector(&block) #=> Collector Instance CSV Data Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Diff Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . File Diff Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Input Capture Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Mailer Usage of the mailer in applications or plugins is described at sending_emails and maillist . However, with respect to the developer’s usage: Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Time And Date Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/attributes/": {
    "title": "Adding Attributes",
    "subtitle": "Models",
    "body": "Models Adding Attributes Origen is an object-oriented environment and we have already seen that the application\ndomain will be modelled by creating object instances which represent the physical silicon.\nHowever the real power of object-oriented programming comes when we start assigning attributes\nto our objects. Static Attributes Continuing our example of modelling a fictional NVM module, an obvious attribute to start with is the\nsize of our NVM memory blocks, we can add this attribute like this: # lib/nvm/memory_128_b954.rb module NVM class MEMORY_128_B954 include Origen :: Model def initialize (options={}) @size_in_kb = 128 end end end @size_in_kb is an example of an instance variable in Ruby. An instance variable\nis one where the value it contains is unique to each object instance, so for example if we have multiple\ninstances of the same class then we can update the value held by an instance variable in one of them without\naffecting the value held by the same variable in the other instances. Instances variables are globally available within a class definition, in other words you can make\na reference to @size_in_kb from any methods that are defined within that class. However to\naccess them externally we need to create a getter method: # lib/nvm/memory_128_b954.rb module NVM class MEMORY_128_B954 include Origen :: Model def initialize (options={}) @size_in_kb = 128 end def size_in_kb @size_in_kb end end end In Ruby a method implicitly returns the value of the last piece of code it executed, so the method we\njust added will return the value held by @size_in_kb .\nWe can now ask a memory block it’s size: $dut = SOC :: EAGLE_M352 .new $dut .nvm.memories.first.size_in_kb # => 128 Note that we have used a method named first above but we have not defined that anywhere.\nThe memorys method created by Origen (which we aliased as memories returns the associated sub-blocks within a Ruby array. In Ruby everything\nis an object, so an array is a built-in object that comes complete with it’s own set of useful methods\nthat we can leverage.\nRuby is very well documented, here is the page describing all of the methods available to an Array: Ruby Array . Because the above example of creating a getter method is so common, Ruby provides a shorthand. We can re-write\nthe above example as: # lib/nvm/memory_128_b954.rb module NVM class MEMORY_128_B954 include Origen :: Model attr_reader :size_in_kb def initialize (options={}) @size_in_kb = 128 end end end This creates a reader (or getter) method which will look for an instance variable of the same name and\nreturn it. If the variable of the same name doesn’t exist then it will return nil . Calculated Attributes Attributes can also be derived from functions. For example within our application it may be useful to consume the size attribute in various formats,\nlet’s create a method to return the size in bytes: # lib/nvm/memory_128_b954.rb module NVM class MEMORY_128_B954 include Origen :: Model attr_reader :size_in_kb def initialize (options={}) @size_in_kb = 128 end def size_in_bytes @size_in_kb * 1024 end end end Of course such functions can also incorporate multiple attributes, here we create a method to return\nthe size in longwords: # lib/nvm/memory_128_b954.rb module NVM class MEMORY_128_B954 include Origen :: Model attr_reader :size_in_kb , :longword_size_in_bytes def initialize (options={}) @size_in_kb = 128 @longword_size_in_bytes = 8 end def size_in_bytes @size_in_kb * 1024 end def size_in_longwords size_in_bytes / longword_size_in_bytes end end end Note that sometimes you will see attribute or method references using the keyword self which means “the current instance”. Our size_in_longwords method could be re-written as: def size_in_longwords self .size_in_bytes / self .longword_size_in_bytes end Whether or not to use the self notation is really a matter of personal preference but be aware\nof it as you may see it used in other code whether or not you use it yourself. Another point to note is that the method was not written like this: def size_in_longwords @size_in_bytes / @longword_size_in_bytes end While this would have worked equally well, it is generally bad practice to reference instance variables\ndirectly and instead it is preferable to access them through a reader method, even when referencing\nthem internally. The reason for this is that if you ever need to transform or filter the value of an attribute, it can\nbe done easily in a single place if all references to the variable are made through a reader method. Dynamic Attributes Some attributes will change value during the course of executing your application, therefore in such\ncases we need a way of setting the value of the attribute in addition to reading it. Sticking with our NVM memory model such an attribute might be the value held by certain addresses in\nthe flash memory. Let’s create a new attribute to represent the data held by a location which we\nwill call config . # lib/nvm/memory_128_b954.rb module NVM class MEMORY_128_B954 include Origen :: Model def initialize (options={}) @config_data = 0xFF end def config_data @config_data end def config_data= (value) @config_data = value end end end With our new getter and setter methods for the config_data attribute we can now change\nthe value of it dynamically: $dut = SOC :: EAGLE_M352 .new\n\nmem = $dut .nvm.memories.first\n\nmem.config_data # => 0xFF mem.config_data = 5 mem.config_data # => 5 Again this is such a common pattern that a shorthand exists, to create getter and setter methods equivalent to\nthose above we can do: # lib/nvm/memory_128_b954.rb module NVM class MEMORY_128_B954 include Origen :: Model attr_reader :config_data attr_writer :config_data end end Or to create both, a further shorthand exists: # lib/nvm/memory_128_b954.rb module NVM class MEMORY_128_B954 include Origen :: Model attr_accessor :config_data end end Anonymous Sub-blocks with Attributes Sub-blocks without a specific class definition also support attributes, any attributes can either be\ndirectly written to the sub-block or supplied in the sub-block definition: class MySoC include Origen :: TopLevel def initialize (options={})\n sub_block :ram , size_in_kb : 128 # Once defined any additional attributes can be declared on the fly ram.clk_domain = :ipg end end $dut = MySoC .new $dut .ram.size_in_kb # => 128 $dut .ram.clk_domain # => :ipg $dut .ram.vendor = \" Mentor \" $dut .ram.vendor # \"Mentor\" Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/bugs/": {
    "title": "Bugs & Features",
    "subtitle": "Models",
    "body": "Models Bugs & Features The example code for tracking versions may seem like a\nlot of effort but it is very quick to implement additional\nconfigurations by copying and pasting the previous one, and remember that this only\nneeds to be done for revisions that make it to silicon. While it may seem like overkill initially, the benefit will become apparent as the\nnumber of silicon derivatives that your application must support begins to grow. By following\nthis architecture you will find that your application can scale to any number of derivatives easily and\nmost importantly you will continue to feel in control of it - especially when it comes to tracking which\nbugs and features exist on each device. Assigning Bugs to the Responsible Module A primary goal of Origen is to help with the creation of complex applications that remain easy to manage and a key\ncomponent of this is the creation of high level code flows that are both easy to follow and to understand. Therefore we do\nnot want our application to be littered with things like “if the device version is 50 then do this…“ , but rather to use the\nmore descriptive “if the device has the low reference voltage bug then do this…“ . Furthermore bugs should be assigned to the sub-block that is actually responsible for them - they should not\nbe assigned at SoC level . Adding bugs at SoC-level is equivalent to adding branches to your code like “if the device is an Eagle then do this…” which may seem reasonable but that has proven to be the path to a maintenance\nnightmare. The problem with that approach is that you have now set yourself up to have to answer the question “does this\ndevice have this bug?” for every new device that you ever add support for in the future. As the number of\ndevices and bugs (and features) grows, the number of such cases to manually track will grow exponentially. The solution to this problem is to track the bug or feature at component level and change your branch to “if the analog module in the NVM module of the current device has the low reference voltage bug then do this…“ . \nThen in the future simply add new device configurations\nby declaring the BOM as we have seen in the versioning guide . Your job is then done. This is because the bug workaround has been implemented in a way that requires no further human interaction\never again - if we create a new device that instantiates a version of the NVM analog that has the bug then\nour workaround will kick in automatically. Similarly if we add a new device which instantiates a version \nof the analog that doesn’t have the bug then the workaround will be bypassed automatically. Recording a Bug Here are some examples of adding bugs to the analog module within our example NVM module, note that bug\nmethod is a class method that must be called outside of the initialize (or any other) instance method: # file: lib/nvm/analog_t921.rb module NVM class ANALOG_T921 include Origen :: Model bug :low_vref , :affected_version => 11 bug :low_iref , :affected_versions => [ 11 , 12 ]\n bug :dac_code , :fixed_on_version => 12 bug :unfixable def initialize (options={}) end end end We have defined these bugs in terms of the affected versions and since our models already contain\nversion information the presence of bugs will be modelled accurately. We can test this in the console: # This will instantiate version 11 of the analog block $dut = SOC :: EAGLE_M352 .new( version : 0 ) $dut .nvm.analog.has_bug?( :low_vref ) # => true $dut .nvm.analog.has_bug?( :low_iref ) # => true $dut .nvm.analog.has_bug?( :dac_code ) # => true $dut .nvm.analog.has_bug?( :unfixable ) # => true # This will instantiate version 12 of the analog block $dut = SOC :: EAGLE_M352 .new( version : 1 ) $dut .nvm.analog.has_bug?( :low_vref ) # => false $dut .nvm.analog.has_bug?( :low_iref ) # => true $dut .nvm.analog.has_bug?( :dac_code ) # => false $dut .nvm.analog.has_bug?( :unfixable ) # => true When we get to the point of implementing a template or source file we will then be able to deal with these\nbugs via logic like: if $dut .nvm.analog.has_bug?( :low_vref ) # Workaround the bug else # Proceed as normal end Recording a Feature Feature identification can be added in a similar way, this API also supports optionally adding descriptions: # file: lib/nvm/analog_t921.rb module NVM class ANALOG_T921 include Origen :: Model feature :feature1 feature :feature2 , :description => \" feature2 description, this API for tools \" # This is feature 3 description, this API is for humans # and markdown should be used for formatting feature :feature3 def initialize (options={}) end end end $dut = SOC :: EAGLE_M352 .new( version : 0 ) $dut .nvm.analog.has_feature?( :feature1 ) # => true $dut .nvm.analog.has_feature?( :feature2 ) # => true $dut .nvm.analog.has_feature?( :feature3 ) # => true $dut .nvm.analog.has_feature?( :feature4 ) # => false $dut .nvm.analog.feature( :feature1 ).description # => [] $dut .nvm.analog.feature( :feature2 ).description # => [\"feature2 description, this API for tools\"] $dut .nvm.analog.feature( :feature3 ).description # => [\"This is feature 3...\", \"and markdown should be..\"] Note that it is not currently possible to track features by version like it is for bugs, however it would not\nbe very difficult to add this should the need arise. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/componentable/": {
    "title": "Creating Your Own Components",
    "subtitle": "Models",
    "body": "Models Creating Your Own Components If you’ve looked at the section on SubBlocks and at the section on Components ,\nyou’ll probably notice many similarities. It may seem that SubBlocks are just a more sophisticated and feature\nrich version of Components . The Origen::Componentable module (henceforth referred to as just Componentable ) is a mixin . The name Componentable is\na protologism taking after Ruby’s own Enumerable mixin. By mixing in Componentable with\nyour classes, you will automatically be given methods to add, remove, move, copy, and query objects you’ve added. Now,\nyou may think… “well, that’s easy enough to do on my”, and that’s very true. But, Componentable will\nhandle all that boiler plate code for you while providing a common interface and having an easily managed/updated\nmixin so that bug fixes and feature enhancements will be felt across all your Componentable classes\nwithout any intervention from you (other than updating the Origen version, that is). Furthermore, Componentable can handle initiailizing Componentable's parent classes. This\nmeans that in addition to your class receiving add, remove, query, etc. methods internally, any parent \nthat uses your class will also receive add, remove, query, etc. methods, again, without any intervention. If this is of interest to you, sections below will discuss how to mixin the Componentable module, how to \nhandle instantiating and initializing your classes, and what the API provides. Mixing In Componentable Mixing in Componentable is easy and does not require that any particular methods be defined. You\ncan mix it in by just putting the following into your class: include Origen :: Componentable Componentable actually contains two APIs: The first is the API provided to the includer class ,\nthat is, the class that includes Componentable . This includer class is then added to a parent class . In other words, the parent class is the one that users of you new Componentable class will\ninteract with. Whereas the includer class acts as the interface between the parent class and\nthe structures that actually hold and maintain the items. If this is still confusing, it should make more sense as you move through this guide and for now, just know that the\nclass that contains include Origen::Componentable is the includer class and the class that\nusers the componentable class is the parent class . Contents There’s quite a few sections to this guide. The marks below should help you jump around appropriately. The Componentable Class Booting the Includer Includer Class API Adding Querying Moving & Copying Iterating Removing Includer Class Organization Naming the Includer Class Conclusion The Parent Class Booting the Parent The Parent API Controlling Accessors on the Parent Example Parent API Basics Adding Querying Iterating Copying & Moving Deleting Generic Parent API Basics Adding Querying Iterating Copying & Moving Deleting Componentable Class Componentable Class Componentable Class Componentable Class The Componentable Class Booting the Includer All that Componentable requires is an instance variable called _componentable_container . This\nis a generic name that the API below will interact with. Depending on how you setup your class, you still may not need to do anything. If your componentable class includes Origen::Model , then the boot process will take place automatically. Componentable implements\nan origen_model_init callback handler for you\n(see here ).\nThis callback will add and initialize this object during the includer class's initialization. \nSo, the following will take care of everything for you: include Origen :: Model include Origen :: Componentable If you are not using include Origen::Model , you’ll need to take some action yourself. Componentable comes with a method to assist with this: init_includer_class ( includer being the class that includes Componentable ).\nCalling this method in your class’s initialize function will accomplish the same thing as including Origen::Model . The usage is: # Initialze the _componentable_container object # Note that this is in the Origen::Componentable module's class methods, not in the mixin. # Initialize internal to the class class Includer include Origen :: Componentable def initialize (options={}) Origen :: Componentable .init_includer_class( self ) end end # Initialize externally an already existing object class Includer include Origen :: Componentable end i = Includer .new Origen :: Componentable .init_includer_class(i) After booting, the includer class is ready! Includer Class API This is the API that includer classes will get for free. However, any of these\ncan be overridden or extended to further customize the Compentable object. The basic API includes these methods: Adding new objects add(name, options={}, &block) #=> adds a new object, :name add(name, class_name : ClassToAdd #=> adds a new object of class ClassToAdd add(name) do |n|\n n.class_name ClassToAdd end #=> (also) adds a new object of class ClassToAdd using block syntax Querying objects list #=> list the available names in the componentable container has?(name) #=> returns true if and object with :name has been added [](name) #=> returns the object at :name, or nil if :name has not been added Moving and copying objects copy(to_copy, to_location, options = {}) #=> # copies an object from to_copy to to_location, cloning the object move(to_move, new_name, option={}) #=> Moves an object from to_move to new_name Iterating through objects each(&block) #=> runs the generic :each method from enumerable across the underlying componentable container hash select(&block) #=> runs the generic :select method from enumerable across the underlying componentable container hash instances_of(class_name) #=> returns an array of all the names of class :class_name Removing objects # aliased as :remove delete(to_delete) #=> deletes the object at :to_delete, returning the object # aliased as :clear and :remove_all delete_all #=> deletes everything in the componentable container All of these will operate on the componentable_container object and all are provided to you. These\nmethods will also be called by the parent class to perform these operations, but more on that later. You\nshould just know that undefining these methods or changing around their arguments will change the way that the parent class will need to interact with the includer class . Includer Class Organization In order to use this to the full power provided, the namespacing must be set up rather specifically. You can always boot\nthe classes manually, so don’t let this put you off from creating your own Componentable Classes but the\nexample namespacing below will show you the recommended way of organizing the modules and classes such that the parent class can bring in you new Componentable class with a single line. As will be covered in later when booting the parent class ,\nthe goal is to bring in your Componentable class as a single line. If you decided to name your Componentable class MyTest for example, then what we’re looking for in the parent class is simply: class Parent include Origen :: Model include MyTest end Well, what’s the problem with this right now? MyTest isn’t a module. Its a class. We can’t include a class, Ruby won’t let us. But we can do is namespace our MyTest class in a module\nalso named MyTest , in this case. When this module is included, Componentable will signal\nto Origen that this module MyTest contains Componentable classes that must be booted. So,\na simple implementation may look like: module MyTest class MyTest include Origen :: Model include Origen :: Componentable end end Note that the name of the module actually isn’t important. As long as the module contains some Componentable classes everything will go as expected. You aren’t even limited to a single class per module.\nIf you have a few Componentable classes in a module, they will each be booted. module MyTests class MyBasicTest include Origen :: Model include Origen :: Componentable end class MyIntermediateTest include Origen :: Model include Origen :: Componentable end class MyAdvancedTest include Origen :: Model include Origen :: Componentable end end An in-depth explanation of how this occurs is out of scope right now, but you can see the section on advanced booting if you wish to know more and get a developers perspective. Naming The Includer Class Define the API based on the name of the includer class? Yep! When trying to add the parent API, two names will be used:\nthe singleton_name and the plural_name . The process for this is: Use Ruby’s/Rail’s underscore method as the singleton_name Apply a few general rules that covers most cases for pluralizing. This will be the plural_name In general, this will just be adding an s to the singleton_name , but it can handle a few\nother cases, such as: ‘is’ -> ‘es’ (as in ‘analysis’ -> ‘analyses’) ’s/h/ch/sh/x/z’ -> ‘es’ (as in ‘bus’ -> ‘buses’, or ‘box’ -> ‘boxes’) ‘on’ -> ‘a’ (as in ‘criterion’ -> ‘criteria’) all other cases will just ‘s’ appended (as in ‘component’ -> ‘components’) You can run this method on your class yourself in interactive mode. This returns a Hash with keys singleton_name and plural_name . For example: Origen :: Componentable .componentable_names( Origen :: Component )\n\n{ singleton_name : :component plural_name : :components } Origen :: Componentable .componentable_names( MyTest )\n\n{ singleton_name : :my_test plural_name : :my_tests } We here at Origen are engineers, not writers, and not interested in figuring out all rules of how to make\neverything plural (I can tell you, the author of this particular section is a native english speaker, and still got\nhalf rules wrong before looking them up). So, if you don’t like the name Compomentable gave you, no problem! \nYou can define it yourself using two class constants (not instance variables ). The following\nexamples will show this: class MyTest COMPONENTABLE_SINGLETON_NAME = ' just_test ' end # This will take the 'just_test' singleton_name, and pluralize it as using that name { singleton_name : :just_test plural_name : :just_tests } class MyTest COMPONENTABLE_PLURAL_NAME = ' just_tests ' end # This will evaluate the singleton name as normal, but use the given plural name { singleton_name : :my_test plural_name : :just_tests } class MyTest COMPONENTABLE_SINGLETON_NAME = ' test ' COMPONENTABLE_PLURAL_NAME = ' tests ' end # This will use both the provided singletoneand plural name. { singleton_name : :test plural_name : :tests } Ruby itself has some requirements though. Due to how these names will be used, they can’t start with a capital letter.\nSo, even if you define a COMPONENTABLE_SINGLETON_NAME and/or a COMPONENTABLE_PLURAL_NAME name,\nthey are getting downcased either way or Ruby won’t let us run anything. Note that even this breaks down for words like deer , as Componentable requires that the\nsingleton name and plural name be different (otherwise methods will step on each other), and will complain if this\nis not met. So, apologies, but you’ll have to keep the plural of your Deer class as Deers ,\nwhich is technically correct actually , but not really important so…\nmoving on. Includer Class Conclusion This covers everything the includer class gets for free. Next, we’ll discuss the parent class . For information on customizing the includer class you can jump here ,\nbut this may not make as much sense without first getting the parent’s perspective. The Parent Class The parent API is really what is interesting. When you use the generic Origen components, say, for example, on your $dut , you use methods like $dut.add_component , $dut.components_of_class , $dut.has_component? , etc. But where do these methods come from? You would think that these are part\nof Origen, that somewhere deep in bowels of the code base are a bunch generic methods to operate on some Component class somewhere. But, that’s not true. Those methods are added by booting the parent class of a Componentable includer class Booting the Parent Since we can’t do much without booting the parent class , we’ll cover that now. Booting the parent is\nmore involved than booting the includer. That said, if the includer class is set up a certain way,\nas discussed here then\nthe boot process for the parent can be automated as well. Booting the parent class includer has two steps: Instantiate the includer class as an instance variable on the parent class. Define the API on the parent class based on the name of the includer class. The easiest way is just to let Origen to do it for you. Like the includer class ,\nincluding Origen::Model will let us hook into the intializer to take care of booting the parent for you. Danger! This requires that your includer class is also either an includer of \n code>Origen::Model</code> OR intializes itself. If not, you'll end up with a fully built parent-API and its very \n own instance variable pointing to an includer class ... that has no comopnentable container .\n As you can imagine, all of the attempt to use the includer will result is errors. You can boot it yourself there\n in the parent as discussed here . This can\n also be used to boot includer classes that are not setup as described here . If we let Origen do it, and if our includer classes are setup as shown in the includer organization section ,\nwe can simply do this by include the module, including Origen::Model and going on our way. class Parent include Origen :: Model include MyTest end parent = Parent .new\nparent.my_test #=> Instance of MyTest Componentable class. parent.list_my_tests #=> list the current added my_tests, in this case, [] But, say we want to boot it directly. That is, not rely on Origen. We can do that using the \nmethod Origen::Componentable.init_parent_class (class method within the Origen::Componentable namespace). We can give this both the instance of the parent class and the includer class and it will handle booting for you. For example: # Internal to the parent class class Parent #include MyTest #=> nevermind, don't need this right now. def intiailize Origen :: Componentable .init_parent_class( self , MyTest ) end end # External to the parent class class Parent #include MyTest #=> nevermind. def intiailize #Origen::Componentable.init_parent_class(self, MyTest) #=> Nevermind this too. end end p = Parent .new Origen :: Componentable .init_parent_class(p, MyTest ) And… we’re done! Now we’ve got the parent booted up and we’re ready to start using it. The Parent API Now, the API for the parent is bit trickier… as its not static. What exactly the parent API is\nwill be dependent on what you’ve named your class. Continuing on with our MyTest includer class example, we can use the naming convention here to know that: The singleton name is: my_test The plural name is: my_tests After booting, we’ll be able to use our includer class on the parent: p.my_test #=> MyTest object p.my_tests #=> {} p.add_my_tests( :test1 )\np.list_my_tests #=> [\"test1\"] p.add_my_tests( :test2 ) do |t|\n t.class_name TestClass end p.list_my_tests #=> [\"test1\", \"test2\"] p.my_tests[ \" test1].do_something\n#=> run method :do_something with object at name \" test1 \" Since this API is not static, its more difficult to document. The generic API is actually just placeholders that can\nbe found here . This API will show which Componentable method is called. So, calling the method from the parent\nclass boils down to calling an includer class method and all of relevent and defined options will be \npassed down to it. You can review the full includer API here . Controlling Accessors on the Parent As with compoments , we added COMPONENTABLE_ADDS_ACCESSORS = true constant in the MyTest class. So, we can expect: p.test1 #=> Object stored in MyTest at name :test1 p.test2 #=> Object stored in MyTest at name :test2 But, say we already had method :test1 on the parent? The result would be a Origen::Componentable::NameInUseError . And if we had multiple test classes, and all\nhad a :test1 and all decided to add COMPONENTABLE_ADDS_ACCESSORS = true , what can\nour parent do? For a new example, say we have two includer classes: MyClockingTest and MyPowerTest , and\nboth decided that COMPONENTABLE_ADDS_ACCESSORS = true . Also, our specification says that both\nneed to have a test named :test1 . We have a few ways we can deal with this. First, we can just disable all accessors on the parent unconditionally (including components ). \nThis takes away the ability for us to use parent.test1 , but now we can\nhave parent.my_clocking_tests[:test1] and parent.my_power_tests[:test1] coexisting. We\ncan do this by setting an attr_reader or defining a method :disable_componentable_accessors and having it return true . Everytime an accessor is added, it will see that on the parent and decide\nagainst adding said accessor. But, we can also dictate which includer classes shouldn’t have accessors and which should. \nMaybe we want to disable only the accessors on MyClockingTest and MyPowerTest , but leave them \nfor Compoonents . If you define the method :disable_componentable_accessors to instead take an argument, Componentable will give it the includer class requesting to add an accessor, as a class name.\nWe can write a method like so to do this: def disable_componentable_accessors includer_class if includer_class == MyClockingTest || includer_class == MyPowerTest true else false end end You can build this method however you see fit on the parent to only get the accessors you want from the various includers. An Example API Using our MyTest includer class again, imported by our Parent parent class , the full API we have \navailable on the parent is below. You can skip to here to view the API in generic terms. We know from before that the singleton_name is :my_test and that plural_name is :my_tests . With these in mind, the API on the parent class will resolve to: Basics # Retrieving an instance of the MyTest object parent.my_test #=> instance of MyTest # Retrieving MyTest's componentable container parent.my_test._componentable_container\nparent.my_tests #=> Hash with indifferent access # Retrieving MyTest instance variable directly on the parent instance_variable_get( \" @_my_test \" .to_sym) #=> instance variable on the parent class Adding # Adding Objects # These methods correspond to a my_test.add call. parent.my_test(name, options={}, &block)\nparent.my_tests(name, options={}, &block)\nparent.add_my_test(name, options={}, &block) # add_my_test is aliased to: #=> add_my_tests Querying # Listing Names of Objects\n# These methods correspond to a my_test.list call\nparent.list_my_tests\n\n# Querying Objects\n# These methods correspond to a my_test.instances_of call\nparent.my_tests_of_class(class_name)\n# my_tests_of_class is aliased to:\n #=> my_tests_instances_of\n #=> my_tests_of_type Iterating # Emumerating # These methods correspond to a my_test.each call parent.my_tests(&block)\nparent.each_my_test(&block) # each_my_test is aliased to: #=> all_my_tests # Selecting # These methods correspond to a my_test.select call parent.select_my_tests(&block) # select_my_tests is aliased to: #=> select_my_test Copying and Moving # Copying # These methods correspond to a my_test.copy call parent.copy_my_test(to_copy, to_location, options={}) # copy_my_test is aliased to: #=> copy_my_tests # Moving # These methods correspond to a my_test.move call parent.move_my_test(to_move, to_location, options={}) # move_my_test is aliased to: #=> move_my_tests Deleting # Deleting Single Objects # These methods correspond to a my_test.delete call parent.delete_my_test(name) # delete_my_test is aliased to: #=> delete_my_tests #=> remove_my_test #=> remove_my_tests # Deleting All Objects # These methods correspond to a my_test.delete_all call parent.delete_all_my_tests # delete_all_my_tests is aliased to: #=> clear_my_tests #=> remove_all_my_tests Also recall, that these methods link directly back to just calling the corresponding method on the includer class ,\nso the full method documentation (parameters, options, return values, exception raised, etc.) can be found back at the includer class’ API . Generic Parent API In more generic terms, adding an includer to a parent yields the following API on the parent class: Recall here that you can use the methods _singleton_name and _plural_name on an instance of an includer class to\nquery those names. You can also use the class method Origen::Componentable.componentable_names(includer) to get a hash containing the keys :singleton and :plural , either with an instance of\nthe includer class or with the class directly. Once again, these methods link directly back to just calling the corresponding method on the includer class ,\nso the full method documentation can be found back at the includer class’ API . Basics # Retrieving an instance of the includer class object parent.<singleton_name> #=> instance of the includer class # Retrieving an instance of the includer class's componentable container parent.<singleton_name>._componentable_container\nparent.<plural_name> # Retrieving the includer instance variable directly instance_variable_get( \" @_<singleton_name> \" .to_sym) #=> instance variable on the parent class Adding # Adding Objects # These methods correspond to a <singleton_name>.add call. parent.<singleton_name>(name, options={}, &block)\nparent.<plural_name>(name, options={}, &block)\nparent.add_<singleton_name>(name, options={}, &block) # add_<singleton_name> is aliased to: #=> add_<includer_plural_name> Querying # Listing Names of Objects # These methods correspond to a <singleton_name>.list call parent.list_<plural_name> # Querying Objects # These methods correspond to a <singleton_name>.instances_of call parent.<plural_name>_of_class(class_name) # <plural_name>_of_class is aliased to: #=> <plural_name>_instances_of #=> <plural_name>_of_type Iterating # Emumerating # These methods correspond to a <singleton_name>.each call parent.<plural_name>(&block)\nparent.each_<singleton_name>(&block) # each_<singleton_name> is aliased to: #=> all_<plural_name> # Selecting # These methods correspond to a <singleton_name>.select call parent.select_<plural_name>(&block) # select_<plural_name> is aliased to: #=> select_<singleton_name> Copying and Moving # Copying # These methods correspond to a <singleton_name>.copy call parent.copy_<singleton_name>(to_copy, to_location, options={}) # copy_<singleton_name> is aliased to: #=> copy_<plural_name> # Moving # These methods correspond to a <singleton_name>.move call parent.move_<singleton_name>(to_move, to_location, options={}) # move_<singleton_name> is aliased to: #=> move_<plural_name> Deleting # Deleting Single Objects # These methods correspond to a <singleton_name>.delete call parent.delete_<singleton_name>(name) # delete_<singleton_name> is aliased to: #=> delete_<plural_name> #=> remove_<singleton_name> #=> remove_<plural_name> # Deleting All Objects # These methods correspond to a <singleton_name>.delete_all call parent.delete_all_<plural_name> # delete_all_<plural_name> is aliased to: #=> clear_<plural_name> #=> remove_all_<plural_name> Customizing Your Componentable Class This section will go over some ways to further customize the Componentable class . Recall that any of the Componentable class’s API can be\noverridden by the includer class . Adding New Items Most likely, you will want to override the add method to cover how to add your custom components. The\nstandard add method will simply instantiate the given class (or a default class if none is given), check\nthat the name doesn’t already exist, add the component, then provide an accessor if set to do so. Not much. It does a bit\nmore if given an instances option, but that is handled as well.\nHowever, add is actually split into a few methods that you can use if you override add . The add method itself calls two methods: _split_by_instances and _add . _split_by_instances is responsible for cutting up the options given into chunks for each instance. You\ncan see the component’s page on multiple instances for a refresher but this will the instances option handling for your class in check with other Componentable classes. Once split up, each individual instance and its options are given to the _add method. _add does three things: it puts in some default options, calls the _instantiate_class method\nand calls the </code>_push_accessor</code> method. Most likely, this is what you’ll want to override. From here, you\ncan build in any defaults/settings that you want and throw errors if things are missing or incorrect. Then you can\nfinish up by calling the two aforementioned methods. For example, the code for the default _add is just: def _add (name, options={}, &block) # Add the name and parent to the options if they aren't already given # If the parent isn't available on the includer class, it will remain nil. options = { name : name, parent : parent\n }.merge(options) if block_given?\n collector = Origen :: Utility :: Collector .new yield collector\n options.merge!(collector.store) end # Instantiate the class. This will place the object in the @_componentable_container at the indicated name _instantiate_class(name, options) # Create an accessor for the new item, if indicated to do so. _push_accessor(name, options) @_componentable_container [name] end So feel free to override that, adding some custom behavior for your class. Warning: This is still a new feature, and some better ways to override this may come around. Check\n the release notes for any changes to how _add should be overridden, if any. Advanced Booting This section is just as more for Origen developers than it is for users. Booting these classes took some behind the scenes\nwork that most users will never see. But, there’s some assumptions that are made\n(in addition to the ones here ) that can adversely affect booting. Here, we’ll briefly touch on the behind-the-scenes actions taken to boot Componentable . First, when you setup the module as: module MyTest class MyTest include Origen :: Model include Origen :: Componentable end end The line include Origen::Componentable will trigger Componentable's included? method to kick\noff. This adds the callback origen_model_init to the MyTest module (not the class ). This\nallows the module , in this case MyTest , to boot the MyTest class upon being\nincluded in a parent class. So, with this, we have an additional assumption that module MyTest does not \nhave an origen_model_init callback already. In most cases, the module housing the Componentable classes will do just that. They won’t have other\nstuff in them. But in them event that it does have its own origen_model_init , Componentable can still function with some workaround. All that needs to happen is a manual call to Origen::Componentable.init_parent_class(klass, self) , where klass is the Componentable class to boot. In this case, MyTest . For example: module MyTest def origen_model_init (klass, options={}) # ... # Add booting the Componentable classes Origen :: Componentable .init_parent_class(klass, self ) end class MyTest include Origen :: Model include Origen :: Componentable end end This will be called for every class containing Origen::Componentable in the model. Notes on Anonymous Classes Componentable can be used with anonymous classes, but since anonymous classes don’t have a name, obvisously, one\nwill need to be provided. Recall from the section on naming that you can override the class name by defining the class constant COMPONENTABLE_SINGLETON_NAME . This\nwill ‘name’ the anonymous class so that Componentable can generate the parent API. Failing to provide\nthis to an anonymous class results in a Origen::Componentable::Error exception. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/components/": {
    "title": "Generic Components",
    "subtitle": "Models",
    "body": "Models Generic Components So far we’ve covered SubBlocks , Fuses , Power Domains and other objects.\nEach of these has its particular use, and its instantiation and customized behavior reflects that, \nbut what about a generic component container? Origen has one of those too, and it behaves similarly to the aforementioned models. The advantage \nis that you can get a SubBlock-like or Fuse-like interface without having your\ngeneric components registered as a SubBlock or Fuse and without any extra overhead. The\ndisadvantage is that it does nothing else, and functions much like a stripped-down SubBlock object. However, this allows you to add and use generic components that could be anything. These components don’t require a base\naddress, or any other options (otherwise you’d use a SubBlock ) but will still initialize and be kept\ntrack for you. For example, if I have a class: scan_helper , which I’ve implemented as something similar to a SubBlock , but that doesn’t have a base_address, registers, or anything like that, I can\ninstantiate it as a component instead: component( :scan_helper , class_name : ScanHelper ) #=> ScanHelper instance with name :scan_helper I can then get this item as I would a sub_block , fuse , etc.: components[ :scan_helper ] #=> ScanHelper instance self .scan_helper #=> ScanHelper instance Component API Seems pretty basic, right? Good! That’s what we’re going for! Below is the API that you can do with components. Adding Components You can add components in a few different ways: # Add a component with default class Origen::Component::Default component( :comp1 ) # Add another component. Notice the use component(s). components( :comp2 ) # Add a component of class MyComponent add_component( :mine , class_name : MyComponent ) # Method add_components also works, as does using a string as the class name add_components( :also_mine , class_name : ' MyComponent ' ) # Add a component using block notation add_components( :block_add ) do |comp|\n comp.class_name ' MyComponent ' end # Add another one using block notation components( :block_add_2 ) do |c|\n c.class_name ' MyComponent ' end Now, if we call just components , we’ll get the resulting Hash storing these. So, components.keys #=> [\"comp1\", \"comp2\", \"mine\", \"also_mine\", \"block_add\", \"block_add_2\"] Notice the switch from :comp1 to \"comp1\" . This is because the underlying Hash is with_indifferent_access . Therefore, you can get components from the Hash using either a String or a Symbol ,\nbut when listing, comparing, etc., the keys will be returned as a String Adding Multiple Instances You can add multiple instances at once by passing in the :instances option. This will auto-append an\nappendix number to each item. For example: add_component( :multiple , instances : 4 )\n\ncomponents.keys #=> [\"multiple0\", \"multiple1\", \"multiple2\", \"multiple3\"] # In addition, this will make an accessor for each one. So, the following are now defined: multiple0 #=> :multiple0 Component multiple1 #=> :multiple1 Component multiple2 #=> :multiple2 Component multiple3 #=> :multiple3 Component You can pass other options in as well. Single options will be applied to all instances. A single option being\neither not an Array object, or an Array object of size 1. Options that are Arrays longer than size 1 will be indexed to each instances. For example, if you indicate\nfour instances of a component, Array index 0 will go to instance 0, Array index index 1 to instance 1, and so on. Providing\nan incompatible Array length will result in an Origen::Componentable::Error . add_component( :multiple , instances : 4 , letter : [ ' A ' , ' B ' , ' C ' , ' D ' ], number : 0 )\n\nmultiple0 #=> :multiple0 Component with parameters: letter: 'A', number: 0 multiple1 #=> :multiple1 Component with parameters: letter: 'B', number: 0 multiple2 #=> :multiple2 Component with parameters: letter: 'C', number: 0 multiple3 #=> :multiple3 Component with parameters: letter: 'D', number: 0 add_component( :more , instances : 3 , letter : [ ' A ' , ' B ' , ' C ' , ' D ' ], number : 0 ) #=> Origen::Componentable::Error The corner case of wanting a static-sized array given to each instance can be overcome by embedding that Array in\nanother Array of size 1. For example, the options instance: 2, cores: [:cm0, :cm3, :cm4] will result in\nan Origen::Componentable::Error but, instance: 2, cores: [[:cm0, :cm3, :cm4]] will be fine \nand results in both instances getting the option cores: [:cm0, :cm3, :cm4] . Copying and Moving Components You can copy and move components using these methods: copy_component( :comp1 , :comp1_copy ) # Method copy_components is an alias components.keys #=> [\"comp1\", \"comp2\", \"mine\", \"also_mine\", \"block_add\", \"block_add_2\", \"comp1_copy\"] move_component( :comp1_copy , :comp1_moved ) # Method move_components is an alias components.keys #=> [\"comp1\", \"comp2\", \"mine\", \"also_mine\", \"block_add\", \"block_add_2\", \"comp1_moved\"] Note that copying components will actually clone the component. So, you get an independent instance\nof the object that you copied from. Listing Components Listing the components will show you just the names. This is the equivalent of using components.keys : list_components #=> [\"comp1\", \"comp2\", \"mine\", \"also_mine\", \"block_add\", \"block_add_2\", \"comp1_moved\"] You can check if a component has been added using the has_component? method: has_component?( \" comp1 \" ) #=> true has_component?( :comp1 ) #=> true has_component?( \" comp_dne \" ) #=> false has_component?( :comp_dne ) #=> false # component?(name) is an alias method name Getting Components You can get components using either the index notation or by utiliting the accessor given\nduring the add process: components[ :comp1 ] #=> component at name :comp1 comp1 #=> same as calling components[:comp1] Querying Added Components There’s a method available that can query the current classes of the added components. components_of_class( MyComponent ) #=> [\"mine\", \"also_mine\", \"block_add\"] # components_instances_of and components_of_type are aliases Enumerating Component exposes two commonly used enumerable methods: each and select # All of these call the :each method components.each do |name, component| # do something end each_component do |name, component| # do something end all_components do |name, component| # do something end select_components do |name, component| # do something end You can use other enumerable methods provided by the Hash class by using components._enumerable_method_ Deleting Components You can delete components that you’ve previously added. This will return the deleted item, or\nraise an exception if the name does not exist. list_components #=> [\"comp1\", \"comp2\", \"mine\", \"also_mine\", \"block_add\", \"block_add_2\", \"comp1_moved\"] delete_component( \" comp1_moved \" ) #=> Component at comp1_moved list_components #=> [\"comp1\", \"comp2\", \"mine\", \"also_mine\", \"block_add\", \"block_add_2\"] # Methods delete_components, remove_component, and remove_components, are all aliases You can also clear the entire component structure and start fresh. Note this this will\nnot return any components. list_components #=> [\"comp1\", \"comp2\", \"mine\", \"also_mine\", \"block_add\", \"comp1_moved\"] delete_all_components\n\nlist_components #=> [] # Methods clear_components and remove_all_components are aliases Info! Due to the way Component is implemented, it does not an API section. You can see the next\n topic on Componentable however to extract the component API in YARDOC from its Componentable mixin. Disabling Accessors If you add lots of components, or if you add lots of components, subblocks, fuses, etc., it may get messy having each\none try to put its own accessor on your model. If you find yourself not wanting components to place accessors on your\nmodel, you can define a method :disable_componentable_accessors(klass) and have it return true if klass is of type Origen::Component . In other words: def disable_componentable_accessors (klass) if klass == Origen :: Component true else false end end Warning! Returning a blanket true value will result in all Componentable objects withholding accessors from your model, including components . For more details on this, please\n see the Componentable Guide . Componentable Component is an example of a Origen::Componentable mixin. For information on using this module\nin your own classes to get a component-like interface, please see the topic here Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/datasheets/": {
    "title": null,
    "subtitle": "Creating Datasheets",
    "body": "Origen provides an API for creating and manipulating datasheets within an Origen application. Datasheets are intended to provide all of the specific spec-tables, revision-history, \nand notes that are associated with a particular device. Including a datasheet in your \napplication will allow you to quickly call up any relevant information about a device\ndirectly to your console. The API is made available by including the Origen::Datasheet module. module MyApplication class TopLevel include Origen :: Datasheet # => makes the Datasheet available to application attr_accessor :datasheet end end Creating Datasheets Creating a datasheet is very simple and is demonstrated in the following code sample: module MyApplication class TopLevel include Origen :: Datasheet # => makes the Datasheet available to application attr_accessor :datasheet @datasheet = TopLevel .new.ds #=> Creates instance of a Datasheet in your application. end end Note: Creating a Datasheet in your Origen application does not physically instantiate an \nXML Datasheet, but rather an Origen model of one that is visible to your application. Importing an Existing Datasheet Through the RosettaStone plug-in, Origen is able to consume existing XML datasheets provided\nthey conform to the XML standards that the program expects. Importation is done via\nthe rs_import method like in the code sample below. The importation process is very fast in will complete in just a few seconds, even for very large XML\nfiles. module MyApplication class TopLevel include Origen :: Datasheet # => makes the Datasheet available to application attr_accessor :datasheet @datasheet = TopLevel .new.ds #=> Creates instance of a Datasheet in your application. @datasheet = rs_import( :path => \" path_to_your_datasheet.xml \" ) end end Spec Tables Spec Tables contain all of the relevant spec information for a particular device. \nAny given Spec contains information such as the Min and Max values, Note references, \nUnits, and Spec symbol, along with dozens of other possible attributes specified in the \nSpec API. Calling up Spec Tables from a datasheet to the console is very simple. All you will need is \nthe unique Spec Table ID. In the case that the specific Spec Table ID is not known, you will \nneed to follow the command examples below. $dut .ds.spec_tables # => This command lists every Spec Table in a datasheet, along with information including the ID. Once the correct ID is provided the Spec Table will be displayed on the console in a very friendly\ntable-view format. $dut .ds.spec_tables[ :unique_id ] # => Displays the Spec Table to the console You can also add a Spec Table to your datasheet and provide your own values if necessary. This\nis shown below. @datasheet .spec_table :unique_id do |t|\n t.full_name = \" Information you want to specify is done like this! \" end Revision History Often it is useful to know a datasheet has changed over time, and the revision history contains \nexactly that information. A Revision History is organized into a list of different Versions, \nwhere each Version lists every change that was made to the datasheet. Calling up information from the Revision History is very simple. If you are unsure of exactly\nwhich version you will need to look at, the below command will display a list of different Versions\nfor a datasheet’s Revision History, along with some information about each Version including the \naccess-key for each one. $dut .ds.revision_history # => diplays a list of each Version in a Revision History To view a specific Version use the following command $dut .ds.revision_history.versions[ :access_key ] # => displays the version to the console! Each Version will display a small table with the specific information concerning that version, \nas well as the list of changes displayed as text. Notes Notes provide engineers a way to include extra information about a Spec that may not\nfit into a specific attribute. Each note contains information like the item_area, the note text,\nand a unique ID for easy referencing and retrieval. Typing the following command into the Origen console will display a list of all notes and their IDs \nassociated with the datasheet. $dut .ds.notes If you would like to get a specific note use the following command $dut .ds.notes[ :note_id ] Searching Sometimes when a datasheet is very large it’s not always convenient to spend time looking up\ndifferent IDs to get the information you want. Currently, searching can be performed on Spec Tables\nand Notes. The way to perform a search is outlined in the following command examples. $dut .ds.spec_tables.search( \" search_string \" ) => this will display every Spec Table that matches \" search_string. \" $dut .ds.notes.search( \" search_string \" ) => displays every note corresponding to \" search_string. \" Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/defining/": {
    "title": "Definition & Hierarchy",
    "subtitle": "Models",
    "body": "Models Definition & Hierarchy Creating A Model A model can be any class that includes the Origen::Model module, this will give you access to\nall Origen APIs for defining registers, pins, etc. and generally makes Origen aware of any instances of the\nmodel when you instantiate them. class MyModel include Origen :: Model end As a general rule include the Origen::Model module every time you create a new class in Origen ,\neven if the model is\nnot of an SoC or an IP block and the concept of registers and pins does not apply.\nThere is not really any downside to including these APIs if you are not going to use them and this\nmodule is the main mechanism to hook your class into the Origen ecosystem. Creating A Top Level Model If a given model represents the top-level of an device then you should also include the Origen::TopLevel module, this specifically lets Origen know that it is a top-level model and as such it holds a special\nplace in the Origen runtime environment - for example any register write requests will be sent to this\nobject for dispatch. Internally the Origen::TopLevel module includes the Origen::Model module and\ntherefore it does not need to be specifically included in top-level model classes (although there is\nno harm from doing so). class MySoCModel include Origen :: TopLevel end Warning! While you can define multiple top-level models only one of them can be instantiated\n per target or Origen thread of execution. Attempts to instantiate a 2nd top-level object will raise an error. Regardless of what name is given to an instance of a top-level class it can always be looked up via Origen.top_level or more simply $dut . All Origen developers can rely on this\nconvention to access the current top-level object: soc = MySoCModel .new Origen .top_level == soc # => true $dut == soc # => true Modelling Hierarchy by Example As your experience with your application grows, the way to partition your models for easiest maintenance\nand development will start to become clear. At that point you may feel decide to start introducing\nabstract classes to handle the concepts that exist within your domain and which don’t necessarily have\na direct counterpart in the physical domain. However to get started we recommend that you closely follow the physical architecture of your target device, where\neach of the main IP blocks that you care about has an associated model. In this example we are going to set up an Origen model structure that will allow us to write some \ntest code for a fictional NVM module contained within an SoC. The Top Level We are going to call our application ‘NVM’ and all of our code will reside in the NVM namespace. However\nthe top-level SoC model is something of a special case because potentially it could be shared by many\napplications - e.g. an application concerned with testing the SRAM could re-use our SoC model. So to set us up to handle that eventuality in the future let’s put all of our top-level definitions into\ntheir own namespace which\nwe will call SOC . Here is how to define the top level model: # lib/soc/eagle_m352.rb module SOC class EAGLE_M352 include Origen :: TopLevel def initialize (options={}) end end end The initialize method will automatically be called by Ruby whenever a new instance of this class is\ninstantiated - so this is a place to do any setup or initialization that is required whenever a new\nEagle model comes into being. At this point we have also chosen to have this method optionally accept a hash of options, we will do this\nalmost every time we define a method since it builds in great flexibility and the ability to handle\nadditional arguments in future that we may not have thought about when first defining a new method. Interacting with Our New Model Our first model is now defined and we can now go and talk to it for the first time, to do so start\nan interactive Origen session from your terminal: origen i This command loads up an interactive Ruby terminal and automatically loads Origen and your application, so we can\nnow experiment with our models: $dut = SOC :: EAGLE_M352 .new $dut .is_a?( SOC :: EAGLE_M352 ) # => true Above we simply instantiated a new instance of our class, and then asked it if it was an instance of SOC::EAGLE_M352 , to which it replied: ‘yes’. Adding Sub Blocks Sub-blocks should be used to model IP blocks or indeed any sub-components within that IP, a generic sub-block\ncan be declared very simply within the top-level’s initialize method: # lib/soc/eagle_m352.rb def initialize (options={})\n sub_block :nvm end By default this will instantiate an object that includes all of the usual Origen APIs (regs, pins, etc.) and \nthis can then be decorated as required by the application (see example below). Most importantly this wires up\neverything internally such that the relationship between the child and the parent are known to Origen and it\nwill automatically build an accessor to get the child module: $dut = SOC :: EAGLE_M352 .new $dut .nvm # => Generic Origen object $dut .nvm.parent # => $dut $dut .children # => {:nvm => <object>} # Decorate as required by calling Origen APIs on the object $dut .nvm.reg :reg1 , 0x30 do |reg|\n reg.bits 31 .. 0 , :data end # The NVM now has a register available... $dut .nvm.reg1.write( 0x1234 ) The above approach is ideal where the models are being built from a 3rd party data source (e.g. standard XML)\nand all that is required is to get an Origen object representation of the same data. However in cases where more native richness is required you can supply a class for the object,\nlet’s create a dedicated model for our NVM IP: # lib/nvm/nvm_m682.rb module NVM class NVM_M682 include Origen :: Model def initialize (options={}) # Add an example register reg :reg1 , 0x30 do |reg|\n reg.bits 31 .. 0 , :data , reset : 0xFFFF_FFFF end end end end This follows the same pattern as our first model, note the use of the NVM namespace and the\nsubsequent storage of the file in the lib/nvm directory rather than lib/soc . We can now refer to this class in our sub-block definition and verify that the register we added is available: # lib/soc/eagle_m352.rb def initialize (options={})\n sub_block :nvm , class_name : \" NVM_M682 \" end $dut = SOC :: EAGLE_M352 .new $dut .nvm.reg1.address # => 0x30 $dut .nvm.reg1.data # => 0xFFFF_FFFF Wash, Rinse, Repeat This process can now be repeated to model the complete design hierarchy, the sub_block method\ncan be used within sub-blocks themselves with no limit on depth. Here are the complete set of initial stub models for the Eagle and it’s NVM module: # lib/soc/eagle_m352.rb module SOC class EAGLE_M352 include Origen :: TopLevel def initialize (options={})\n sub_block :nvm , class_name : \" NVM_M682 \" end end end # lib/nvm/nvm_m682.rb module NVM class NVM_M682 include Origen :: Model def initialize (options={})\n sub_block :analog , class_name : \" ANALOG_T921 \" sub_blocks :memory , class_name : \" MEMORY_128_B954 \" , instances : 4 sub_block :state_machine , class_name : \" CONTROL_D345 \" end # Origen is not yet smart enough to correctly pluralize 'memory', but we # can manually add this method to create a better experience for our users def memories memorys end end end # lib/nvm/analog_t921.rb module NVM class ANALOG_T921 include Origen :: Model def initialize (options={}) end end end # lib/nvm/memory_128_b954.rb module NVM class MEMORY_128_B954 include Origen :: Model def initialize (options={}) end end end # file: lib/nvm/control_d345.rb module NVM class CONTROL_D345 include Origen :: Model def initialize (options={}) end end end A couple of points are worth noting from the above code: The namespace reference is not required when making references to other models/classes within the\nsame namespace. Multiple instances have been specified for the memory sub-block. By convention use the\nsingular for the name, i.e. :memory , and then Origen will automatically create\naccessors called memory0 , memory1 , etc., and a method to get an\narray of all sub-blocks called memorys . Origen is not yet smart enough to generate\nthe correct English pluralization in this case, memories , but hopefully in future it will.\nIn the meantime we have manually created a memories method which will simply call\nthe memorys method that Origen created. The classes for the various NVM sub-blocks are all empty right now and as such they did\nnot really need to be defined, however these are placeholders for us to go on and add more\nlogic in the future. Even though we have not yet added any logic to our models they are starting to become useful,\nfor example we can now ask the Eagle how many NVM memory blocks that it has: $dut = SOC :: EAGLE_M352 .new $dut .nvm.memories.size # => 4 Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/fuses/": {
    "title": "Fuses",
    "subtitle": "Models",
    "body": "Models Fuses The Fuses or e-Fuses model here is bare-bones, requiring few arguments to instantiate a fuse field: Name Start Address Size Any other options passed during instantiation will be modeled as attributes of the fuse field. idcode_attrs = { customer_visible : true , owner : ' Ginty ' , default_value : 0x0 }\nserial_id_attrs = { customer_visible : false , owner : ' Seth ' , default_value : 0x0 } $dut .fuse_field( :idcode , 0xDEADBEEF , 128 , idcode_attrs) $dut .fuse_field( :serial_id , 0xF5F5F5F5 , 64 , serial_id_attrs) Accessing fuses behaves similarly to other Origen models, returning an array of fuse field names when\ncalledwithout an argument. $dut.fuses # => [:idcode, :serial_id] Given the potentially large number of fuses on SoCs, one may search for fuse fields using a regular expression.\nThis can be handy when wanting to iterate around a desired collection of fuse fields, such as memory repair fuses. $dut.fuses(/code/) # => Array of size one containing the fuse field :idcode Attributes are accessed as any other model $dut.fuses(:idcode).customer_visible # => true\n$dut.fuses(:idcode).owner # => 'Ginty' Fuses can be modeled within any class that includes Origen::SubBlocks, as is often the case, fuses are\nowned by individual IP or the top level device. Currently there are no rich methods for interacting with the fuse fields, ala Origen::Registers, so \nplease feel free to contibute. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/hw/": {
    "title": "Hardware Attributes",
    "subtitle": "Models",
    "body": "Models Hardware Attributes The need to model abstract hardware properties can sometimes arise, most\ncommonly when generating a view of the models which needs to contain some detailed\ninformation about the RTL architecture - generating an IP-XACT view of the IP for use\nin verification would be a good example of this. HDL Paths For designers using Origen as the master definition of their registers and other metadata, it\nis always preferable to setup the Origen models to mirror the eventual hierarchy of\nthe RTL.\nIn that case nothing special is required to extract HDL path information and the path method available on all sub-blocks, registers and bits should do a\ngood job: $dut .atd.path # => \"mydut.atd\" (Where 'mydut' is the lowercased class name) $dut .atd.reg1.path # => \"mydut.atd.reg1\" $dut .atd.reg1.data.path # => \"mydut.atd.reg1[15:0]\" (Where 'data' are some named bits in reg1) However in cases where that is not possible the following API exists to reconcile\nany differences. For any point in the tree the default can be overridden by setting the @path instance variable within the\ngiven object, this can also be supplied at sub-block declaration time. e.g. class MyDut include Origen :: TopLevel def initialize sub_block :atd , class_name : \" ATD \" , base : 0x1000_0000 , path : \" atds.atd0 \" end end $dut .atd.reg1.data.path # => \"mydut.atds.atd0.reg1[15:0]\" $dut .atd.path = \" atds.atd1 \" $dut .atd.reg1.data.path # => \"mydut.atds.atd1.reg1[15:0]\" Layers can be taken out of the hierarchy altogether by setting the path attribute to :hidden : sub_block :atd , class_name : \" ATD \" , base : 0x1000_0000 , path : :hidden $dut .atd.reg1.data.path # => \"mydut.reg1[15:0]\" Register and bit definitions can also be given a path override: reg :reg1 , 0 do |reg|\n reg.bits 31 .. 0 , :data end reg :reg2 , 0x4 , path : \" reg2_reg \" do |reg|\n reg.bits 31 .. 0 , :data end reg :reg3 , 0xC , path : \" reg3_reg \" do |reg|\n reg.bits 31 .. 0 , :data , path : \" data_reg \" end reg1.data.path # => \"mydut.atd.reg1[15:0]\" reg2.data.path # => \"mydut.atd.reg2_reg[15:0]\" reg3.data.path # => \"mydut.atd.data_reg\" Note that in the case of the path being given to the bits it bypasses the\nregister altogether, to include the register prefix the bit path name with\na . reg :reg3 , 0xC , path : \" reg3_reg \" do |reg|\n reg.bits 31 .. 0 , :data , path : \" .data_reg \" end reg3.data.path # => \"mydut.atd.reg3_reg.data_reg\" Absolute Paths Sometimes for a given node that is handled ‘unusually’ in RTL it is easier just\nto give an absolute path, the abs_path attribute can be set in\nplace of the path attribute for any of the examples above. When resolving paths from a child object the final path will be returned\nimmediately when an absolute path is encountered, this is best shown by example: sub_block :sub1 sub_block :sub2 , path : \" memory_block.ram \" sub_block :sub3 , abs_path : \" p2.flash \" sub1.reg1.path # => \"p1.sub1.reg1\" (where p1 is the path of the parent) sub2.reg1.path # => \"p1.memory_block.ram.reg1\" sub3.reg1.path # => \"p2.flash.reg1\" Registers and bits will also accept abs_path in place of path . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/introduction/": {
    "title": "Introduction",
    "subtitle": "Models",
    "body": "Models Introduction Models are at the heart of an Origen application and can be thought of as\nobject representations of the silicon in the application domain.\nModels can instantiate other models and they can be nested arbitrarily deep\ndepending on the needs of your application. For example, if your application is only concerned with generating dynamic \ndocumentation for a small number of devices, then it may be sufficient\nto have a single model representing each device. If on the other hand, your application is concerned with generating complex\ndesign or test code, then a lot more information will be encapsulated within your\nmodels. In these cases your application will be much easier to manage\nusing multiple models\nto represent the sub-blocks that make up the device or module in\nquestion. Model responsibilities include but are not limited to: Defining the architecture of the target device Defining what bugs or features are present in the target device Defining register and bit maps Defining any other attributes of the target device, e.g. memory size Within the Origen ecosystem, the model is intended to be the master of\nthe universe and everything from documents, to test patterns, even to\nthe design IP itself, can be considered different ways of viewing or consuming the\nmodel. It is important to spend\nthe time to architect the models in an organized manner and one which closely\nresembles the silicon that you are trying to represent.\nOnce the solid model foundation is in place, it then becomes very easy to decide\nwhere to add additional data in the future. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/modes/": {
    "title": "Package, Mode & Configuration",
    "subtitle": "Models",
    "body": "Models Package, Mode & Configuration A given SoC or IP block can typically operate in various modes or configurations\nand may have its feature set modulated by the package that it is in. The following APIs allow such concepts to be modelled so that they can then be used\nto scope things like pin availability. Package This represents the package that the device is in, however this could be a real physical\npackage or a pseudo package such as the subset of pins available to a given probecard.\nThe package is an a SoC attribute and therefore this API is only available to models\nthat include the Origen::TopLevel module. A simple package definition requires simply supplying a name for it, here are\nsome examples but the names are completely arbitrary and you can use whatever you\nlike: class MyDut include Origen :: TopLevel def initialize add_package :probe add_package :mapbga add_package :qfp end end By default the model will boot with no package set, this state would be used\nto represent the die with all pins exposed. The package state can then be changed as shown: $dut .package # => nil $dut .package = :mapbga $dut .package # => <mapbga package object> $dut .with_package :qfp do $dut .package # => <qfp package object> end $dut .package # => <mapbga package object> Packages are objects (an instance of the Origen::ChipPackage class)\nand additional attributes can be set at definition time like this: def initialize add_package :t2080 do |package|\n package.number_of_rows = 16 package.number_of_columns = 16 end add_package :t4080 do |package|\n package.number_of_rows = 32 package.number_of_columns = 32 end end $dut .package = :t2080 $dut .package.number_of_columns # => 16 $dut .package = :t4080 $dut .package.number_of_columns # => 32 See the ChipPackage API for the up to\ndate list of available attributes. Mode This represents which mode the device is in, again this can represent a real operating mode\nsuch as user, functional test, RAMBIST, etc. or some abstract concept that is specific to the\ngiven domain. The mode API is available to any object that includes Origen::Model and therefore\nsub-blocks can also define their own modes and have a mode context independent of the top-level\nobject. Modes are defined and set in the same way as packages, here are some examples: class MyDut include Origen :: TopLevel def initialize add_mode :user add_mode :rambist end end $dut .mode # => nil $dut .mode = :user $dut .mode # => <user mode object> $dut .with_mode :rambist do $dut .mode # => <rambist mode object> end $dut .mode # => <user mode object> Note that like packages the modes are represented by objects which can be assigned attributes,\nsee the ChipMode API for the up to\ndate list of available attributes. Mode objects do support a convenience API for checking the current mode: $dut .mode.user? # => false $dut .mode.rambist? # => true Configuration This is another layer which supports the concept that different configurations may exist within\nthe one mode. More generally it is simply another scope that the application can use to describe\ndifferent states/configurations. Like modes, the configuration API is available to any object that includes Origen::Model and therefore\nsub-blocks can also define their own configurations and have a configuration context independent of the top-level\nobject. Here are some examples: class MyDut include Origen :: TopLevel def initialize add_mode :user add_mode :bist add_configuration :nvm add_configuration :ram end def enter_rambist_mode self .mode = :bist self .configuration = :ram # In a test application you would generate the necessary vectors to actually do this here # Upon exit from this method 3rd parties will now be able to tell that the DUT is in RAMBIST mode/configuration end end $dut .enter_rambist_mode # => nil $dut .mode.bist? # => true $dut .configuration # => :ram Note that currently the configuration is not represented as an object and therefore cannot\nstore additional attributes associated with the given configuration. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/naming/": {
    "title": "Naming",
    "subtitle": "Models",
    "body": "Models Naming One of the hardest things in computer science is said to be naming things. Model naming convention may vary from company to company, but we recommend aligning to whatever\nsystem is used by the hardware design teams. In other words the Origen model name for a given\nIP should be the same as whatever the RTL or macro is called for the corresponding object in the\ndesign world. The overall goal is to eliminate ambiguity and end up with a system where it straightforward to\nidentify what silicon IP is represented by a given Origen model. Class Naming Each of your model definitions will be a Ruby class and it is required by Ruby that the class\nname starts with a capital letter. It is also Ruby convention to use CamelCase for class names,\nhowever in our experience this is not necessarily easy to stick to if you are also trying to\nkeep your class names in sync with a 3rd party naming system as recommended above. If not following CamelCasedNaming, then we recommend that you uppercase and underscore\nTHE_CLASS_NAME for consistency. It is Ruby (and Origen) conventions that each class is contained within it’s own file that\nhas been assigned the lower_cased_and_underscored version of the class name. So for example the model for EAGLE_M352 would look like this: # lib/eagle_m352.rb class EAGLE_M352 # Model definition and logic goes here end Namespacing Namespacing your code is good practice and is also recommended, in Ruby a namespace involves wrapping\nall of your code in a uniquely named module. For example all of the Origen code is contained within the Origen namespace and this\n(as we will see shortly) is why the Origen register API is accessible via Origen::Registers instead of just Registers . The name used for the namespace should uniquely identify your application within your ecosystem,\nif you were writing an application to test a RAM module at a 28nm node for example, then you might go\nwith simply C28RAM . The namespacing is also mirrored in the file system hierarchy, so all of the files for C28RAM should live in lib/c28ram . Wrapping the above example in the namespace would change it to: # lib/c28ram/eagle_m352.rb module C28RAM class EAGLE_M352 # Model definition and logic goes here end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/parameters/": {
    "title": "Parameters",
    "subtitle": "Models",
    "body": "Models Parameters A given model, or indeed an application, will often have some parameters associated with\nit.\nWhile any standard Ruby accessors and instance variables can be used to define such\nparameters the following API is provided to define them in a standardized way. The \nadvantages to using this API vs. a roll-your-own solution are as follows: The API provides a number of features that go above and beyond what basic Ruby\nattribute accessors provide, this would require significant application-side code to\nreplicate Using standard APIs gives your code a familiar look and feel to any new developers who\nmay work on it in future You will be able to benefit from future additions to the Origen ecosystem that hook into\nthis API, e.g. a documentation helper to automatically generate a parameter summary\nwill almost certainly emerge Basic Idea Parameters are defined as a group of named values that will apply in a given context, many\ndifferent sets of values to apply in different contexts can be defined.\nA context can be used to represent any abstract concept that you like, but a good example \nwould be to have a set of parameter values that will apply at probe, a different set for final test and a\ndifferent set for spec operation. The current parameter context can be set and changed dynamically at runtime as required\nby your application, typically this would be set on a per-target/environment basis or for pattern\ngeneration on a per-pattern basis.\nA common approach for pattern generation is to leverage sourceless pattern generation and employ the convention that the first field in the pattern name refers to the spec\ncontext - e.g. probe_mypat, ft_mypat, spec_mypat.\nIt is then trivial to set the parameter context based on the pattern name, thereby providing a bulletproof way to update any\ngiven parameter for every probe pattern by simply updating its value in the probe parameter\nset definition. Including the Parameters API To use the parameters API in an abstract class the following module can be included: include Origen :: Parameters However this is already included the Origen::Model and Origen::TopLevel modules and any class which includes those will already have access to this API. Defining a Set of Parameters Parameters are defined as shown below, it is always a good idea to create a parameter\ncontext called :default , these are the values that will be enabled when\na parameter context has not explicitly been set: define_params :default do |params|\n params.tprog = 20 .uS\n params.terase = 100 .mS end Parameters can be organized into namespaces by simply writing them, no upfront definition\nis required and there is no limit to how deeply nested they can be: define_params :default do |params|\n params.program.time = 20 .uS\n params.erase.time = 100 .mS\n params.erase.pulse_count = 10 params.test.dc.vdd.min = 1.5 params.test.dc.vdd.max = 2.5 end Parameters are read back in application code via the params method: params.test.dc.vdd.min # => 1.5 Each namespace in the chain returns an object that can be used like a hash: def print_erase_parameters params.erase.each do |name, value|\n puts \" #{ name } : #{ value } \" end end print_erase_parameters # => time: 0.1 # => pulse_count: 10 In some cases, it is useful to have one object access another’s parameters (e.g. a sub-block can\nreference the top-level parameters sets). However, in this case the calling object may not necessarily\nbe aware of which parameters have been created. The param? method provides a quick \nway to combine an existence test while attempting to retrieve the value of a specific parameter. param?( ' test.dc.vdd.min ' ) # => 1.5 param?( ' test.dc.vdd.nom ' ) # => nil # Example to set bin using a top-level parameter or default to 12 # if the top-level parameter has not been set (i.e. does not exist) my_block_bin = dut.param?( ' testprogram.bin.my_block ' ) || 12 The current parameter context is set as follows: params.context # => :default params = :probe params.context # => :probe with_params :ft do params.context # => :ft end params.context # => :probe Tracking the Context of Another Object The parameter context for a given object can be configured to automatically track that of another object by\nspecifying a Ruby path to the object to be tracked as shown below: # A short hand is available to track the parameter context from the top level ($dut) class MyObject include Origen :: Model parameters_context :top end # Or you can supply a path to the object in the form of a string, here the path reference is local to the MyObject # instance class MyObject include Origen :: Model parameters_context ' parent.mbist ' end # Or another example where the target object is found via the global scope class MyObject include Origen :: Model parameters_context ' $dut.pll ' end Then whenever the parameter context is set on the tracked object the same context name will be applied\nwhen referencing a parameter within the tracking object, for example: $dut .params.context # => :default my_object.params.context # => :default $dut .params.context = :probe $dut .params.context # => :probe my_object.params.context # => :probe Late Defined Parameters Occasionally the need may arise to base a parameter value on a property of the model\nor the wider environment that is not yet finalized or known at the time when the parameter\ndefinition code is being executed.\nIn that case the parameter can be defined as a function and Origen will hold off evaluating\nit until the last possible moment when it is first referenced: define_params :default do |params|\n params.test.dc.vdd.min = -> { $dut .vdd * 0.9 } end Such parameters will behave identically to standard parameters in all respects and consumers\nwill not be able to tell if a given parameter originated from a function. Defining Child Sets Complete parameter sets can be defined for different named contexts, however in many cases\nonly a subset of the parameters will have different values vs. another context.\nTo make maintenance of such cases efficient the API allows parameter sets to be defined in a\nhierarchy such that a given set can be defined with a parent and if it does not define\na value for a given parameter then the value from the parent will be returned instead. Parameter sets can inherit from within the same object scope or from another DUT object\nentirely. Local inheritance passes the name of another parameter set as a Symbol. To\ninherit from another object a String must be passed that starts with ‘dut’ or ‘top, and \nis delimited by periods. Here is how the string argument is parsed: str_arg = ' dut.ddr.default ' arg_array = str_arg.split( ' . ' )\n[ ' dut ' ,top ' ].include?(arg_array[0]).should == true\ndut_path_to_object = arg_array[1..-2] # => ' ddr ' parameter_context = arg_array[-1].to_sym # => :default Local Inheritance define_params :ate , inherit : :default do |params|\n params.erase.time = 40 .mS end define_params :probe , inherit : :ate do |params|\n params.erase.time = 20 .mS\n params.erase.pulse_count = 5 end define_params :ft , inherit : :ate do |params|\n params.erase.pulse_count = 7 end with_params :probe do params.program.time # => 20uS (inherited from :default) params.erase.time # => 20ms params.erase.pulse_count # => 5 end with_params :ft do params.program.time # => 20uS (inherited from :default) params.erase.time # => 40ms (inherited from :ate) params.erase.pulse_count # => 7 end Remote Inheritance define_params :ate , inherit : ' dut.ddr.default ' do |params|\n params.erase.time = 40 .mS end Sometimes the parameter definition for a child context should be a function of the\nvalue from the parent, when defining a child context the parent can be accessed\nlike this: define_params :ate , inherit : :default do |params, parent|\n params.test.dc.vdd.min = parent.test.dc.vdd.min * 0.9 params.test.dc.vdd.max = parent.test.dc.vdd.max * 1.1 end params.context # => :default params.test.dc.vdd.min # => 1.5 params.test.dc.vdd.max # => 2.5 params = :ate params.test.dc.vdd.min # => 1.35 params.test.dc.vdd.max # => 2.75 The context can also be explicitly supplied when fetching a parameter, this will\noverride the parameter context that would otherwise be applied: params.context # => :default params.test.dc.vdd.min # => 1.5 params( :ate ).test.dc.vdd.min # => 1.35 Live Updating Parameters When a parameter is referenced a static value is returned which thereafter has no\nrelationship to the current parameter context, for example: terase = params.erase.time\nparams.erase.time # => 100ms terase # => 100ms params = :probe params.erase.time # => 20ms terase # => 100ms The above should not be surprising and is what would normally be expected, however\nthrough the magic of Ruby a live updating parameter can be returned by referring\nto it via params.live : terase = params.live.erase.time\nterase # => 100ms params = :probe terase # => 20ms This is an experimental feature and developers are encouraged to play around with it and\nreport back on any useful applications that they may find for it.\nPotentially this is a good way to expose parameters via an interface to 3rd parties without coupling\nthem tightly to the namespacing and organization of the parameters within the owning class. It is certainly only really useful when applied in conjunction with parameter contexts that can\nchange within the scope of a pattern or other Origen thread of execution. While the examples\nso far have focussed on parameter contexts that will be permanent for a given thread,\nlike probe or ft, contexts can be used to represent more dynamic concepts. For example a given\nNVM pattern may read the flash under different read conditions where the configuration for\neach one is modelled by parameter contexts defined within the read controller. Another possible use case is to bind register bit values to parameters, due to the way\nthat Origen stores register data at bit level a register cannot simply be written to a live\nparameter, however a dedicated API is provided for this case: reg :erase , 0x0 do bits 3 .. 0 , :pulses end erase.pulses.data # => 0 erase.pulses.bind params.live.erase.pulse_count\nerase.pulses.data # => 10 params = :probe erase.pulses.data # => 5 In other words anytime that register gets written in the course of a pattern generation\nrun its value will automatically track the current parameter context. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/pins/": {
    "title": "Pins",
    "subtitle": "Models",
    "body": "Models Pins Origen provides a pin (and pin group) API that should be used to define and manipulate the\nphysical pins of the device. Pins are mainly intended to be defined on models that will be used for pattern generation\nand where the pins represent the physical device pins that the tester can interact with.\nHowever in its basic form a pin is just an object that can hold a data state and there\nare probably some creative uses of the pin models outside of pattern generation. The pin API is made available to your model by including the Origen::TopLevel or Origen::Model modules. While pins can be added\nfrom any sub-module the ownership of all pins is always assigned to the top-level object,\nthis is reflecting real life where the pin is a physical property of the top-level SoC.\nTherefore it is recommended that pin definitions are always made on the top-level object\nand most modern Origen applications now take this approach. Defining Pins Pins should be defined as part of the object initialization process, but to avoid the\ninitialize method growing out of hand it is recommended that pins are instantiated in a\ndedicated method that is called upon initialization. Here is an example of how to define some JTAG interface pins in an SoC model: class MySoC include Origen :: TopLevel def initialize (options={})\n instantiate_pins(options) end def instantiate_pins (options={})\n add_pin :tclk , reset : :drive_hi , meta : { max_freq : 15 .Mhz }\n add_pin :tdi , direction : :input add_pin :tdo , direction : :output add_pin :tms end end Some points to note in the above code: add_pin will instantiate an instance of Origen::Pins::Pin Each pin must be given a name, or handle, similar to how registers are named. However unlike\nregisters the name must not only be unique within the parent object but it must also be unique\nwithin the scope of all objects instantiated by a target . The easiest way to comply with this requirement\nis to follow the advice of handling all pin definitions at the top level. Pins are initialized in the don’t care state by default, an alternative default state can be specified via\nthe :reset option. Pins are I/Os by default, however they can be defined as input or output only by using the :direction option. Application-specific meta data can be attached to the given pin via the :meta option Pins are accessed via the pin method: $dut .pin( :tdi ) # => <pin object> Note that pins can be accessed locally from any object that includes the Origen::Model module: $dut .pin( :tdi ) == $dut .memories.rambist.pin( :tdi ) # => true However references to pins within a sub-block would typically use an alias that reflected the pin function related to\nthat sub-block. Pin aliases are added like this: has_pin?( :tdi ) # => true has_pin?( :bisti ) # => false add_pin_alias :bisti , :tdi has_pin?( :bisti ) # => true pin( :bisti ) == pin( :tdi ) # => true Or called directly on the pin: pin( :tdi ).add_alias( :bisti ) Defining Pin Groups Pin groups are modelled by an object called a PinCollection which is very similar in principle to the BitCollection used for modelling registers.\nA PinCollection is essentially an extension of a regular Ruby\narray object which has some of its own attributes (such as an id for example) and everything else is proxied to\nthe contained pin objects. For pattern generation pins and pin groups will support the same API so that application code does not have to\ngive much concern as to whether it is dealing with one or the other. Pin groups are defined in a similar manner to single pins: add_pins :porta , size : 32 add_pins :portb , size : 16 , endian : :little Some points to note in the above code: add_pins will generate a new pin group, e.g. named :porta and individual pin\nobjects named :porta0 through :porta31 .\nSee below for how to define pin groups based on existing pins. Pin groups can be any size, define via the :size option. Pin groups are big endian by default, however little endian can be specified via the :endian option. Changing this attribute will have the effect of reversing the\norder that data is applied in a test pattern. Pin groups can be looked up like regular pins, or via a dedicated method if it makes application code clearer: pins( :porta ) # => <pin collection> pin_group( :porta ) # => <pin collection> A pin group is a regular Ruby array and can be iterated on and so on: pins( :porta ).size # => 32 pins( :porta ).each do |pin| # Do this for pin :porta0, :porta1, etc. end Within a pin group individual pins can be addressed via a local index: pins( :porta )[ 0 ] == pins( :porta0 ) # => true Anonymous pin groups can be composed from a range of indexes at runtime: pins( :porta ).data # => 0x0000_0000 pins( :porta )[ 0 , 1 , 2 , 3 ].drive( 0xF )\npins( :porta ).data # => 0x0000_000F pins( :porta )[ 8 .. 15 ].drive( 0x55 )\npins( :porta ).data # => 0x0000_550F Pin groups can be composed from any arbitrary group of existing pins using the add_pin_group method: # The first argument is the ID for the new pin group, followed by the IDs of the pins it should contain add_pin_group :jtag , :tdi , :tdo , :tclk , :tms pins( :jtag ).size # => 4 Pin groups can be aliased in the same way as pins, for readability the method add_pin_group_alias can be used, although internally it is the same as add_pin_alias : add_pin_group_alias :porta , :data pin_group( :data ).dont_care # Can now be used as if it were a regular first class pin group It is possible to alias a single pin within a pin group, in that case a pin number argument\nmust be supplied to add_pin_alias : add_pin_alias :moda , :porta , pin : 4 It is also possible to create a pin group from a subset of pins of a regular pin group, simply\npass in a range or an array of pin indexes to add_pin_group_alias : add_pin_group_alias :data_byte_0 , :porta , pins : [ 7 .. 0 ]\nadd_pin_group_alias :data_byte_1 , :porta , pins : [ 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 ]\n\npins( :data_byte_0 ).dont_care # Can now be used as if it were a regular first class pin group Power and Ground Pin Modelling The API supports modelling power and ground pins as follows: add_pin :pinx add_power_pin :vdd1 add_power_pin :vdd2 add_ground_pin :gnd1 add_ground_pin :gnd2 add_ground_pin :gnd3 add_power_pin_group :vdd , :vdd1 , :vdd2 add_ground_pin_group :gnd , :gnd1 , :gnd2 , :gnd3 This will cause these pins to be stored in separate collections to make pattern and other content generation easier: # Based on the above example pins.size # => 1 power_pins.size # => 2 ground_pins.size # => 3 Power and ground pin lookup should be done via dedicated methods: power_pin( :vdd1 )\nground_pins( :gnd )\n\nground_pin_groups.each do |id, group| # Do this for each ground pin group end Power pins have some dedicated attributes that can be defined, in additional to the generic meta-data hash supported\nby all pins: add_power_pin :vddio , voltage : 3 , current_limit : 50 .mA, meta : { min_voltage : 1.5 }\n\npower_pin( :vddio ).voltage # => 3 power_pin( :vddio ).current_limit # => 50E-03 power_pin( :vddio ).meta[ :min_voltage ] # => 1.5 Virtual Pin Modelling The API supports modelling virtual pins. Virtual pins are essentially user-defined pins that may not necessarily be\nassociated with the SoC, such as: Tester utility pins that control relay states on the device interface board (DIB) Tester channels to control components on the DIB add_virtual_pin( :virtual1 , type : :utility_pin )\nadd_virtual_pin( :virtual2 , type : :utility_pin )\nadd_virtual_pin( :virtual3 , type : :relay_pin )\n\nadd_virtual_pin_group :utility , :virtual1 , :virtual2 add_virtual_pin_group :relay , :virtual3 This will cause these pins to be stored in separate collections to make content generation easier: # Based on the above example virtual_pins.size # => 3 Virtual pin lookup should be done via a dedicated method: virtual_pin( :virtual1 )\n\nvirtual_pin_groups.each do |id, group| # Do this for each virtual pin group end Changing Data State See the Pin API for full details of what methods are available. Here are a few examples of working with pins: # Make the tester drive a value on a pin pin( :tdi ).drive_hi # Equivalent to above, this form is better when serially applying data in a loop... pin( :tdi ).drive( 1 ) # ...like this... reg( :data ).shift_out_left do |bit|\n pin( :porta ).drive(bit.data) end # Asserting that a pin drives a certain value has various aliases, these are all equivalent pin( :tdo ).assert( 1 )\npin( :tdo ).compare( 1 )\npin( :tdo ).expect( 1 ) # Current state can be queried pin( :tdo ).driving? # false pin( :tdo ).comparing? # true pin( :tdo ).dont_care\npin( :tdo ).comparing? # false pin( :tms ).drive_lo\npin( :tms ).toggle # Pin groups support the same methods as pins pins( :porta ).drive( 0x55 ) # 01010101 pins( :porta ).assert( 0x55 ) # LHLHLHLH pins( :porta ).dont_care # XXXXXXXX # Individual pins within a pin group can be accessed by index pins( :porta )[ 1 ].drive( 0 ) # XXXXXX0X Bang (!) Methods Almost all pin methods have a bang form, for example: pin( :tdi ).drive!( 1 ) The bang methods will set the state on the pin in the same way as the regular method but\nwill then automatically fire off a tester cycle to generate a vector. In other words the above is the shorthand equivalent of: pin( :tdi ).drive( 1 ) $tester .cycle Pin Availability by Package Pins can be defined based on a specific package context which can be used to gate their availability. Here is an example: # Initially define the available packages at the top level before adding any pins class MySoC include Origen :: TopLevel def initialize add_package :pkg1 add_package :pkg2 end end Pins can then be defined by package: add_pin :pin1 , packages : :all add_pin :pin2 # No constraint is equivalent to :all add_pin :pin3 , package : :pkg2 add_pin :pin4 , packages : [ :pkg1 , :pkg2 ] # Pins can also be added within a package scope, these will add to :pkg1 only with_package :pkg1 do add_pin :pin5 add_pin :pin6 end # All pins are available when the package is set to nil, no package represents the die package # => nil pins.size # => 6 package = :pkg1 pins.size # => 5 (no pin3) has_pin?( :pin3 ) # => false package = :pkg2 pins.size # => 4 (no pin5 or pin6) has_pin?( :pin3 ) # => true Pin groups can contain different sets of pins in different packages: add_pin( :pin1 )\nadd_pin( :pin2 )\nadd_pin( :pin3 )\n\nadd_pin_group :g1 , :pin1 , :pin2 , package : :pkg1 add_pin_group :g1 , :pin1 , :pin2 , :pin3 , package : :pkg2 has_pins?( :g1 ) # => false pin_groups.size # => 0 package = :pkg1 has_pins?( :g1 ) # => true pins( :g1 ).size # => 2 pin_groups.size # => 1 package = :pkg2 has_pins?( :g1 ) # => true pins( :g1 ).size # => 3 pin_groups.size # => 1 Package Attributes The attributes listed in the constant PACKAGE_SCOPED_ATTRIBUTES in the Pin API can be set to specific values per package. Here is an example of how to set the pin location by package: # At definition time add_pin :pin1 , packages : { pkg1 : { location : \" A2 \" }, pkg2 : { location : \" A3 \" }}\nadd_pin :pin2 # Or later pins( :pin2 ).add_location \" A5 \" , package : :pkg1 pins( :pin2 ).add_location \" B2 \" , package : :pkg2 package = :pkg1 pins( :pin1 ).location # => \"A2\" pins( :pin2 ).location # => \"A5\" package = :pkg2 pins( :pin1 ).location # => \"A3\" pins( :pin2 ).location # => \"B2\" A context can also be supplied when reading such attributes to override the current context: package = :pkg1 pins( :pin1 ).location # => \"A2\" pins( :pin1 ).location( package : :pkg2 ) # => \"A3\" Origen will automatically create an alias for the given location (a lower cased symbol) that is scoped to the package. package = :pkg1 has_pin?( :a2 ) # => true has_pin?( :a3 ) # => false package = :pkg2 has_pin?( :a2 ) # => false has_pin?( :a3 ) # => true Certain types of metadata only become available at distinct times in a product lifecycle, for example Device Interface Board (DIB) information.\nDepending on when the pin model is constructed the user can specify the DIB metadata in two ways: # All at once $dut .add_pin :tdi , packages : { bga : { location : ' BF2 ' , dib_meta : { channel : 100106 , connection : \" PE117.08 \" , slot : \" PE117 \" , spring_pin : \" 08 \" } } } # Over time $dut .add_pin :tdi , packages : { bga : { location : ' BF2 ' } } $dut .pins( :tdi ).add_dib_meta :bga , { channel : 100106 , connection : \" PE117.08 \" , slot : \" PE117 \" , spring_pin : \" 08 \" } Pin Functions Pin aliases are an example of modelling different pin functions that can be mux’d onto the same pin, in this case\nthe pin attributes are the same regardless of the function name being used. However sometimes it is necessary to model different attributes depending on the pin function - for example under\none function the pin may be an input, but when used as another function it is an output. The attributes listed in the constant FUNCTION_SCOPED_ATTRIBUTES in the Pin API can be set to specific values per context (mode and/or configuration). If any of these function-scoped attributes are a hash then the function-specific value will be merged with any\ndefault value that has been defined on the pin. This allows the function to override default values and inherit\ndefault values for attributes that it doesn’t care about.\nLook at the meta data in the example below to see this in action. Here is an example of adding a function: class MySoC include Origen :: TopLevel def initialize add_pin :pin1 add_pin :pin2 , meta : { vol : 0.4 , voh : 0.6 } # Example of default meta data # Define some pin functions pin( :pin1 ).add_function :nvm_fail , direction : :output pin( :pin2 ).add_function :nvm_done , direction : :output , meta : { voh : 0.7 } # Override some of the meta data pin( :pin1 ).add_function :tdi , direction : :input pin( :pin2 ).add_function :tdo , direction : :output # Add some groupings that are associated with specific pin functions add_pin_group :jtag , :tdi , :tdo add_pin_group :nvm , :nvm_fail , :nvm_done end end $dut = MySoC .new # The name used to look up a pin now returns the pin with a thin wrapper around it # which defines its current function: $dut .pin( :nvm_fail ).direction # => :output $dut .pin( :nvm_done ).direction # => :output $dut .pin( :tdi ).direction # => :input $dut .pin( :tdo ).direction # => :output # If a function name is given when defining a pin group, the pin will always have # that function when it is accessed through the resultant group $dut .pins( :jtag )[ 0 ].direction # => :output $dut .pins( :jtag )[ 1 ].direction # => :input $dut .pins( :nvm )[ 0 ].direction # => :output $dut .pins( :nvm )[ 1 ].direction # => :output # The pin's meta data can be overridden by function $dut .pin( :tdo ).meta # => { vol: 0.4, voh: 0.6 } $dut .pin( :nvm_done ).meta # => { vol: 0.4, voh: 0.7 } Pin Clock Functionality The API supports creating a free-running clock on any existing pin, where the timing parameters\nof the clock can be specified and vector generation (in relation to the current tester timeset)\nwill be automatically handled. See the Pin Clock API below. enable_clock(options) Enable the clock functionality on a given pin. Does not start the clock, only sets up\nits internally tracked parameters. Clock can be specified in cycles, time, or frequency $dut .pin( :pin1 ).enable_clock( period_in_ns : 200 ) # create free-running clock with 200ns period $dut .pin( :pin2 ).enable_clock( frequency_in_khz : 32 ) # create 32Khz free-running clock start_clock(options = {}) Start an existing clock or create and start a free-running clock on a given pin $dut .pin( :pin2 ).start_clock # start up existing clock pin2 $dut .pin( :pin3 ).start_clock( period_in_us : 2 ) # create and start clock with 2us period stop_clock, pause_clock Stop the clock running on a given pin $dut .pin( :pin1 ).stop_clock # stop clock on pin1 $dut .pin( :pin2 ).pause_clock # stop clock on pin2 $dut .pin( :pin3 ).pause_clock # stop clock on pin3 resume_clock(options = {}) Restart an existing clock. Can be restarted with existing parameters or restarted with a new clock setup $dut .pin( :pin2 ).resume_clock # resume clocking on pin2 with existing clock setup $dut .pin( :pin3 ).resume_clock( period_in_ns : 100 ) # resume clocking on pin3 with new clock parameters Some addtional examples: # Create timeset with 2-ns period $tester .set_timeset( ' ts_50Mhz ' , 20 ) # timeset period is 20ns # In this example, we enable (without immediately starting) a clock pin with # 100ns period and then pause, resume, and stop later in the pattern. $dut .pin( :pin1 ).enable_clock( period_in_ns : 100 ) $dut .pin( :pin1 ).start_clock\n... $dut .pin( :pin1 ).pause_clock\n... $dut .pin( :pin1 ).resume_clock\n... $dut .pin( :pin1 ).stop_clock\n... # In this example, we start free-running clock with 200ns period, then later stop # and restart with a different (100ns period) setup. $dut .pin( :pin2 ).start_clock( period_in_ns : 200 )\n... $dut .pin( :pin2 ).stop_clock\n... $dut .pin( :pin2 ).start_clock( period_in_ns : 100 )\n... $dut .pin( :pin2 ).stop_clock\n... Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/power/": {
    "title": "Power Domains",
    "subtitle": "Models",
    "body": "Models Power Domains Power domains are modeled from the Design side, not from an ATE perspective. Power domains are not the same thing\nas power pins, rather power domains contain (indirectly) three types of pins: Signal Power Ground The idea behind modeling power domains is to provide a source of truth for the voltages various pins are programmed to\non the ATE. There is no native pin levels API yet in Origen but users do create ATE levels using the Origen compiler . Prior to the development of PowerDomains, \napplications would likely use the Origen::Parameters module to store pin levels.\nThe advantage of using PowerDomains is that all pins get a single source of truth for their programmed value. Here is an example of the PowerDomain API: add_power_domain :vdd do |domain|\n domain.description = ' CPU Core Complex ' domain.nominal_voltage = 0.9 .V\n domain.unit_voltage_range = 0.7 .V.. 1.1 .V end add_power_domain :vdda do |domain|\n domain.description = ' PLL ' domain.nominal_voltage = 1.2 .V\n domain.unit_voltage_range = 1.08 .V.. 1.32 .V end add_power_domain :vccsoc do |domain|\n domain.description = ' SoC ' domain.nominal_voltage = 1.5 .V\n domain.unit_voltage_range = 1.35 .V.. 1.65 .V end Now we can interact with the power domains using the top level DUT. $dut .power_domains # => [:vdd, :vdda, :vccsoc] $dut .power_domains( :vdd ).description # => \"CPU Core Complex\" $dut .power_domains( :vdd ).nominal_voltage # => 1.0.V $dut .power_domains( :vdd ).range # => (0.7.V..1.1.V) Typically in Origen, models own things directly, but in the case of power domains, they ‘own’ pins indirectly. Most apps\ninstantiate pins to the top level DUT so the PowerDomains module was written to deal with that reality, versus asking apps\nto instantiate pins within a power domain. In order for a power domain to be aware of the pins it ‘owns’, pins must set\nthe ‘supply’ pin attribute. Let’s define some pins, for the :vdd power domain, that have the supply attribute defined. VDD_SIGNAL_PINS = [ :pin1 , :pin2 , :pin3 ] VDD_POWER_PINS = [ :vdd1 , :vdd2 , :vdd3 ] VDD_GND_PINS = [ :vss1 , :vss2 , :vss3 ] def initialize VDD_SIGNAL_PINS .each do |p| $dut .add_pin p do |pin|\n pin.supply = :vdd end end VDD_POWER_PINS .each do |p| $dut .add_power_pin p do |pin|\n pin.supply = :vdd end end VDD_GND_PINS .each do |p| $dut .add_ground_pin p do |pin|\n pin.supply = :vdd end end end Here are some methods available to interact with the pins associated with a power domain. $dut .power_domains( :vdd ).signal_pins # => [:pin1, :pin2, :pin3] $dut .power_domains( :vdd ).power_pins # => [:vdd1, :vdd2, :vdd3] $dut .power_domains( :vdd ).ground_pins # => [:vss1, :vss2, :vss3] $dut .power_domains( :vdd ).has_pin?( :vdd1 ) # => true $dut .power_domains( :vdd ).pin_type( :vdd1 ) # => :power $dut .power_domains( :vdd ).has_power_pin?( :vdd1 ) # => true $dut .power_domains( :vdd ).has_pin?( :pin1 ) # => true $dut .power_domains( :vdd ).pin_type( :pin1 ) # => :signal $dut .power_domains( :vdd ).has_signal_pin?( :pin1 ) # => true $dut .power_domains( :vdd ).has_pin?( :vss1 ) # => true $dut .power_domains( :vdd ).pin_type( :vss1 ) # => :ground $dut .power_domains( :vdd ).has_ground_pin?( :vss1 ) # => true $dut .power_domains( :vdda ).signal_pins # => [] $dut .power_domains( :vdda ).power_pins # => [] $dut .power_domains( :vdda ).ground_pins # => [] $dut .power_domains( :vdda ).has_pin?( :vdd1 ) # => false After a power domain is instantiated, its setpoint or value is nil by default. This behavior is by design, such that the\nuser could define chip modes or parameter contexts that provide scope\nfor a group of power domain values. Here are some examples of setting power domain setpoints/values. $dut .power_domains( :vdd ).setpoint = 0.72 .V $dut .power_domains( :vdda ).setpoint = 1.10 .V $dut .power_domains( :vccsoc ).setpoint = 1.37 .V A little about the attribute ‘unit_voltage_range’. If a power domain has this attribute set to :fixed, then it means all units\nwill see the eact same voltage when the device is powered up. If this attribute is set to a Range, then it means each device can \npower-up to a unique voltage, based on a permanently programmed value stored within the device (e.g. using e-fuses). Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/registers/": {
    "title": "Registers",
    "subtitle": "Models",
    "body": "Models Registers When modelling semiconductor IP, there will almost always be a need to define register\nand bit maps and Origen provides an API specifically for this purpose. When modelling silicon with Origen, the hardware should be the guide as to\nwhere logic or attributes should go and if you have followed the advice so far\nthen you will already have a model framework that closely resembles the physical hardware.\nThe registers then, are simply instantiated within the model of the corresponding hardware\nthat owns them. Defining Registers Registers should be defined as part of the object initialization process, but to avoid the\ninitialize method growing out of hand it is recommended that you instantiate registers in a\ndedicated method that is called upon initialization. When defining registers you can either take the approach of defining them all up front\nor defining them individually on an as-needed basis - the latter is recommended as it is the most\nefficient in terms of effort. Here is an example of how to define this register in our memory map: # file: lib/nvm/analog_t921.rb module NVM class ANALOG_T921 include Origen :: Model def initialize (options={})\n instantiate_registers(options) end def instantiate_registers (options={})\n reg :ctrl , 0x0024 , size : 16 do |reg|\n reg.bit 7 , :coco , access : :ro reg.bit 6 , :aien reg.bit 5 , :diff reg.bit 4 .. 0 , :adch , reset : 0x1F end end end end Some points to note in the above code: Even though we have not used it we have continued the practice of setting up every method with\nan optional option argument and we have passed this between method calls - i.e. we passed the\ninitialize options when calling instantiate_registers. This keeps things extremely flexible for\nthe future and means that it is easy to influence the register instantiation externally, for\nexample: NVM::ANALOG_T921.new(include_test_registers: true) The reg method takes a name, address and size as arguments. The size is optional\nand is 32 by default. Bit definitions are contained within the do..end block passed to the reg method. By default bits are writable and will reset to 0, but this can be overridden as shown\nin the example. When defining bits the size is 1 by default and the reset state is 0 by default, these can be\noverridden on an as needed basis as shown above. Accessing Registers Origen will automatically create accessor methods for the register and its bits, the above register\nwould be accessed like this: $dut .nvm.analog.ctrl # => <register object> $dut .nvm.analog.ctrl.adch # => <subset of bits> The Origen console will show a nice graphical representation of the register which reflects its\ncurrent state, this can be very useful when debugging or more generally as an interactive\nversion of the block guide: > origen i\n\n>> $dut.nvm.analog.ctrl\n=>\n0x24 - :ctrl\n ================================================================================================================\n | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 |\n | | | | | | | | |\n | | | | | | | | |\n ----------------------------------------------------------------------------------------------------------------\n | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\n | :coco | :aien | :diff | :adch[4:0] |\n | 0(RO) | 0 | 0 | 0x1F |\n ---------------------------------------------------------------------------------------------------------------- Origen supports some more verbose APIs that you may see used in some codebases or documentation,\nthese are now considered legacy APIs but are equivalent to the above: $dut .nvm.analog.reg( :ctrl ) $dut .nvm.analog.reg( :ctrl ).bits( :adch ) $dut .nvm.analog.reg( :ctrl )[ :adch ] Origen supports Verilog style part selects to access an ad-hoc subset of bits, although unfortunately [3:0] is not valid Ruby and [3..0] is used instead. $dut .nvm.analog.ctrl[ 1 ] # => bit 1 of the register $dut .nvm.analog.ctrl.adch[ 1 ] # => bit 1 of the adch bits $dut .nvm.analog.ctrl[ 3 .. 0 ] $dut .nvm.analog.ctrl.adch[ 1 .. 0 ] Bit Order and Serial Processing By default, a register is defined with its LSB in bit position 0, this can be changed to the MSB at position 0 by setting the bit_order attribute as shown below: reg :ctrl , 0x0024 , size : 16 , bit_order : :msb0 do |reg| # Bit definitions would be exactly the same as the above example end A register with the MSB in bit position 0 will appear reversed in the console view, compare the following to the earlier example: > origen i\n\n>> $dut.nvm.analog.ctrl\n=>\n0x24 - :ctrl\n ================================================================================================================\n | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |\n | :adch[4:0] | :diff | :aien | :coco |\n | 0x1F | 0 | 0 | 0(RO) |\n ----------------------------------------------------------------------------------------------------------------\n | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |\n | | | | | | | | |\n | | | | | | | | |\n ---------------------------------------------------------------------------------------------------------------- When serially processing a register (in a pattern driver for example), some of the APIs will change order depending on the bit_order value.\nHere is a summary of the APIs that are available for serially processing a register and how they behave in respect to this\nattribute: shift_out / shift_out_with_index - A logical rather than a physical shift, this will process the bits with the LSB going first\nand it will behave the same regardless of the register’s bit order. reverse_shift_out / reverse_shift_out_with_index - As above, but MSB first. shift_out_left / shift_out_left_with_index - Think of this as a physical shift, it will process the top-left bit of the\nregister first and which bit that is will depend on the bit order. shift_out_right / shift_out_right_with_index - As above, but with the bottom-right bit going first. All of these APIs behave like this: myreg.shift_out_left_with_index do |bit, i| # This block will execute for each bit in the register # *bit* is a bit object (instance of Origen::Reg::Bit) # *i* is the iteration index, 0, 1, 2, etc. Note that this is only available for the _with_index versions. bist_shift(bit) end Base Addresses When defining registers the address specified should be the local address within the owning\nIP block. Base addresses can be passed in within the sub block definition, base_address is an official\noption that Origen will recognize and automatically deal with. # lib/nvm/nvm_m682.rb sub_block :analog , class_name : \" ANALOG_T921 \" , base_address : 0x4000_0000 Registers will automatically pick up the base address of their parent, the local address can\nbe accessed via the offset method: $dut .nvm.analog.ctrl.address # => 0x4000_0024 $dut .nvm.analog.ctrl.offset # => 0x24 Note that when resolving a base address Origen will look right up the hierarchy until it reaches the top\nlevel object and all base addresses in that branch of the tree will be added together. Register Domains An API is available to model register domains, where domain could mean what bus or clk domain that the\nregister is on, or any similar concept. Domains must first be declared in the object that owns them and then they can be passed to sub block\ndefinitions: domain : :ips domain : :ahb , endian : :little sub_block :analog , class_name : \" ANALOG_T921 \" , base_address : 0x4000_0000 , domain : :ips The domain attribute will also accept an array of multiple domain names as required. The child block and any of its registers will then be associated with the given domains: $dut .nvm.analog.domains # => {ips: <object>} $dut .nvm.analog.ctrl.domains # => {ips: <object>} Note that the domains method returns a hash pointing to objects that represent the domains,\nthis can therefore be associated with attributes such as the :endian attribute in the\nexample above. See the Domain Class API for an up to date list of\nsupported attributes. Per-Domain Base Addresses Domain specific base addresses can be assigned to a sub-block by passing a hash to the :base_address option as shown in the example below: class Top include Origen :: TopLevel def initialize domain :ips domain :ahb sub_block :subx1 , class_name : \" SubX \" , base_address : 0x1000_0000 sub_block :subx2 , class_name : \" SubX \" , base_address : { ips : 0x2000_0000 , ahb : 0x3000_0000 } end end class SubX include Origen :: Model def initialize reg :reg1 , 0x200 do bits 31 .. 0 , :data end sub_block :suby1 , class_name : \" SubY \" , domain : :ips sub_block :suby2 , class_name : \" SubY \" , domain : :ahb end end class SubY include Origen :: Model def initialize reg :reg1 , 0x300 do bits 31 .. 0 , :data end end end $dut = Top .new $dut .subx1.reg1.address # => 0x1000_0200 $dut .subx1.suby1.reg1.address # => 0x1000_0300 $dut .subx1.suby2.reg1.address # => 0x1000_0300 # Where a register falls into the case where multiple domains are specified for it, you must # indicate the one you want $dut .subx1.reg1.address( domain : :ips ) # => 0x2000_0200 $dut .subx1.reg1.address( domain : :ahb ) # => 0x3000_0200 $dut .subx2.suby1.reg1.address # => 0x2000_0300 $dut .subx2.suby2.reg1.address # => 0x3000_0300 In the case where a register owned by a child sub-block is not in any of the domains listed in the base address\nhash then it will pick up a base address of 0. An alternative default can be set by adding a :default key to the hash: sub_block :subx2 , class_name : \" SubX \" , base_address : { default : 0x1000_0000 , ips : 0x2000_0000 , ahb : 0x3000_0000 } Documenting Registers Registers can be documented by Ruby comments like this: # ** MGATE Clock Divider Register ** # The MCLKDIV register is used to divide down the frequency of the HBOSCCLK input. If the MCLKDIV # register is set to value \"N\", then the output (beat) frequency of the clock divider is OSCCLK / (N+1). The # resulting beats are, in turn, counted by the PTIMER module to control the duration of Flash high-voltage # operations. reg :mclkdiv , 0x0003 , size : 16 do |reg| # **Oscillator (Hi)** - Firmware FMU clk source selection. (Note that in addition to this firmware-controlled bit, the # FMU clock source is also dependent on test and power control discretes). # # 0 | FMU clock is the externally supplied bus clock ipg_clk # 1 | FMU clock is the internal oscillator from the TFS hardblock reg.bit 15 , :osch , reset : 1 end The descriptions are then programmatically accessible via the following methods: mclkdiv.full_name # => \"MGATE Clock Divider Register\" mclkdiv.description( include_name : false ) # => [\"The MCLKDIV register is...\", \"register is set...\", ...] bit = mclkdiv.osch\nbit.full_name # => \"Oscillator (Hi)\" bit.description( include_name : false , include_bit_values : false ) # => [\"Firmware FMU clk...\", \"FMU clock...\", ...] bit.bit_value_descriptions[ 0 ] # => \"FMU clock is the externally supplied bus block ipg_clk\" bit.bit_value_descriptions[ 1 ] # => \"FMU clock is the internal oscillator from the TFS hardblock\" Most commonly these descriptions will be used for documentation, for example the Documentation Helpers plugin provides\nhelpers to easily present registers in Origen documentation as shown here - Register Helpers . The descriptions can also be supplied as in-line arguments, but doing so overrides any comment-based\ndocumentation. Thus, it is intended to be used\nonly when the register is being declared programmatically by an importer and humans\nshould stick to the above API for clarity: reg :mclkdiv , 0x0003 , size : 16 , description : \" ** MGATE Clock Divider Register ** The MCLKDIV reg... \" do |reg|\n reg.bit 15 , :osch , reset : 1 , description : \" ** Oscillator (Hi) ** - Firmware FMU clk source selection... \" end Defining Application-Specific Metadata Within a given application it may be desired to attach some meta-data to a register or bits to\ntrack application-specific properties, for example whether a register is only readable in test\nmode or not. The object owning the register can define a default set of custom attributes and then override\nthese for specific registers and bits.\nHere is an example: def instantiate_registers (options={})\n\n default_reg_metadata do |reg|\n reg.user_reg = false end default_bit_metadata do |bit|\n bit.time_to_respond = 0 end reg :fstat , 0x0001 , size : 8 , user_reg : true do |reg|\n reg.bit 8 , :ccif , time_to_respond : 10 .us\n reg.bit 7 , :rdcolerr reg.bit 6 , :accerr , access : :w1c reg.bit 5 , :fpviol , access : :w1c reg.bit 0 , :mgstat , access : :ro end reg :mclkdiv , 0x0002 , size : 16 do |reg|\n reg.bit 15 , :osch , reset : 1 reg.bit 13 .. 12 , :mode_rdy , writable : false reg.bit 10 , :eccen , reset : 1 reg.bit 9 .. 8 , :cmdloc reg.bit 7 .. 0 , :div end end fstat.user_reg? # => true mclkdiv.user_reg? # => false fstat.ccif.time_to_respond # => 10us fstat.accerr.time_to_respond # => 0 Global attributes can also be added, when done in this way the meta data\nwill be applied to all registers within the scope of an application. If the same attribute is later declared within a class as above then the value\nfrom the class will take precedence. As with the above example the attribute values can be overridden when\ndefining registers and bits. Origen :: Registers .default_reg_metadata do |reg|\n reg.attr_x # Adds the attribute with a default value of nil reg.attr_y = 10 # Adds the attribute with a default value of 10 end Origen :: Registers .default_bit_metadata do |reg|\n reg.attr_z = 15 end Plugins may also use this approach to globally extend the attributes of\nregisters and bits. Importing Registers If the register data for the target device/module is already mastered somewhere else, for\nexample in IP-XACT format, then it can be imported directly to save having to manually duplicate the\nregister definitions in Origen.\nThis will generate the exact same models of the registers as if they had been declared directly\ninto Origen. This import (and export) functionality is provided via the Cross Origen plugin and this should be consulted directly for the latest information on the API and the supported formats. However here is a brief example of how it can be used to import from a local XML file: # lib/nvm/nvm_m682.rb module NVM class NVM_M682 include Origen :: Model include CrossOrigen def initialize (options={})\n cr_import( path : \" #{ Origen .root } /ipxact_files/nvm_m682.xml \" ) end end end Understanding the Origen Register Model By using the above API Origen has now built an accurate register model that will look and behave like the\nreal register on silicon.\nThis is extremely convenient and useful for pattern generation as we will see later, but it can also\nbe very useful for other applications such as generating documentation . Each register created by Origen is an instance of the Origen::Registers::Reg class.\nThis does not by itself provide that much functionality and its main purpose is as a container for the\nindividual bits that make up the register. Each bit is an instance of the Origen::Registers::Bit class. The main function of the bit object is to store a single bit of data and to track the state of various\nattribute flags that monitor such things as whether the bit is writable, or readable, or whether a particular bit\nis required to be read during a test pattern operation. Similar to the Reg the Bit API is mainly for internal use. Instead the public facing API is implemented by the Origen::Registers::BitCollection class.\nThis class provides a consistent API whether you are working with an entire register or a subset of bits in\nthe register. By calling ctrl a new BitCollection is generated on the fly and populated\nwith all of the bit objects contained in the register.\nSimilarly if you call ctrl.adch then a BitCollection will be\nreturned that contains only the subset of requested bits. Examples Here are a few examples of working with the register that we recently added: $dut = SOC :: EAGLE_M352 .new( version : 1 )\n\nreg = $dut .nvm.analog.ctrl\n\nreg.data # => 31 reg.data.to_hex # => \"0x1F\" # Only bits that are writable can hold data, the same as real silicon reg.write( 0xFFFF )\nreg.data.to_hex # => \"0x7F\" # Individual bits can be manipulated reg.adch.data # => 31 reg.adch.write( 0 ) \nreg.adch.data # => 0 reg.data.to_hex # => \"0x60\" # Bits can be marked for read reg.is_to_be_read? # => false reg.coco.read\nreg.coco.is_to_be_read? # => true reg.aien.is_to_be_read? # => false reg.is_to_be_read? # => true # The register can be reset reg.reset\nreg.is_to_be_read? # => false reg.data.to_hex # => \"0x1F\" More Examples Here are some addtional examples showing how to iterate through a model’s registers class Top include Origen :: TopLevel def initialize reg :adc0_cfg , 0x200 do bits 31 .. 0 , :data end reg :adc1_cfg , 0x300 do bits 31 .. 0 , :data end reg :dac_cfg , 0x400 do bits 31 .. 0 , :data end reg :status , 0x100 do bits 31 .. 0 , :data end end end $dut = Top .new # Iterate over ALL registers (:adc0_cfg, :adc1_cfg, :dac_cfg, :status) $dut .regs.each do |r| # do something with register r end # Iterate over all registers matching a regular expression # Ex 1: Only ADC cfg registers (:adc0_cfg, :adc1_cfg) $dut .regs( ' /acd \\d _cfg/ ' ).each do |r| # do something with register r end # Ex 2: Any cfg registers (:adc0_cfg, :adc1_cfg, :dac_cfg) $dut .regs( ' /cfg/ ' ).each do |r| # do something with register r end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/specs/": {
    "title": "Specifications",
    "subtitle": "Models",
    "body": "Models Specifications Dictionary.com defines a specifications (or spec): a detailed description or assessment of requirements, dimensions, materials, etc., as of proposed building, machine, bridge, etc. Origen refines spec to mean a parametric measure that has the following basic attributes: Name Symbol Type Mode Audience Description Limits (min, max, typ) This is not the complete list of attributes but a well defined spec should define these\nattributes. Specification API The spec API is in the preliminary stages so please send feedback for enhancements Most engineers are probably familiar with a data sheet specification that looks something\nlike this: Parameter Symbol Min Typ Max Unit Notes ADDR/CMD Setup tddkhas 495     ps wrt MCK There are three attributes required to define a Spec: name, mode, and type. A fourth\nattribute (sub_type) can further delineate a Spec but it is not required. The basic\nspec API can take two syntactical forms. The first is a more traditional Ruby syntax\nand the second makes the API feel more like a custom DSL. spec :soc_vdd , :dc do |spec|\n spec.symbol = \" Vdd \" spec.description = \" Soc Core Power Supply \" spec.min = \" 1.00.V - 50.mV \" spec.max = 1.05 spec.unit = \" V \" spec.audience = :external end spec :soc_vdd , :dc do symbol \" Vdd \" description \" Soc Core Power Supply \" min \" 1.00.V - 50.mV \" max 1.05 unit \" V \" audience :external end While the user can be free to add various attributes over time, they must assign a valid\nname and have valid limits to complete instantiation. A valid name must not start with\nletters and cannot contain special characters forbidden by Ruby. Dashes and underscores\nare allowed but the preferred method is to make spec name Symbols in the snake-case format .\nLimits can be of type Numeric or String so the API is flexible enough to handle\nspecs with a formula as the limit. Valid limits are defined as: If Min && Max: Min < Max if limit is Numeric. If Target, Min < Target < Max A target can be thought of as an unofficial typical value. Targets are typically used when\nspecs are exported for use in data analysis and also help understand if a min anx max limit\nare not symetrical. During spec limit assignment the user just can either input a numeric value, a symbol or\na string. [ 1 ] pry()> @ip .specs( :ip_setup_time ).min\n=> #<struct Origen::Specs::Spec::Limit exp=\"250.ps + 25.ps\", maturity=nil, value=2.7e-10> [ 2 ] pry()> @ip .specs( :ip_setup_time ).min.exp\n=> \" 250.ps + 25.ps \" [ 3 ] pry()> @ip .specs( :ip_setup_time ).min.value\n=> 2.7e-10 The Spec model will save the original user input as an expression and will\nattempt to evaluate the string to a numeric value or lookup the symbol within the\nParameters and Specs database. Currently only the numeric and string expressions are working. Notice how the mode attribute is never specified. This is because the Spec API will\nalways use the mode of the current object as a default. If no mode is specified (nil)\nthe user intends for the Spec to be available to all modes of the defining object. The\nuser, of course, can specify a mode as shown below. The Spec API will only return\nspecs that match that specified mode instead of returning globally defined specs. spec :soc_vdd , :dc , :mymode do symbol \" Vdd \" description \" Soc Core Power Supply \" min \" 1.00.V - 50.mV \" max 1.05 unit \" V \" audience :external end Another thing to note about modes is that specs defined with no mode will be\ncatalogued as :global if the owning object is Origen.top_level and :local for\nany other owning IP. This allows certain specs to be used across the Origen\necosystem and other local specs to be contained inside the owning IP. The user can search for specs using filters for any of the following: Name Mode Type Sub-Type If any of the options are nil it will not filter by that option when interrogating the\nspec database. The API is: specs( :myspecname , options) In the example above a symbol is passed for the spec name but all four filter options\ncan be a String, Number or a Regexp. If an object defined three specs named :soc_vdd,\n:io_vdd, :pll_vdd the following call would occur. specs( / vdd / , verbose : true ) ================================================================================================\n| IP: soc |\n================================================================================================\n| Name | Symbol | Mode | Type | Parameter | Min | Max | Unit | Audience |\n------------------------------------------------------------------------------------------------\n| soc_vdd | Vdd | :global | dc | Soc Core Power Supply | 0.95 | 1.05 | V | external |\n| io_vdd | OVdd | :global | dc | Soc IO Power Supply | 1.45 | 1.55 | V | external |\n| pll_vdd | AVdd | :global | dc | Soc PLL Power Supply | 1.15 | 1.25 | V | external |\n------------------------------------------------------------------------------------------------ If the ‘verbose’ argument is not included, only an array of spec objects is returned. If only a\nsingle spec is found a Spec object is returned instead of an array of a single spec. The console\nprinting method only displays attributes which have content for at least one of the specs\nfound. It also auto-adjusts the attribute column padding so no space is wasted. Specs and Modes in Detail Specs can be defined globally or within nested sub_blocks or controllers . A spec\nis defined in the context of a mode, even if it only has a single mode. A mode is defined as\na known device state with a unique name or id. An simple example could be a basic PORESET\nthat defines the clocking and register space state after turning a chip on. The spec\nAPI does not require a mode to be defined but it will assign some reserved modes if none is\nprovided. If the owner of the block is equal to Origen.top_level a mode named :global is assigned,\notherwise a mode named :local is assigned. Specs with a local mode are not accessible\noutside the model in which they are defined. A spec with a global mode is accessible\neverywhere but will be overwritten is defined both globally and locally. Here is an\nexample where a spec is defined within three modes. class SoC_With_Specs include Origen :: TopLevel def initialize sub_block :ip_with_specs , class_name : \" IP_With_Specs \" , base_address : 0x1000_0000 add_mode :default add_mode :low_power add_mode :high_performance modes.each do |mode| case mode when :default vdd_nom = 1.0 .V when :low_power vdd_nom = 0.95 .V when :high_performance vdd_nom = 1.05 .V end spec :soc_vdd , :dc , mode do symbol \" Vdd \" description \" Soc Core Power Supply \" min \" #{ vdd_nom } - 50.mV \" max \" #{ vdd_nom } + 50.mV \" audience :external end end end end Notice below how both the limit expression and value get changed based on the mode\nselection of the owning IP. [8] pry()> @dut.mode\n=> high_performance\n[9] pry()> @dut.specs(:soc_vdd).min.exp\n=> \"1.05 - 50.mV\"\n[10] pry()> @dut.specs(:soc_vdd).min.value\n=> 1.0\n[11] pry()> @dut.mode = :low_power\n=> :low_power\n[12] pry()> @dut.specs(:soc_vdd).min.value\n=> 0.9\n[13] pry()> @dut.specs(:soc_vdd).min.exp\n=> \"0.95 - 50.mV\" Specs have an audience attribute that can be set to :internal or :external. They\nalso have a read-only attribute called ‘limit_type’ which is either :single_sided\nor :double_sided. Here are some attribute access examples: [7] pry()> @ip.specs(:ip_setup_time).mode\n=> :new_mode_with_altered_specs\n[8] pry()> @ip.specs(:ip_setup_time).limit_type\n=> :double_sided\n[10] pry()> @ip.specs(:ip_setup_time).notes = \"my note\"\n=> \"my note\"\n[11] pry()> @ip.specs(:ip_setup_time).notes\n=> \"my note\"\n[12] pry()> @ip.specs(:ip_setup_time).symbol # Defaults to name if no value supplied\n=> :ip_setup_time\n[13] pry()> @ip.specs(:ip_setup_time).testable\n=> true\n[14] pry()> @ip.specs(:ip_setup_time).audience\n=> :internal\n[15] pry()> @ip.specs(:ip_setup_time).description\n=> \"IP Setup Time with Double-Sided Limits\" The Origen::Specs::Spec class is available to all models and as such has a method ot find all specs\nthat exist in the model itself or any child models. This method is useful when trying to\nexport the spec information of a model to other API. [ 2 ] pry( #<RSpec::ExampleGroups::OrigenSpecsModule>)> @dut.find_specs.size => 8 Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/versioning/": {
    "title": "Versioning",
    "subtitle": "Models",
    "body": "Models Versioning Adding a version attribute is strongly encouraged since this will be how bugs and\nfeatures will be tracked in the future. Since this is such a common attribute all Origen models already have a version attribute and if\nthis key is passed to a sub_block definition it will automatically be attached to the sub-block,\neven in the case where a custom class is used. When instantiating an SoC model we can supply a version and this should then cascade down\nthe hierarchy affecting what versions of the sub-modules get instantiated. Let’s say that two different versions of our Eagle device exist, and in turn each one instantiated\na different version of the NVM IP.\nWe can model that like this: # lib/soc/eagle_m352.rb module SOC class EAGLE_M352 include Origen :: TopLevel def initialize (options={}) case version when 0 sub_block :nvm , class_name : \" NVM_M682 \" , version : 3 when 1 sub_block :nvm , class_name : \" NVM_M682 \" , version : 5 else fail \" The BOM for version #{ version } has not been defined! \" end end end end Note that we define an error condition if our application attempts to instantiate a version that we\nhave not defined. We then cascade this information down the tree, so our NVM module should also instantiate it’s\ncomponents based on the required version: # lib/nvm/nvm_m682.rb module NVM class NVM_M682 include Origen :: Model def initialize (options={}) case version when 3 sub_block :analog , class_name : \" ANALOG_T921 \" , version : 11 sub_blocks :memory , class_name : \" MEMORY_128_B954 \" , instances : 4 , version : 12 sub_block :state_machine , class_name : \" CONTROL_D345 \" , version : 20 when 5 sub_block :analog , class_name : \" ANALOG_T921 \" , version : 12 sub_blocks :memory , class_name : \" MEMORY_128_B954 \" , instances : 4 , version : 12 sub_block :state_machine , class_name : \" CONTROL_D345 \" , version : 24 else fail \" The BOM for version #{ version } has not been defined! \" end end end end We can test this out in the console: $dut = SOC :: EAGLE_M352 .new( version : 0 ) $dut .nvm.state_machine.version # => 20 $dut = SOC :: EAGLE_M352 .new( version : 1 ) $dut .nvm.state_machine.version # => 24 Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/common/": {
    "title": "Common API",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator Common API All tester drivers support the common API described in this guide. By building your patterns\nusing this API your will be able to generate them for any ATE that is supported by Origen. Some tester drivers may expose additional methods to leverage some key features of\nthe given ATE which do not have direct equivalents on other systems. You may or may not\nchoose to use these in your application. If you do, then be aware that you are introducing\nsome logic which cannot be automatically translated to other ATEs. In that case you will have to implement\nthe alternative implementation for other platforms on the application side,\nsomething like this: if $tester .uflex? # An implementation that uses a method that only exists on the UltraFLEX driver, # this will make the test run more efficiently on that platform else # Conventional implementation using the common API for all other platforms end Of course some applications may only ever wish to target a specific ATE, in that case you\ncan freely pick from the common and ATE-specific APIs. This API is currently provided by the Origen Testers plugin . In addition\nto the primary methods discussed below, all tester drivers support the methods described in the following\nAPI docs: OrigenTesters::VectorGenerator OrigenTesters::Timing OrigenTesters::API API Methods Here are each of the main methods supported by the common API. Generating Cycles These are the basic methods for generating vectors. cycle(options = {}) Generate a tester cycle or cycles: $tester .cycle $tester .cycle repeat : 1000 As this is such a commonly used method, there are some convenience methods available, this is\nequivalent to the above example: 1 .cycle 1000 .cycles A very common pattern when working at this level is to setup some pin states and\nthen trigger a cycle: pin( :tdi ).drive( 1 ) $tester .cycle\npin( :tdi ).drive( 0 ) $tester .cycle All of the pin state methods support a bang ( ! ) variant which will automatically\ncall a single cycle after setting the pin state, this is equivalent to the above: pin( :tdi ).drive!( 1 )\npin( :tdi ).drive!( 0 ) wait(options = {}) Repeats the last vector for the specified about of time. The time can be specified in cycles\nor a time, multiple arguments will be added together: $tester .wait cycles : 1000 # Equivalent to $tester.cycle(repeat: 1000) $tester .wait time_in_us : 1000 # Wait for 1000us $tester .wait time_in_ms : 1 # Wait for 1ms $tester .wait time_in_ms : 1 , time_in_us : 1000 , cycles : 100 # Wait for 2ms + 100 cycles The wait method can also be called with additional arguments to generate a dynamic wait,\ni.e. a match loop.\nHere for example to wait for up to 2 seconds for the done pin to go high: $tester .wait match : true , time_in_s : 2 , pin : pin( :done ), state : :high The above API is somewhat verbose, a cleaner one is available by supplying a block to generate\nthe vectors which much pass for the match to resolve.\nThis is equivalent to the previous example: $tester .wait match : true , time_in_s : 2 do pin( :done ).assert!( 1 ) end This block form also allows much more complex match conditions to be described, here to wait\nfor either the fail pin to go high, OR the done pin to go high: $tester .wait match : true , time_in_s : 2 do |conditions, fail|\n conditions.add do pin( :done ).assert!( 1 ) end conditions.add do pin( :fail ).assert!( 1 ) end end To AND these conditions would simply be: $tester .wait match : true , time_in_s : 2 do pin( :done ).assert( 1 )\n pin( :fail ).assert( 1 ) 1 .cycle end ignore_fails(*pins) Ignore fails on the given pins for the duration of the given block, this\nhas the effect of temporarily setting the states of the given pins to\ndon’t care. # Temporarily ignore mis-compares on the fail and data pins $tester .ignore_fails(pin( :fail ), pins( :data )) do # Any vectors generated in here will force the state of the given pins to X end Data Capture store(*pins) Instruct the tester to capture the data on the given pins from the vector that was generated last,\nnote that it does not actually generate a new vector. Sometimes when generating vectors within a loop you may want to retrospectively capture\na previous vector, passing in an offset option will allow you to do this. Here are some examples: $tester .cycle # This is the vector that we want to capture $tester .store pin( :d0 ), pin( :d1 ) # Capture the data on the d0 and d1 pins $tester .cycle # This one gets stored $tester .cycle $tester .cycle $tester .store pin( :d0 ), pin( :d1 ), offset : -2 # Just realized I need to capture that earlier vector Note that this API is for engineers who are writing protocol drivers, most test IP would be\nwritten at a higher level, e.g. atd_result.data.store! # Capture the value of the ATD result bits to the tester store_next_cycle(*pins) Similar to the above, this API allows driver creators to indicate that the next vector,\nwherever that may be generated, should be captured: $tester .store_next_cycle pin( :d0 ), pin( :d1 ) # This is the vector that will be captured, in real life this could be done after returning # to a caller $tester .cycle capture_style Testers support different ways of capturing vector data. For all tester types the default\ncapture style is hram (history ram). For UltraFlex digcap is additionally supported. Change\nfrom the default like this: # change capture style # if the digcap isn't support for the current tester, default behavior (hram) is used tester.capture_style = :digcap # change back to hram capture style tester.capture_style = :hram # temporarily change the capture style for this cycle tester.store_next_cycle pin( :d0 ), capture_style : :digcap configure capture memory Origen will create any instrument definitions required when capture memory is used. However,\nit may be desirable to alter the configuration settings. Here is an example of how to do this: # configure TDO as a 16-bit instrument (default size is the number of pins - 1 in this case) tester.capture_memory :digcap do |mem|\n mem.pin :tdo , size : 16 end Data Source overlay Testers support different ways of modifying vector data during run time. This practice is referred to\nhere as “overlay”. Overlay is requested through an optional argument to cycle: # setup overlay parameters overlay_options = {} # Required - what pin(s) are being overlayed? overlay_options[ :pins ] = dut.pin( :tdi ) # Required - what is the overlay string? This will become a label or subroutine name overlay_options[ :overlay_str ] = ovl_reg[i].overlay_str\n\ntester.cycle overlay : overlay_options # Generate another overlay cycle, holding the same data as the previous cycle overlay_options[ :change_data ] = false tester.cycle overlay : overlay_options # Now a new piece of data needs to be sent overlay_options[ :change_data ] = true tester.cycle overlay : overlay_options overlay_style The default overlay style is subroutine (vectors that will be modified are replaced\nby a call to a subroutine). Change from the default like this: # if requested sytle is not available for the current tester it will default to :subroutine tester.overlay_style = :digsrc tester.overlay_style = :subroutine tester.overlay_style = :label tester.overlay_style = :handshake # change the overlay style for this cycle only by adding :overlay_style to the overlay_options overlay_options[ :overlay_style ] = :label tester.cycle overlay : overlay_options Not all overlay styles are supported on all testers and if the requested style is not supported a warning\nwill be logged and it will fall back to the default style (:subroutine). Here is a brief summary of what each type does: digsrc The vectors to be modified are updated with the data value held in a tester memory. subroutine The vectors to be modified are removed from the pattern and replaced by a call to a another (subroutine) pattern. label A label is inserted into the pattern immediately before the vectors to be modified. handshake The vectors to be modified are removed from the pattern and replaced by a handshake with the tester. configure source memory Origen will create any necessary instruments statements. Add configuration information to source memory\nlike this: tester.source_memory do |mem|\n mem.pin :tdi , size : 32 , format : :binary , data_type : :long end Subroutines start_subroutine(name), end_subroutine Use these methods to write a pattern subroutine: $tester .start_subroutine \" wait_for_done \" $tester .wait match : true , time_in_s : 2 do pin( :done ).assert!( 1 ) end $tester .end_subroutine call_subroutine(name, options = {}) Call a pattern subroutine, an offset can be given to retrospectively jump to a subroutine\nfrom a previous vector: $tester .call_subroutine \" wait_for_done \" 1 .cycle 1 .cycle # A branch will also be made after completing this vector 1 .cycle 1 .cycle $tester .call_subroutine \" wait_for_done \" , offset : -2 Loops and Branching label(name) Inject an arbitrary label into the pattern: $tester .label \" on_failed \" branch_to(label) Branch to a label: $tester .branch_to \" on_failed \" loop_vectors(name, number_of_loops) Execute the vectors generated within the given block n times: $tester .loop_vectors( \" my_loop \" , 3 ) do # Do this 3 times... $tester .cycle end Miscellaneous freq_count(pin) Setup to measure the frequency on the given pin: $tester .freq_count pin( :clk_out ) microcode(code, options = {}) This can be used to inject arbitrary microcode into the pattern, which of course is\ninherently coupling your logic to a specific test platform - so use sparingly! An offset can be given to apply the microcode to previously generated vectors. $tester .microcode ' set_cpu (cpuC) ' 1 .cycle 1 .cycle # cpuB will be set here 1 .cycle 1 .cycle $tester .microcode ' set_cpu (cpuB) ' , offset : -2 Free-Running Clock on Existing Pin Set up a pin to be a free-running clock with the vector generation (with respect to toggling\nthe pin at the appropriate intervals) automatically taken care of. See Pin Clock Functionality for details on the API. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/creating/": {
    "title": "Creating Patterns",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator Creating Patterns Patterns are generated by regular Ruby files that should live within the pattern directory - a sub-directory within there is fine and is in fact encouraged to help\nkeep things organized as the number of patterns increases.\nHowever keep in mind that each pattern should be uniquely named - i.e. no other files of the\nsame name should live in\nany of the sub-directories of pattern . Each pattern file should have the following structure: Pattern .create do # Pattern specific content goes here end Startup and Shutdown Sequences Startup and shutdown sequences will generally be the same for all patterns and these should\nbe implemented by using the callbacks that support pattern generation . Any options supplied to Pattern.create will be passed into the startup and shutdown methods when they are called, thereby providing a mechanism for per-pattern\ncustomization of the startup/shutdown sequences. Here is an example of an SoC controller with some startup and shutdown callbacks implemented: class MyDeviceController include Origen :: Controller def startup (options)\n options = { mode : :functional_test ,\n }.merge(options) if options[ :mode ] == :functional_test enter_functional_test_mode elsif options[ :mode ] == :bist enter_bist_test_mode else raise \" Unknown mode requested - #{ options[ :mode ] } \" end end def shutdown (options)\n options = { reset : true ,\n }.merge(options)\n reset_device if options[ :reset ] end end So by default this pattern will enter functional test mode at the start and reset the device at the end: Pattern .create do # Pattern specific content goes here end This one will enter BIST mode instead at the start: Pattern .create( mode : :bist ) do # Pattern specific content goes here end and this one would exit without resetting the device: Pattern .create( mode : :bist , reset : false ) do # Pattern specific content goes here end Note - The top-level is guaranteed to be called first and last for the startup and shutdown\n callbacks respectively. However the calling order of lower level startup/shutdown listeners is undefined, if\n you have multiple and care about the order you should designate one as the master which will be called by Origen, it\n should then co-ordinate calling any additional startup/shutdown methods as required. The Golden Rules for Building Maintainable Patterns Origen provides a framework in which you can build very complex patterns that remain\neasy to maintain, but as with any tool it is also possible to use it to create something\nwith which to hang yourself! In order to avoid going down a path that will lead to an unmaintainable mess, it is\nstrongly recommended that the following rules are observed: Patterns should not talk to the current tester object directly Patterns should not attempt to control pin states Patterns should not attempt to access registers directly Probably the most tempting one to break is the last one, however\ngenerally manipulating register states outside of the owning model is a sign of poor\napplication design and breaking the encapsulation that should be provided by a model\nrepresenting a silicon module.\nInstead the model’s controller should provide an external interface which would remain constant even if the\ninternal operation of a given operation changes significantly from one silicon revision to the next.\nSee the Controller guides for more. If the above rules are followed pattern source files should typically be very small and should\ngenerally only call a handful of methods on the target object(s), here are a few examples: # Pattern to measure the output of the Vreg module Pattern .create do $dut .vreg.measure end # Pattern to measure the output of the Vreg module for a specific setting Pattern .create do $dut .vreg.measure( setting : 12 ) end # Pattern to program a checkerboard and then read it Pattern .create do $dut .nvm.program( pattern : :ckbd ) $dut .nvm.read( pattern : :ckbd ) end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/custom/": {
    "title": "Custom Testers",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator Custom Testers Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/documenting/": {
    "title": "Documenting Patterns",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator Documenting Patterns Origen encourages an agile approach to documentation and pattern generation is\nno exception.\nTools are provided to create test patterns that are self-documenting and by taking\na little care you can produce very detailed (and of course 100% accurate) documentation\nof your test patterns for free. The pattern generation command has the following switches: origen g bistcom # Generate a regular pattern\norigen g bistcom --doc # Output documentation of that pattern to the terminal\norigen g bistcom --html # Generate pre-formatted HTML documentation for inclusion in a web page The following methods are available to control the documentation output from the pattern\ngenerator… Debug Documentation Comments that may help with debug of patterns on the tester can be injected into\nthe pattern via the cc method, as with all methods related to\npattern documentation this is globally available. cc \" Entering test mode now \" test.mode.write!( RAMBIST_MODE )\nreset! The method argument is a regular string and dynamic segments can be embedded and\nformatted using any regular Ruby. delay_cycles = 100 cc \" Wait for #{ delay_cycles } cycles for the mode to latch \" address = 0x12 cc \" Set the target address to: 0x%04X \" % address This will produce pattern output that looks like this: // Wait for 100 cycles for the mode to latch\n// Set the target address to 0x0012 c1 is an alias for cc . These low level comments will appear in the pattern but they will not be included\nwhen a document of the pattern is generated. A c2 method is available to elevate the importance of a subset of\nthese low level comments\nsuch that they will be included in generated documentation. cc \" You won't see me in the docs \" c1 \" Or me \" c2 \" But you will see me! \" Documenting Major Steps Major steps in the pattern can be highlighted using the ss method. ss \" Enter RAM BIST mode \" # A block form is also available ss do vdd_core = 1.7 cc \" Enter RAM BIST mode with the following options: \" cc \" Vdd core - #{ vdd_core } v \" end This will produce the following output in the pattern: // #######################################################################\n// # Enter RAM BIST mode\n// #######################################################################\n\n// #######################################################################\n// # Enter RAM BIST mode with the following options:\n// # Vdd core - 1.7v\n// ####################################################################### Any comments defined in this way are considered more important than the regular cc comments and they will be automatically included in the\ngenerated documentation. Documenting Structure When presenting documentation it is useful to know something about the structure\nof the pattern, this allows vectors to be grouped into sections like ‘startup’, \n‘shutdown’, etc. Such structure can be described using the pp method: pp \" Startup \" do $dut .enter_ram_bist_mode $dut .ram.configure_for_test end def enter_ram_bist_mode pp \" Enter RAM BIST mode \" do # Mode entry code here... end end This would produce comments in the pattern that look like this: // #######################################################################\n// # Startup\n// #######################################################################\n\n// #######################################################################\n// # Enter RAM BIST mode\n// ####################################################################### However this difference vs. the ss method is that information about\nthe structure has been provided - it can be determined that the enter RAM bist\nsection is a sub-section of the wider startup sequence. This comes into play when the pattern documentation is generated as HTML,\nnow we will see something like this (click to expand): Startup Enter RAM BIST mode # Some comments generated by the RAM BIST entry sequence Adding Annotations Sometimes it will be helpful to add some annotations to describe what sections\nof the pattern are doing, this can be done via the annotate method. Any annotations will not be output in the actual pattern but will be included\nin generated documentation. Here is the above example with some annotations added: pp \" Startup \" do annotate \" Perform startup operations that are common to all patterns. \" $dut .enter_ram_bist_mode $dut .ram.configure_for_test end def enter_ram_bist_mode pp \" Enter RAM BIST mode \" do annotate <<-END This is an example of a multi-line annotation. Anything you write here\n will be parsed as markdown, so you can do things like:\n\n * Create bullet\n * Lists\n\n ~~~ruby\n # Embed some code examples\n $dut.enter_ram_bist_mode\n ~~~\n\n Or create [links](https://origen.freescale.net) END # Mode entry code here... end end This would produce the following snippet of documentation: Startup Perform startup operations that are common to all patterns. Enter RAM BIST mode This is an example of a multi-line annotation. Anything you write here\nwill be parsed as markdown, so you can do things like: Create bullet Lists # Embed some code examples $dut .enter_ram_bist_mode Or create links # Some comments generated by the RAM BIST entry sequence Summarizing Long Sections Sometimes it is not necessary to list out every comment or operation when documenting \na pattern. For example if the pattern downloads some functional code to be executing\non the chip it is not really necessary to include the entire code download in the\npattern document. For these scenarios a snip method is available which will output the\ngiven number of documentation lines and then enter a message to indicate that\nthe remainder of the output has been snipped for efficiency. Here is an example of how to use it, here the comments generated by the contained\nsection will be limited to 10 lines: snip 10 do # Download some verbose LRE code here end Pattern Headers When you generate a pattern, you’ll notice the top section contains some useful information, such as the user that generated the pattern, a\ntimestamp, the current environment, version of the application, the gems used, etc. This section is called the pattern header and may look something\nlike this: // ***************************************************************************\n// GENERATED:\n// Time: 24-Jun-2018 10:06AM\n// By: coreyeng\n// Mode: debug\n// Command: origen g iterator_postfix_test_x_bx -t debug.rb\n// ***************************************************************************\n// ENVIRONMENT:\n// Application\n// Source: git@github.com:Origen-SDK/origen.git\n// Version: 0.33.1\n// Branch: fixes(c4e8e1d0db0) (+local edits)\n// Origen\n// Source: https://github.com/Origen-SDK/origen\n// Version: 0.33.1\n// Plugins\n// atp: 1.1.0\n// origen_core_support: 0.2.3\n// origen_debuggers: 0.6.0\n// origen_doc_helpers: 0.5.2\n// origen_testers: 0.16.1\n// origen_updater: 0.7.0\n// *************************************************************************** The pattern header can also serve as place for the application, current plugin, or other shared plugins, to add specific comments that relate to\nhow that pattern was generated or how it should be used. Three configuration attributes exist that will inject additional comments into the pattern header: shared_pattern_header , application_pattern_header ,\nand current_plugin_pattern_header . These configuration attributes should be blocks that accept an options hash and return either a String , Array of Strings , or another block . Strings and Arrays will have the formatting handled\nfor you, but blocks can handle the formatting themselves and can provide custom header comment formatting. Assume we have two plugins, plugin1 and plugin2 that are each needed to generate a pattern located in the\napplication my_app . With no plugin set and with the configuration attributes set as follows: # plugin1/config/application.rb config.shared_pattern_header do \" Hi from shared #{ Origen .app!.name } ! \" end config.current_plugin_pattern_header do \" Hi from current plugin: #{ Origen .app!.name } ! \" end # plugin2/config/application.rb config.shared_pattern_header do \" Hi from shared #{ Origen .app!.name } ! \" end config.current_plugin_pattern_header do \" Hi from current plugin: #{ Origen .app!.name } ! \" end # my_app/config/application.rb config.shared_pattern_header do \" Hi from application #{ Origen .app!.name } ! \" end generating a pattern, will yield the following appended to the pattern header: // ***************************************************************************\n// Header Comments From Shared Plugins:\n// Header Comments From Shared Plugin: plugin1:\n// Hi from shared plugin1!\n// Header Comments From Shared Plugin: plugin2:\n// Hi from shared plugin2!\n// ***************************************************************************\n// Header Comments From Application: my_app:\n// Hi from application my_app!\n// *************************************************************************** You’ll notice here that there’s no current_plugin_pattern_header printed. This will be printed when\nthe current plugin is set to a plugin that has this configuration attribute. Setting the current plugin to plugin1 , you’ll now get both shared headers, the current plugin’s header, and the application header: // ***************************************************************************\n// Header Comments From Shared Plugins:\n// Header Comments From Shared Plugin: plugin1:\n// Hi from shared plugin1!\n// Header Comments From Shared Plugin: plugin2:\n// Hi from shared plugin2!\n// ***************************************************************************\n// Header Comments From The Current Plugin: plugin1:\n// Hi from current plugin plugin1!\n// ***************************************************************************\n// Header Comments From Application: my_app:\n// Hi from application my_app!\n// *************************************************************************** As previously said, you can provide either a block, proc, or lambda (anything that responds to call will work) and use cc, ss, c2 , etc. to handle arbitrary headers or formatting. For example, changing shared_pattern_header in plugin2 : # plugin2/config/application.rb config.shared_pattern_header do proc do c2 \" Hi from block in #{ Origen .app!.name } \" end end Will show the following in the pattern header: // ***************************************************************************\n// Header Comments From Shared Plugins:\n// Header Comments From Shared Plugin: plugin1:\n// Hi from shared plugin1!\n// Header Comments From Shared Plugin: plugin2:\n// Hi from block in plugin2!\n// ***************************************************************************\n// Header Comments From The Current Plugin: plugin1:\n// Hi from current plugin plugin1!\n// ***************************************************************************\n// Header Comments From Application: my_app:\n// Hi from application my_app!\n// *************************************************************************** Info: Although the guides here show an option hash , there are currently no options actually being passed in, i.e., its just\n an empty hash. This is only because this is a new feature, and by using an options hash here, future versions of Origen will be able to add any options that should\n go to the pattern header without affecting the method prototype. Deprecated: You may see config.pattern_header in some legacy applications. config.pattern_header is limited to only the\n current plugin and must handle formatting itself. This is now deprecated but is left in for legacy purposes. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/introduction/": {
    "title": "Introduction",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator Introduction Origen was initially conceived to be a pattern generator and as you would\nexpect it provides\npowerful APIs to generate tester patterns from your device models.\nThese APIs endeavour to abstract as much of the underlying ATE API as possible\nso that quite often all that is required to switch ATE platforms is to change\nthe tester model instantiated by the environment. With Origen, an application can also easily create custom tester\ndrivers which (for example) can be used to generate patterns in a format that\ncan be run on\nthe bench (as a J-Link command file for example) or in a functional\nsimulation - basically generating your pattern as a Verilog stimulus file. Origen is a simulation-less pattern generation tool and it is therefore very\nquick and lightweight compared to more traditional simulation-based pattern generation\nworkflows.\nWhen combined with the growing number of quality Origen plugins that are available to provide common hardware (e.g. JTAG) and protocol drivers\n(e.g. ARM Debug, Nexus), the speed of pattern development that can be\nachieved with Origen is unrivaled. With a bit of practice you can literally go from\nnothing to a working pattern for a new application within 10 minutes. Use Simulations for What They Are Good At Simulations still have their place, after all they are the only way to get pre-silicon\nfeedback on whether a given pattern will actually work or not.\nAn Origen-based workflow can still make heavy use of simulations for pre-silicon\nvalidation of test IP, however the downsides of requiring a simulation to actually\ngenerate a pattern (workflow complexity, slow generation times) are removed. This leads to much quicker turn around of pattern changes, which means that they can be regenerated\nin real time while debugging on the tester. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/j750/": {
    "title": "J750 API",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator J750 API This page will be used to document any J750-only APIs related to pattern generation,\nhowever the goal is to have as few of these as possible so that Origen pattern source code can re-target\nautomatically to any supported platform. There are no significant APIs in this category currently, therefore refer to the Common Pattern API which can fully target the J750. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/name/": {
    "title": "Generating by Name",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator Generating by Name In a large application the number of pattern source files can grow very large, for example in the\nflagship Origen application we grew to having more than 1500 pattern source files \nat one time!\nIn such a case even if you follow the golden rules for building maintainable patterns the fact that there are so many of them becomes a maintenance concern by itself and\nworries start to creep in about whether all of the patterns really implement a given operation\nin exactly the same way. Even if you don’t have so many patterns it can still become tedious to have to manually\ncreate the pattern every time a new test is added or modified, wouldn’t it be nice if\nthe pattern just created itself?! With Origen this is possible as long as your patterns lend themselves to being fully described\nby a naming convention. In short if it is possible to uniquely describe your pattern behavior\nwith a name then it is possible to synthesize that pattern from that name - this is goal of\nsourceless pattern generation with Origen. This feature is particularly powerful when combined with the Origen program generator , since it means that\nyour test program flow file becomes the only place where you define a test and the program\ngenerator will output a list of required pattern names. This can then be passed to the pattern\ngenerator which can synthesize all of the patterns without needing to create any pattern\nsources at all.\nOnce you have invested some time in building a test program interface and sourceless\npattern capability you can get to the point where to create a new test all you need to do\nis add a single line to the test flow and you are done! That level of automation and\nefficiency is simply not possible from any other test engineering framework. Enabling Name-Based Generation This feature is enabled via the before_pattern_lookup callback which will be called immediately\nbefore Origen looks for a pattern source for the given pattern generation request.\nIf this method returns false then Origen will cease processing that pattern and will\nassume that the application has dealt with the request. If the method returns\nthe requested pattern name then the regular pattern lookup and generation flow\nwill proceed as normal. It is recommended that you create a dedicated class called a pattern dispatcher within\nyour application which will handle deciding whether or not a pattern request\ncan be synthesized without a source file and then if so handle the synthesis and\ngeneration. Add these lines to your application.rb file to engage a pattern dispatcher\n(where MyApp is your application’s namespace): # config/application.rb def before_pattern_lookup (requested_pattern) MyApp :: PatternDispatcher .new.dispatch_or_return(requested_pattern) end Then create an initial pattern dispatcher shell like this: # lib/my_app/pattern_dispatcher.rb module MyApp class PatternDispatcher def dispatch_or_return (requested_pattern)\n requested_pattern end end end This initial dispatcher simply returns the requested pattern name, therefore Origen will\nbehave as normal and look for a source file for every pattern request. Even if you adopt sourceless pattern generation for your application it is likely that\nyou will still want to support conventional generation as well - having the ability\nto quickly hack together a engineering pattern at short notice is something that is\nmost easily achieved by making a dedicated pattern source file. So the first question is what should be the default behavior - sourceless or lookup? If sourceless is the default then you can implement a convention where if a pattern\nname contains ‘custom’ then a source file will be expected. If lookup is the default\nthen you could have the opposite convention where ‘nosrc’ in the pattern name means\nthat it should be generated without a source. Let’s go with sourceless being the default, here is how to modify the dispatch_or_return method to do that: def dispatch_or_return (requested_pattern) # If the pattern name contains 'custom' just return the name to have Origen lookup a source file for it if requested_pattern =~ / custom / requested_pattern else generate(requested_pattern) false # Return false to Origen to prevent std pattern dispatch end end def generate (requested_pattern) # Logic to generate the pattern to be added here end Now you can see the influence of the pattern dispatcher for the first time, any requests\ncontaining ‘custom’ will be processed as normal and any requests without this will\ndo nothing. How to Generate a Pattern A pattern can be generated from within the dispatcher in much the same way as it is\ngenerated within a regular pattern source file. Here our generate method will now produce an empty pattern: def generate (requested_pattern) Pattern .create( name : requested_pattern) do # Logic to generate the pattern to be added here end end Within the Pattern.create block you can call the exact same methods\nthat you would use in a regular pattern source, the difference of course is that\nhere we want to dynamically create them based on the name rather than hard-coding\nthem for a specific pattern. By going this route you also have to currently pick up a bit more responsibility\nfor pre-processing the requested pattern name. For example via the regular\ndispatch mechanism Origen will clean up the name to remove things like a path,\nfile extension, and pre and post-fixes that may or may not be present. In other\nwords Origen allows you to very flexible over what name you request, for example\nthese are equivalent: origen g bistcom\norigen g output/p2/nvm_bistcom_debug.atp In due course the internal Origen methods may be exposed via an API, but for now\nyour pattern dispatcher will have to deal with it (if you want to continue to\nhave this flexibility). Here is an example method that you can use for this: def generate (requested_pattern)\n requested_pattern = clean_pattern_name(requested_pattern) Pattern .create( name : requested_pattern) do # Logic to generate the pattern to be added here end end def clean_pattern_name (name)\n name = Pathname .new(name).basename.to_s # Strip path name.sub!( / \\. .* / , \" \" ) # Strip any and all extensions name.sub!( / ^nvm_ / , \" \" ) # Strip prefix, this will unique to your app, here 'nvm_' is removed name.sub!( / _debug$ / , \" \" ) # Strip postfix, again unique to your app, here '_debug' occurring at the end is removed name end Now you should be able to create (albeit empty) patterns via your dispatcher in the\nsame way as via the regular generator. Renaming Your Patterns to Make Parsing Easier To generate patterns by name you obviously need to have a comprehensive naming convention\nfrom which the behavior of each pattern can be fully described, you may even have\nthis already in place. However what is easy for a human to parse from a naming convention is not necessarily\neasy for a computer.\nFor example your patterns may have the general format: <parameter set>_<operation>_<identifier>_<block> Here are a couple of examples: prb_pgm_ckbd_b0 # Program a checkerboard to block 0, using probe parameters\nft_pgm_ckbd_b0 # Program a checkerboard to block 0, using FT parameters That’s fine, but what if these are allowed: pgm_ckbd_b0 # Program a checkerboard to block 0, using default parameters\npgm_ckbd_20us_b0 # Program a checkerboard to block 0, using default parameters + 20us programming time Again easy enough to understand, but we have just introduced somethings that will be\ndifficult to interpret by our pattern dispatcher. Firstly how do we know if ‘pgm’\nis a reference to an operation or a parameter set? One initial way to deal with it is to say that unspecified defaults are not allowed,\nbut that would quickly get out of hand as it would mean that every pattern would need\nto declare every variable which is not realistic. So we need a way to unambiguously say\nfrom the pattern name what each field represents. Similarly in the 2nd example we have further qualified the program operation with ‘20us’,\nbut again this is going to add a lot of complexity to our parser - what does that field\nreally represent? Is it program time, settling time, something else? Once again attaching\nsomething to the field name is going to really help us out when it comes to parsing and\ngenerating the pattern. So how can we re-write these examples to make our lives easier. Well one of the existing\nfields already has a good example for us. In the patterns above we have ‘b0’ which has\nunwittingly created the convention that a block reference within a pattern will consist\nof ‘b’ followed by a number. This is exactly the kind of thing that we can deal with easily. So extending that convention to prefix each field with a short mnemonic describing what it\nrefers to we end up with: paraprb_oppgm_patckbd_b0 # Program a checkerboard to block 0, using probe parameters\nparaft_oppgm_patckbd_b0 # Program a checkerboard to block 0, using FT parameters\noppgm_patckbd_b0 # Program a checkerboard to block 0, using default parameters\noppgm_patckbd_tprog20_b0 # Program a checkerboard to block 0, using default parameters + 20us programming time So we have paid a penalty here with a pattern name that is a bit more verbose than it really\nneeds to be, but it is a small price to pay for being able to drop pattern sources\ncompletely and to end up with a relatively simple pattern dispatcher. Parsing the Pattern Name To create an automated pattern dispatcher you are going to have to get familiar with\nregular expressions (regexs). Providing a tutorial on this is beyond the scope of this guide, but\na Google search for ‘regular expression tutorial’ should yield many resources to learn\nfrom. The following website is highly recommended to keep close by while developing your\ndispatcher - www.rubular.com . Aside from having a quick reference\nguide to the Ruby regex syntax it has a live panel which you can paste in your pattern name\nand then experiment with the regex to ensure the correct thing is matched.\nBest of all you can even save a given regex setup and\npaste the link into into your code comments for future reference. The parsing methods you will need to implement are very much dependent on your application and\nnaming convention, however a good way to get started is to\ndefine a method to handle each field. This breaks down the parsing into manageable chunks\nand also gives you a convenient place to set defaults.\nHere are some examples\n(here assuming that the requested pattern\nhas been assigned to an instance variable by upstream code): # An example of a required field def operation if @requested_pattern =~ / (^|_)op( \\w +?)(_|$) / $2 else raise \" No operation was contained in pattern: #{ @requested_pattern } \" end end # An example of an optional field with a default def parameter_set if @requested_pattern =~ / (^|_)para( \\w +?)(_|$) / $2 else \" default \" # Use the 'default' parameter set if not specified end end # An example of an optional field that returns nil if not present, a default # may or may not be assigned later within the patgen logic def block if @requested_pattern =~ / (^|_)b( \\w +?)(_|$) / $2 end end No doubt the regex code may look a bit daunting at first and unfortunately regexs are\nunusual in that they tend to be easier to write than they are to read!\nHowever we have basically used the same regex in all of the above examples and most likely\nyou could parse your entire pattern name like that. Here is a walkthrough of how it works: string =~ // This is basic format of a regex, you can read this as\n \"does some section of the string match the rules inside //\". /(^|_)para(\\w+?)(_|$)/ This means the start of the string ( ^ ) or an underscore... /(^|_)para(\\w+?)(_|$)/ ...followed by the op code that we are trying to match. /(^|_)para(\\w+?)(_|$)/ Then we have the section that we want to capture. \\w means a\n word character, that is a letter, number or unfortunately an underscore.\n The + means one or more of the previous characters. Since the \\w rule includes underscores by default this will match as many\n occurences as possible, so it would continue matching through the next underscore\n and into the next field, this is called a 'greedy' match. To prevent this we\n add the ? which tells it to match as little as possible, sometimes\n called a 'lazy' match.\n This whole section is surrounded in parenthesis which means 'capture the values\n that correspond to this section'. /(^|_)para(\\w+?)(_|$)/ Finally stop at the end of the string ( $ ) or an underscore. Our regex contains 3 sets of parenthesis, the part of the string that matched this\nsection is available at the end via the variables $1 , $2 and $3 . The field we want to capture is in position two and therefore\nour parse methods return this. Here are links to see each of these in action and for you to experiment with: operation parameter_set block As a final optimization note, with ruby parameters can be used in regexs in the same\nway they can be used as strings, so actually we could abstract the regex portion of the\ncode to a method like this: def extract (op_code) if @requested_pattern =~ / (^|_) #{ op_code } ( \\w +?)(_|$) / $2 end end def operation extract( \" op \" ) || raise( \" No operation was contained in pattern: #{ @requested_pattern } \" ) end def parameter_set extract( \" para \" ) || \" default \" end def block extract( \" b \" ) end Putting it All Together Now that we can generate a list of build options from the requested name we can start to\ngenerate the pattern. One of the first jobs of the dispatcher is to generate the list of options\nthat should be passed into Pattern.create , in our example let’s say that\nthe parameter set option is passed into our startup method via Pattern.create . We can now do this by simply calling our parameter_set method: def generate (requested_pattern)\n requested_pattern = clean_pattern_name(requested_pattern) Pattern .create( name : requested_pattern, parameter_set : parameter_set) do # Logic to generate the pattern to be added here end end What happens inside the pattern block very much depends on your application patgen API\nand if you are creating this from scratch\nsome thought should be given to designing it to lend itself to pattern synthesis.\nIn the flagship Origen application where this technique was first developed the original\nAPI was not at all designed with this in mind. This led to an extremely complex pattern\ndispatcher being required to handle all of the corner cases. To make life simpler for pattern synthesis it is recommended that the API is kept very simple\nwith only a few methods being made available and all customization of the operation being\ndone via an options hash. So for example a good API to handle our program checkerboard example might be: Pattern .create( params : :ft ) do $dut .nvm.pgm( pattern : :ckbd , tprog : 20 , block : 0 ) end Which could then be synthesized via the following method: def generate (requested_pattern)\n requested_pattern = clean_pattern_name(requested_pattern) Pattern .create( name : requested_pattern, parameter_set : parameter_set) do $dut .nvm.send operation, pattern : pattern, tprog : tprog, block : block end end Even simpler would be: Pattern .create( params : :ft ) do $dut .nvm.execute( operation : :pgm , pattern : :ckbd , tprog : 20 , block : block) end And the equivalent synthesizer method: def generate (requested_pattern)\n requested_pattern = clean_pattern_name(requested_pattern) Pattern .create( name : requested_pattern, parameter_set : parameter_set) do $dut .nvm.execute operation : operation, pattern : pattern, tprog : tprog, block : block end end A clear pattern is starting to emerge now that for every supported option we have\na matching method of the same name in our dispatcher, so we can optimize this a bit: OPTIONS = %w( operation pattern tprog block ) def generate (requested_pattern)\n requested_pattern = clean_pattern_name(requested_pattern)\n options = {} OPTIONS .each do |option|\n options[ :option ] = self .send(option) end Pattern .create( name : requested_pattern, parameter_set : parameter_set) do $dut .nvm.execute(options) end end Now if we want to add support for a new option we just add it to the OPTIONS array and create the corresponding parse method. We can probably go one better. As we have seen the parser methods are all very similar, do we really need them? Not really as long as we are willing to defer default setting and error checking to our\nmodels (where it probably makes more sense anyway). Here is a complete pattern dispatcher in around 30 lines of code, where if you want to\nadd support for another field in the future just add it to the OPTIONS definition that maps the option name to the pattern name op code: # lib/my_app/pattern_dispatcher.rb module MyApp class PatternDispatcher OPTIONS = { operation : \" op \" , pattern : \" pat \" , tprog : \" tprog \" , block : \" b \" ,\n } def generate (requested_pattern) @requested_pattern = clean_pattern_name(requested_pattern)\n options = {} OPTIONS .each do |option, op_code|\n options[ :option ] = extract(op_code) end Pattern .create( name : @requested_pattern , parameter_set : extract( \" para \" )) do $dut .nvm.execute(options) end end def extract (op_code) if @requested_pattern =~ / (^|_) #{ op_code } ( \\w +?)(_|$) / $2 end end def dispatch_or_return (requested_pattern) # If the pattern name contains 'custom' just return the name to have Origen lookup a source file for it if requested_pattern =~ / custom / requested_pattern else generate(requested_pattern) false # Return false to Origen to prevent std pattern dispatch end end def clean_pattern_name (name)\n name = Pathname .new(name).basename.to_s # Strip path name.sub!( / \\. .* / , \" \" ) # Strip any and all extensions name.sub!( / ^nvm_ / , \" \" ) # Strip prefix, this will unique to your app, here 'nvm_' is removed name.sub!( / _debug$ / , \" \" ) # Strip postfix, again unique to your app, here '_debug' occurring at the end is removed name end end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/pins/": {
    "title": "Pins",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator Pins The control of pin states represents the lowest level of Origen’s pattern generation\nAPI. Generally for most modern applications you should need to do this very rarely\nand mainly when creating mode entry and reset sequences for your\ndevice.\nFor most applications a plugin such as the JTAG driver should be used to\nabstract much of the lower level details about the values to be applied to a given\npin by a given test vector.\nIf your application uses a proprietary interface then it is recommended that you\ncreate a dedicated class to implement the interface\nprotocol and to deal with all of the manipulation of pin states. Basic Concept All of Origen’s vector-based tester models will support a cycle method\nwhich will drive or expect the current values held by all pins for one clock cycle.\nIn other words the cycle method takes a snapshot of the current pin states and then\napplies them to the DUT. Origen’s pin API provides models that represent a DUT’s pins and pin groups\nand methods with which to manipulate their states between tester cycles. See the Pins section of\nthe Models guide for details and examples\nof how to add and manipulate pin states within your model logic. Recommended Architecture Here are the key components of the recommended architecture: All pins and aliases are defined within the top-level models only, the top-level model is the only object\nthat owns pins in the entire application for a given target setup. Functions should be added to the pins to represent the different functionality available\non the pins depending on the mode. The availability of the required functions is a contract between a given sub-model\nand the top-level, i.e. the NVM models and test logic assume that all top-level models will\nprovide functions named nvm_fail and nvm_done . Each model only refers to the pins using the name/function that it understands. The test block/plugin that is primarily responsible for a given test pattern\ncan still control the pin order of the created pattern by using the pin_pattern_order method. The above approach has the benefits of encapsulating all pin definitions within the top-level model, so\nthat a device’s TE could implement the details straight from the top-level DFT guide for example, while the lower level\nmodules can talk to the pins/signals that they know about. Here is an example of how to implement this scheme in a top-level SoC model: class MySoC include Origen :: TopLevel def initialize (options)\n instantiate_pins(options) end def instantiate_pins (options) # Common pins required by all to support mode entry sequences add_pin :tclk , reset : :drive_lo add_pin :trst , reset : :drive_hi add_pin :extal add_pin :xtal , reset : :drive_lo add_pin :tms add_pin :tdo add_pin :tdi add_pin :resetb add_pins :data , size : 8 # Add NVM BIST mode functions pin( :extal ).add_function :nvm_clk pin( :data )[ 2 ].add_function :nvm_fail pin( :data )[ 3 ].add_function :nvm_done pin( :data )[ 4 ].add_function :nvm_invoke # Add additional function groups here... end end Controlling the Pattern Pin Order As a test engineer for a specific test module you may want more importance to be given to some pins\nthan others, or to otherwise order them to make them most readable for debugging the target module. This can be achieved by calling the pin_pattern_order method: class NVM include Origen :: Model def initialize # Unspecified pins will appear in arbitrary order at the end pin_pattern_order :nvm_clk , :nvm_invoke , :nvm_done , :nvm_fail end end Aside from specifying the order of the pins this also specifies what the name should be, i.e. if a given\npin/pin group has multiple aliases then the one used to refer to the pin in the pin_pattern_order is that one that will appear in the generated pattern. By default any unspecified pins will appear in arbitrary order at the end. To include only the pins\nspecified then append the :only option at the end: # Only include these pins in the output pattern and in this order pin_pattern_order :nvm_clk , :nvm_invoke , :nvm_done , :nvm_fail , only : true Alternatively specific pins or pin groups can be excluded from appearing in the output file via\nthe pin_pattern_exclude method: # Don't include these pins in the pattern pin_pattern_exclude :porte , :portf An error will be raised if the same pin appears in both pin_pattern_order and pin_pattern_exclude . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/registers/": {
    "title": "Registers",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator Registers The majority of patterns are concerned with reading and writing to registers to make the\nDUT do something and consequently \nmore than 90% of your time developing an Origen test application should be concerned with\nwriting code at the register level. All test transaction drivers such as the ARM Debug driver are expected to support the basic\nOrigen register API. This allows the test engineer to develop code at register level and\nindependently of the underlying test communication protocol which can be easily changed\nto something else as required. Basic Concept See the Registers section of\nthe Models guide for details and examples\nof how to add and manipulate register states within your model logic. Interaction with the registers should be limited to the model’s controller - no one else should reach into a model to manipulate its register state (this is not prevented\nbut recommended), and the controllers should instead expose interface methods for the outside\nworld to use. Internally such methods will work by manipulating registers in a sequence. The read! and write! methods when called on a register (or bit) will\nautomatically fire off a request for the register to be written using the following\nrules: If the model or controller that owns the register implements a write_register method\nthen call this with the target register passed in as the argument Otherwise if the object that owns the register implements an owner method,\nthen see if the object that this returns provides a suitable write_register method If not then if a currently instantiated model includes the Origen::TopLevel module then see if it (or its controller) has a write_register method available If the request has still not been fulfilled then raise an error Read works in the same way except that it looks for a method called read_register . What this all means is that within a controller you will build your\ntest logic from methods that look like this: def measure_vref (setting= nil ) if setting\n ss \" Measure the Vref voltage for setting #{ setting } \" vref.level.write(setting) else ss \" Measure the default Vref voltage \" end vref.test_enable.write!( 1 ) end # From a pattern call like this: Pattern .create do $dut .nvm.measure_vref( 5 ) end The actual mechanism for how the registers are written is abstracted away from the\ntest logic itself and therefore the test logic is generally independent from the communication\nprotocol. This is a very powerful concept that allows plugins to be created that provide \ntest sequences for a specific silicon module and these can then be re-used on DUTs that\nemploy completely different register access protocols. Recommended Architecture This is the recommended architecture for modern Origen applications that will lend itself\nto working well within a plugin-based environment. Define registers in the child models that own them and create test methods to manipulate them\nin the controller: class NVM include Origen :: Model def initialize reg :vref , 0x0003 , size : 16 do |reg|\n reg.bit 15 , :test_enable reg.bit 7 .. 0 , :level end end end class NVMController include Origen :: Controller def measure_vref (setting= nil ) if setting\n ss \" Measure the Vref voltage for setting #{ setting } \" vref.level.write(setting) else ss \" Measure the default Vref voltage \" end vref.test_enable.write!( 1 ) end end Defer how to actually write the register to the top-level SoC controller and normally this would\nbe done via one of the available protocol plugins.\nHere for example is an SoC which will write the register via the Nexus protocol : class MySoC include Origen :: TopLevel # Indicate to Origen that this model represents a top-level device object end class MySoCController include Origen :: Controller include Nexus # Process register reads using the Nexus protocol def read_register (reg, options={})\n nexus.read_register(reg, options) end # As above for write requests def write_register (reg, options={})\n nexus.write_register(reg, options) end end And that is all that is required, Origen takes care of the hook up and the behind the scenes\ncommunication to make it all work. Another target may then instantiate a different SoC model which could use a completely different\nprotocol like ARM Debug , in which case the NVM test module would\nstill work although the generated pattern would look completely different. Bit Level Access All registers support bit level updates, we have seen an example of this already: vref.test_enable.write!( 1 ) What this will do is update the value held by the given bits and then send the parent\nregister object to the write_register method for processing.\nAll other bits in the register will maintain the state that they had prior to this\noperation commencing. Since it is not generally possible to update only a subset of bits on a device the entire\nregister will still be updated on silicon.\nHowever in the case of performing a bit-level read things get a bit more interesting. The equivalent read operation will update the data values of the bits in the same way, but\nit will also set a flag on those bits marking that they have been requested for read. vref.test_enable.read!( 1 ) The protocol driver can then look out for this flag when generating the readout vectors\nand only enable a compare on the vectors that correspond to the bits marked for read.\nGenerally this takes a lot of the cognitive overhead out of writing patterns since you\ncan mentally disregard the state of all bits except the ones that you care about. All standard Origen protocol plugins are expected to support this feature. The same is true for store (meaning capture the value on the tester) or overlay operations: # Capture the value of the level bits vref.level.store! # Dynamically overlay the value written to the level bits vref.level.overlay( \" vref_setting \" )\nvref.write! Combining Multiple Bit Level Accesses Into A Single Transaction Multiple individual bits within a register can be accessed/manipulated within a single\ntransaction by making multiple bit-level calls to read (or write ), followed by a single\nregister-level read! (or write! ) operation: my_reg.my_bits_x.read( 1 )\nmy_reg.my_bits_z.read( 0b101 )\nmy_reg.read! Sometimes you will see application code that combines the final transaction request with the\nfinal bit-level operation, this will do the same thing as the above example: my_reg.my_bits_x.read( 1 )\nmy_reg.my_bits_z.read!( 0b101 ) If you prefer, an equivalent block form API is also available, this is equivalent to the above example: my_reg.read! do |reg|\n reg.my_bits_x.read( 1 )\n reg.my_bits_z.read( 0b101 ) end Writing a Driver Generally the code for an existing driver should be reviewed to see how to go about this,\nthe JTAG driver would be a good example to look at,\nbut here are some basic pointers on good driver design. All drivers should implement read and write register methods: def write_register (reg, options={}) end def read_register (reg, options={}) end The write methods are usually fairly simple, here is a basic example of how to do a parallel\nand a serial protocol write: # Writing on a parallel port, let's say we have a 16-bit register and the # data needs to be written on a pin group called data which is 8-bits def write_register (reg, options={})\n pin( :din ).drive( 1 ) # Let's say when this pin is high data is captured # Drive the data in MSB -> LSB order pins( :data ).drive!(reg[ 15 .. 8 ].data)\n pins( :data ).drive!(reg[ 7 .. 0 ].data)\n pin( :din ).drive( 0 ) # Turn off capture end # Writing on a serial port, same as above only this time the :data port is # only 1-bit wide def read_register (reg, options={})\n pin( :din ).drive( 1 ) # Let's say when this pin is high data is captured # Drive the data in MSB -> LSB order reg.shift_out_left do |bit|\n pin( :data ).drive!(bit.data) end pin( :din ).drive( 0 ) # Turn off capture end Read methods are usually a bit more involved to implement the bit-specific read and\ncapture operations.\nHere is a parallel and serial protocol example which supports bit-level read operations: # Reading on a parallel port, let's say we have a 16-bit register and the # data needs to be read on a pin group called data which is 8-bits def write_register (reg, options={})\n pin( :dout ).drive( 1 ) # Let's say when this pin is high data is presented # Compare the data in MSB 8 .times do |i|\n bit = reg.bit(i + 8 ) if bit.is_to_be_read?\n pins( :data )[i].assert(bit.data) else pins( :data )[i].dont_care end end $tester .cycle # Now the data in LSB 8 .times do |i|\n bit = reg.bit(i) if bit.is_to_be_read?\n pins( :data )[i].assert(bit.data) else pins( :data )[i].dont_care end end $tester .cycle\n\n pin( :dout ).drive( 0 ) # Turn off read out end # Reading on a serial port, same as above only this time the :data port is # only 1-bit wide def read_register (reg, options={})\n pin( :dout ).drive( 1 ) # Let's say when this pin is high data is presented # Drive the data in MSB -> LSB order reg.shift_out_left do |bit| if bit.is_to_be_read?\n pin( :data ).assert!(bit.data) else pin( :data ).dont_care! end end pin( :dout ).drive( 0 ) # Turn off read out end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/running/": {
    "title": "Running The PatGen",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator Running The PatGen The pattern generator is launched via the Origen generate command, see the command line\nhelp to get details of the most up to date options: origen generate -h As this is such a commonly used command it has a short cut alias: origen g -h The generator can be run on a single file: origen g pattern/ram/march.rb It can also be run without a path and by just supplying a name, Origen is also pretty flexible\nwith regards to file extensions and pre and post fixes and in most cases it should do a good\njob of finding the pattern that you want: origen g march It can also run on a whole directory: origen g pattern/ram Pattern list files can also be used, by convention these should be kept in the list directory\nand should have the extension .list : origen g list/production.list Here is an example of a list file: # List files can be commented like this\n# Simply list the name of the patterns that you would use on the command line\nmarch.rb\ndata_retention.rb\n# List files can also call other lists\nprobe.list By default the generated patterns will be put in output or whatever directory\nis returned by the config.output_directory attribute in application.rb . Submit to the LSF by appending -l and optionally interactively\nwait for completion: origen g list/production.list -l -w Regression Testing Every time Origen generates a pattern it will check to see if it has generated it before, and\nif so it will compare the current version to the previous version and alert if there is a\ndifference. This can be used to check for regressions when making changes that you don’t want\nto affect the output, or to verify that the change is what you intended in cases where you\nare intentionally modifying the output. The diff is a smart diff and will not care about any changes to comments, only about changes\nthat will affect the pattern’s operation. In the case of a difference being found Origen will automatically present you with the diff command\nto run if you want to view the change. To accept changes or to start tracking the differences in a pattern (or patterns) run the following command\nafter generating: origen save all Programmatically Launching the Generator If you start writing your own commands you may want\nto launch the generator from Ruby, do that as follows: Origen .app.runner.launch action : :generate , files : \" list/production.list \" This can be combined with Target Loops to run the\ngenerator for multiple targets. A generate job can also be posted to the LSF by supplying the same options that you would use\non the command line like this: Origen .lsf.submit_origen_job( \" g march \" ) Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/timing/": {
    "title": "Timing and Waiting",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator Timing and Waiting A common workflow is to have a tester timing file defined and managed outside of Origen, in\nwhich case the main concern within your Origen source code is simply to refer to required\ntimeset(s) by name. However, Origen does also support a more complex timing definition where waveforms\ncan be defined and mastered in Origen source code. That is discussed later on in the Complex Timing section. Simple Timing This guide gives an overview of some of the most common timing related\nmethods, but to get a complete overview of what is available consult\nthe OrigenTesters::Timing API . A timeset declaration is used to provide information to Origen about what\ntimeset to use for future test cycles and what period of time each\ncycle represents. Normally this would be initialized within the startup method before generating any\nvectors as shown below: class MySoCController include Origen :: Controller def startup (options) $tester .set_timeset( \" mode_entry \" , 40 ) end end The first argument is the name of the timeset, this should correspond to\nhow the timeset will be named within the test program, and the second argument\nis the cycle period in nano-seconds. This method also accepts a block in which case the contained vectors will generate\nwith the supplied timeset and subsequent vectors will return to the previous timeset\nautomatically. $tester .set_timeset( \" bist_50mhz \" , 20 ) do # Any cycles generated in here will use 20ns for the period end The arguments can also be supplied as a single array, or not at all. In the latter case\nthe existing timeset will simply be preserved. This is useful if you have timesets that\ncan be conditionally set based on the target. # Target 1 $dut .readout_timeset = [ \" readout \" , 120 ] # Target 2 $dut .readout_timeset = false # This code is compatible with both targets, in the first case the timeset will switch # over, in the second case the existing timeset will be preserved. $tester .set_timeset( $dut .readout_timeset) do # Generate readout vectors... end Creating a Timing Set Currently the creation of the timing set for a given test platform must be\ndone independently of Origen, however adding an Origen API for this is on the roadmap. Waiting All $tester models will support the following API to generate wait states\nin the test patterns. Wait for specific number of cycles: $tester .wait( cycles : 1000 ) Wait for a period of time: $tester .wait( time_in_us : 500 ) $tester .wait( time_in_ms : 10 ) A shorthand for the above cases is available: 500 .us! # Wait for 500us 10 .ms! # Wait for 10ms Multiple times specified in different units will be added together, this can be useful\nif the delay is based on a complex calculation: # Wait for 500us + 100 cycles $tester .wait( time_in_us : 500 , cycles : 100 ) Waiting for an Event All testers provide an API for generating match loops, these can be used to\nmake the pattern wait dynamically for a pin-based or even a register-based\nevent. To do this enable the :match option and supply a block, within the block\ngenerate the vectors that will test if the condition has been met.\nAny time options passed in will be applied as a timeout, i.e. the maximum time to\nwait for the required condition to resolve. Here are some examples: # Wait for up to 1 second for the done bit to be set $tester .wait( match : true , time_in_s : 1 ) do reg( :status_reg ).bit( :done ).read!( 1 ) end # Wait for up to 1 second for the done pin to be set $tester .wait( match : true , time_in_s : 1 ) do pin( :done ).assert!( 1 ) end Complex Timing Defining Timesets A wave object defines the waveform that should be applied to a pin, and each pin will\nhave two wave objects assigned to it - one for drive cycles and one for cycles where the\npin is being read/compared. A timeset object is used to collect the wave objects for all pins. Multiple timesets can\nbe defined and therefore the waveforms being applied to the pins can be changed by changing\nthe timeset.\nThe API to change the timeset is the same as that already discussed above: tester.set_timeset( ' func ' , 100 ) The period of the timeset can be referenced in the wave definitions to make the waveforms\nkeep the same shape with different period settings. Here is the most basic timeset definition, this will give all pins a default waveform which\ndrives for the whole period on drive cycles, and strobes at 50% of compare cycles: # Simple definition, all pins have default waves add_timeset :t1 Here is a more complex definition, which changes the default compare for all pins to be at\n25% of the period, and which adds a unique drive wave to the :tck pin to create a clock: # Complex definition, defines an alternative default compare wave and specific timing for :tck timeset :func do |t|\n t.compare_wave do |w|\n w.compare :data , at : \" period / 4 \" end t.drive_wave :tck do |w|\n w.drive :data , at : 0 w.drive 0 , at : 25 w.dont_care at : \" period - 10 \" # Just to show that dont_care can be used end end Pin groups can also be referenced in the timeset definition, here to add common drive timing\nto all pins in :gpio, and with a special compare waveform for :gpio5 only: # Another timeset to show the wave assignment to pin groups timeset :t2 do |t|\n t.compare_wave :gpio5 do |w|\n w.compare :data , at : 100 end t.drive_wave :gpio do |w|\n w.drive :data , at : 200 end end Note that the API currently only supports edge compares, i.e. window compares cannot be defined. Additional drive and compare waves can be defined for any pin by giving them a code which can\nbe used to select the given waveform in a pattern - i.e. the approach used by the \nV93K tester to select from multiple available waveforms. Here is an example with a single pulse waveform defined for a clk pin which will be applied\nwhen the pin is driven to 1 , and a double pulse waveform that will be applied when the pin\nis drive to T : timeset :func do |t|\n t.drive_wave :tck do |w|\n w.drive 1 , at : 0 w.drive 0 , at : 20 end t.drive_wave :tck , code : ' T ' do |w|\n w.drive 1 , at : 0 w.drive 0 , at : 10 w.drive 1 , at : 20 w.drive 0 , at : 30 end end Consuming Timeset Data The currently selected timeset can be retrieved via the following methods which are aliases: dut.timeset # => instance of Origen::Pins::Timing::Timeset dut.current_timeset Using the plural returns a hash containing all timesets, thereby allowing access to specific timesets\nregardless of the current selection: dut.timesets # => Hash dut.timesets[ :func ] # => instance of Origen::Pins::Timing::Timeset # This will also work: dut.timeset( :func ) Each timeset stores the waves in two arrays, one for drive waves and another for the compare waves: dut.timeset( :func ).drive_waves # => Array containing instances of Origen::Pins::Timing::Wave dut.timeset( :func ).compare_waves Each wave object has an events array, and the pins assigned to it can also be retrieved: drive_wave = dut.timeset( :func ).drive_waves.first\ncompare_wave = dut.timeset( :func ).compare_waves.first\n\ndrive_wave.events # => [[0, :data], [50, 0], [75, :x]] drive_wave.pins # => Array of Origen::Pins::Pin instances compare_wave.events # => [[\"period / 2\", :data]] The method evaluated_events can be used to get the events with the formulas evaluated based on the\ncurrent period: compare_wave.events # => [[\"period / 2\", :data]] compare_wave.evaluated_events # => [[50, :data]] The waves assigned to a given pin by the current timeset can also be accessed via the pin API: dut.pin( :tms ).compare_wave.events[ 0 ] # => [\"period / 2\", :data] The waveform associated with a particular code can be accessed as follows: # The wave for driving 0 and 1 is returned by default, these are all aliases: dut.pin( :clk ).drive_wave.events # => [[0, 1], [20, 0]] dut.pin( :clk ).drive_wave( 0 ).events # => [[0, 1], [20, 0]] dut.pin( :clk ).drive_wave( 1 ).events # => [[0, 1], [20, 0]] dut.pin( :clk ).drive_wave( ' T ' ).events # => [[0, 1], [10, 0], [20, 1], [30, 0]] Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/ultraflex/": {
    "title": "UltraFlex API",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator UltraFlex API This page will be used to document any UltraFLEX-only APIs related to pattern generation,\nhowever the goal is to have as few of these as possible so that Origen pattern source code can re-target\nautomatically to any supported platform. There are no significant APIs in this category currently, therefore refer to the Common Pattern API which can fully target the UltraFLEX. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/v93k/": {
    "title": "V93K API",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator V93K API All of the Common Pattern API can be used to target the V93K. This page is used to document any additional V93K-specific APIs related to pattern generation,\nhowever the goal is to have as few of these as possible so that Origen pattern source code can re-target\nautomatically to any supported platform. Driving Custom Waveforms The V93K has a very powerful waveform generator and it is common to use many more pin state codes than\nother platforms in order to select particular waveforms. Say for example that we have various waveforms defined to drive a clock pin, where a ‘1’ on the pin\nwill drive a single pulse and a code of ‘P’ will select a different waveform which will create 4 pulses\nper cycle. The ‘P’ code (or any other letter) can be driven very easily as shown below: # Example vectors pin( :clk ).drive!( 1 ) # 1 X XXXX 10100001 1 .cycle # 1 X XXXX 10100001 pin( :clk ).drive!( ' P ' ) # P X XXXX 10100001 1 .cycle # P X XXXX 10100001 pin( :clk ).drive!( 1 ) # 1 X XXXX 10100001 The above vectors would produce the following waveform per the earlier description of ‘P’: _______ _______ _ _ _ _ _ _ _ _ _______\nclk _______| |_______| |_| |_| |_| |_| |_| |_| |_| |_| |_______| | Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/plugins/app/": {
    "title": "Config & Origen.app",
    "subtitle": "Plugins",
    "body": "Plugins Config & Origen.app Every Origen application and plugin has an object that represents it, this is returned by Origen.app and is essentially an instance of the class defined in config/application.rb . When calling Origen.app within plugin code some thought has to be given to\nwhich application you mean, do you mean the plugin itself or the top-level application\nthat it is plugged into? To deal with this ambiguity the following API exists which works the same as Origen.root : Origen .app # Returns the current top-level app instance Origen .app! # Returns the app instance associated with the code making the # call, typically use this to get a plugin's app instance Origen .app( :doc_helpers ) # Returns the app instance for the given plugin name Am I the Current Application or Plugin? A common use case for examining the application instance is to see if a plugin is\nrunning standalone (in its own development workspace) or if it is running fully deployed as a plugin\nto a wider application. The following code can be used in this case: if Origen .app!.current? # The plugin is running standalone in its own workspace (I am the current application) else # The plugin is running as a component in a parent application end A further question can arise if the plugin is found to be running as a component in a\nparent application: ‘am I the current plugin?’ To test for this: if Origen .app!.current_plugin? # Do something special when I am the current plugin else # Sigh, just another run-of-the-mill plugin end Overriding the Application Config Some config options have the ability to be overridden by the current plugin,\ne.g. config.pattern_prefix will be set by the plugin that owns the pattern\nand not the top-level application. See ATTRS_THAT_CURRENT_PLUGIN_CAN_OVERRIDE in the Configuration API for a complete list of the config options that fall into this category. If the current plugin does not provide a value for a given config option then the value\ndefined by the top-level application will be used instead. Typically a rich plugin which provides patterns and similar IP to an application will\ncontain logic like this in its config/application.rb : # If this app is running standalone then it supports multiple devices and so in that # case namespace the output by device type. However if running as a plugin then it # will be in a single device app, in that case put everything in the 'atd' directory config.output_directory do if current? # If app is running standalone (i.e. not as a plugin) \" #{ Origen .root } /output/ #{ dut.class } \" else \" #{ Origen .root } /output/atd \" end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/plugins/creating/": {
    "title": "Creating a Plugin",
    "subtitle": "Plugins",
    "body": "Plugins Creating a Plugin Origen plugins are essentially Origen applications themselves.\nFollow the standard instructions to Create a New Application and choose one of the available plugin templates rather than an application template. Understanding How Plugins are Loaded For the purposes of this guide let’s say we are creating a plugin called ATDTest and this would have a top-level lib file called lib/atd_test.rb . When a plugin is run from its own workspace, we would call this running in standalone or development\nmode, then it is loaded like any other Origen application.\nThe first thing Origen does in this case is to load the plugin’s gem bundle, defined in its Gemfile ,\nand then boot the plugin by loading config/boot.rb . Normally such a file will look like this: # config/boot.rb require ' atd_test ' So by default this simply loads the plugin’s top-level file which in this example is lib/atd_test.rb . However when the plugin is loaded as part of a parent application, neither the plugin’s Gemfile or\nits config/boot.rb file will be loaded.\nInstead the parent application’s Gemfile will be loaded, and this will contain\na reference to our plugin. The tool that evaluates the Gemfile, called Bundler , will\ninspect our plugin’s gemspec file (in this example atd_test.gemspec ) and\nit will ensure that any dependencies listed there are met. Once the gem bundle has been created\nit will then load our plugin’s top-level file, lib/atd_test.rb . The take away from this is that the following rules should be observed when creating plugins: Load all of your plugin’s code from it’s top-level file ( lib/atd_test.rb ), if that requires\nall of the lib code you wish to share with your users then they will not need to do anything except\nadd your plugin to their Gemfile . The plugin’s config/boot.rb file should only be used for loading any code which is for testing\nonly or for otherwise running your plugin within its own workspace environment. The plugin’s Gemfile should not be used. This should contain a line that calls gemspec which tells Bundler to refer to the plugin’s gemspec file instead, e.g. atd_test.gemspec . This\nprevents you from having to maintain the plugin’s gem dependencies in two separate locations. The plugin’s gemspec should be used to declare all of its gem dependencies as shown below. Note that plugins\nmust never specify an absolute version of gems in its runtime dependencies. # atd_test.gemspec # Declare any dependencies that the plugin will need when it is running within a parent application. # Never specify an absolute version since that can easily conflict with other plugins if they did the # same. Instead specify a range, normally just a minimum version that you need. spec.add_runtime_dependency \" origen_jtag \" , \" >= 1.1.0 \" # Declare any dependencies that the plugin need when running in standalone/development mode only, a # very common example is the documentation helpers plugin. This is only required to build the plugins # web pages, but it is not required at runtime. # Note that absolute version numbers are allowed here since this does not apply outside of this plugin. spec.add_development_dependency \" origen_doc_helpers \" Sharing Models and Other Lib Code The plugin’s lib directory will be automatically added to the Ruby load path\nno special consideration is required to expose lib code to the parent application.\nIn our example the parent application will be able to load\nany of our code like this: require ' atd_test/atd_16b ' However as noted above the plugin’s top-level file, lib/atd_test.rb will be automatically\nloaded, therefore it is the usual convention to have this file require everything else so that the parent\napplication does not need to manually require anything. Sharing Other IP To share source files, templates and commands the plugin must define config.shared in\nits config/application.rb file, here is an example that will share everything: config.shared = { :patterns => \" pattern \" , :templates => \" templates \" , :programs => \" program \" , :command_launcher => \" config/shared_commands.rb \" } Access can be restricted by specifying a sub-directory, or by simply\nremoving the given resource: # Only share a subset of patterns (those that live within the pattern/shared directory, those # in pattern/development for example would not be available to the host application) config.shared = { :patterns => \" pattern/shared \" , # :templates => \"templates\", # :programs => \"program\", # :command_launcher => \"config/shared_commands.rb\" # :global_launcher => \"config/global_commands.rb\" } Sharing Templates The host application can reference a template from an added\nplugin by using the plugin’s name as a pointer to the\nshared template directory (the directory specified in the plugin’s config.shared[:templates] attribute),\nand then a relative path from there to the required template. For example the doc_helpers plugin contains a test flow layout template at templates/shared/test/_flow.md.erb , and an importing\napplication would reference this template via the path doc_helpers/test/_flow.md.erb . Sharing Pattern and Program Sources When test pattern and program directories are shared Origen will look within these for\nthe requests patterns/flows whenever the given plugin is designated as the\ncurrent plugin. See the Current Plugin for more detail on this. For example say our plugin is called atd_test and it provides a pattern\ncalled atd_ramp.rb , then\nit could be generated like this from the parent application workspace: origen pl atd_test\norigen g atd_ramp Alternatively you can override the current plugin at runtime like this, this is\nequivalent to the above: origen g atd_ramp --plugin atd_test Program generation source files work from exactly the same principles. Note that since there is currently no easy way to view a list of all patterns provided\nby a plugin, it is conventional for the plugin to provide custom commands to generate\na complete set of patterns, e.g. something like this: origen atd_test:prod_pats # Generate all production patterns from the ATD plugin\norigen atd_test:prod_prog # Generate the production test program from the ATD plugin Sharing Application Commands To share custom commands supply a path to a command definition/launcher file within the plugin\nas shown in the example above. This file works very similar to the way that custom commands are added to an application. Here is an example command launcher file from a real plugin, this adds a custom\ncommand, origen atd_test:j750 , to the host application and also extends the origen g command by adding an additional option to it. Note the use of Origen.root! and Origen.app! to refer to the plugin’s own root\nand application instance rather than that of the host application. Also note that the command has been called atd_test:j750 instead of just j750 , this is to ensure that there is no naming collision with commands\nthat could be added by other plugins.\nIn future Origen will automatically apply a plugin specific prefix to the commands like this,\nbut until then all plugin developers are expected to be good citizens and add this manually. # config/shared_commands.rb # The requested command is passed in here as @command case @command when \" atd_test:j750 \" require \" #{ Origen .root! } /lib/commands/j750 \" # Important to exit when a command has been fulfilled or else Origen core will try and execute it exit 0 # Add an additional option to the standard generate command, important to have no exit here when \" generate \" @application_options << [ \" --md5 \" , \" Apply an MD5 checksum to pattern names \" ] Origen .app!.md5 = true if ARGV .include?( \" --md5 \" ) # Always leave an else clause to allow control to fall back through to the Origen command handler. # You probably want to also add the command details to the help shown via 'origen -h', # you can do this bb adding the required text to @plugin_commands before handing control back to # Origen. else @plugin_commands << <<-EOT atd_test:j750 Generate the ATD test program for J750 EOT end Sharing Global Commands The above allows you to share commands when running from within an application instance. But what if\nwe want to share commands regardless of whether we are running in an application? In this way, Origen\ncan be even further utilized as a tool distribution platform and but allow all of our non-application\nspecific functionality to still be used. E.g., LSF manager, authentication, revision control APIs, etc. Adding shared global commands is very similiar to adding shared application commands, as shown above. The global_launcher option in the config.shared definition points to a file containing\nthe global commands. This file, call it config/global_commands.rb , for example, is analogous to\nthe config/shared_commands.rb file from the above and looks about the same, with the exception\nthat the @plugin_commands variable is now @global_commands . An example is below: case @command\n\n# Print the current version notes of the atd_test module.\nwhen \"atd_test:version_notes\"\n require \"#{Origen.root!}/lib/commands/version_notes\"\n exit 0\n\nelse\n @global_commands << <<-EOT\n atd_test:version_notes Checks the dPDM BOM versus the DS HREFs\n -h for a full description\n EOT\n\nend Danger! Global commands are a bit more involved and require some extra setup outside of the\n plugin itself. When inside an application, these commands will behave as Shared commands,\n but outside of an application, the plugin must be brought in as a dependency either through User Installs or Tool Repo Installs , or must be added to the system gems. For a refresher on what this means,\n please see the Invocation Considerations Guide . For even more\n details please see the Advanced Topic On Invocations . Danger! Global commands behave slightly differently when run from an application\n versus running without one. Origen does provide a 'standalone' application which gives all the functionality,\n but this application cannot be customized. If you find yourself requiring application-specific behavior, your command\n is better suited to be a Shared command. Danger! Although Global and Shared commands may have differences\n in the application behavior, they do not have any differences, from an Origen perspective, when invoked\n either by a Tool Repo Install or User Install setup versus a System Level setup. Bundler makes it easier to develop Global commands than using Gem natively, so it is recommended\n that you use a User Install when developing Global commands. You can read up on this is and\n how to set it up in the Advanced Topic On Invocations . Command Sharing Considerations Due to the way that Origen acknowledges shared, global, and application commands, a pitfall exists where user-defined commands\ncan step on each other (known as command clobbering ). This has the implication that you may not be running the command you think you\nare running. Consider a plugin, called my_plugin_1 that adds and implements a shared command my_command . This\ncommand will be available to any application which contains my_plugin_1 as a dependency. Now, consider a second plugin, my_plugin_2 which is also a dependency of the application. my_plugin_2 also adds and implements the\ncommand my_command . Both plugins are adding the same command and are clobbering the command listing. The behavior\nwill be dependent on the load order and can be difficult to predict. For example, if my_plugin_1 is listed before my_plugin_2 in the application’s Gemfile , then my_plugin_1 will be loaded and evaluated first and my_command in my_plugin_1 will be run. However,\nthat is not all the consideration needed. If my_plugin_1 actually lists my_plugin_2 as its dependency,\nthen my_plugin_2 will be loaded before my_plugin_1 regardless of the load order in the application’s Gemfile . Now, my_command in my_plugin_2 will be run. This means that it can be difficult\nto track which one of the commands will be run in the case of command clobbering between plugins. You can use the bundle command to see what the final load order is and track down which version of the command will be run. The solution to this is to add namespacing to each of the plugins, as shown in the Sharing Application Commands section above. However, this is up to the plugin developers to abide by. Origen does not guarantee nor enforce this \nbehavior and is none the wiser to plugins stepping on each other. No\nwarnings or errors are generated in the event of command clobbering. Regarding global commands, the same pitfall exists. However, an additional issue is that a shared command can now clobber a global\ncommand. In the current Origen implementation, shared commands take precedence over global commands. Meaning, if my_plugin_1 implements my_command as a global command and, for one reason or another, it implements my_command as a shared\ncommand, then when running in an application the shared version of my_command will be used. However, external\nto an application, the global version of my_command will be run. Like shared command clobbering, no warnings\nor errors are generated, Origen is completely oblivious to this behavior, and it is up to the plugin developers to ensure this does not\noccur. This is a known issue which has been registerd with the core team. For tracking this issue’s status, please see the Cascading Commands Issue on Github. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/plugins/current/": {
    "title": "Current Plugin",
    "subtitle": "Plugins",
    "body": "Plugins Current Plugin The current plugin is a concept that comes into play whenever a plugin provides pattern\nand test program sources to a parent application. The current plugin is selected in a similar way to the current target, either at \nruntime to set the current plugin for a given job only: origen g atd_ramp --plugin atd_test or the workspace default can be set via the origen pl command: origen pl atd_test Identifying a current plugin performs two main functions: Limits the search scope when dynamically searching for pattern sources and avoids\nambiguity over which pattern is being requested Selects which application callbacks and configuration context should be enabled The first function is fairly self explanatory and means that Origen will search for the requested\npattern only within the subset of all available patterns that are owned by the current plugin.\nThe second function warrants some more discussion… Application instances (as defined in config/application.rb) are automatically registered\nas listeners into Origen’s callback system and this\nis often used to implement pattern generation features like sourceless pattern generation . That works fine when an application is running standalone, but once it starts to\nincorporate many plugin instances who can all synthesize pattern sources then we have a\nproblem over which one to choose to fulfill a given request. Similarly there could be issues when\na 3rd party callback listener kicks in when generating a completely unrelated pattern. The selection of the current plugin therefore gives Origen some help by specifying what area\nof the wider application should be enabled when generating a particular pattern.\nIdeally a more automated system would be developed for this, and it may be in future, but for\nnow the current plugin concept solves the problem and doesn’t seem to be much of an hindrance to\nuse in practice. Aside from callbacks, the current plugin selection also selects which plugin’s configuration\noverrides should be applied to a given generation job, see the plugin configuration guide for some more discussion on this. Programmatically Setting the Current Plugin The current plugin can be set in Ruby code using the below API. Origen .app.plugins.current = :atd_test # Sets the default plugin Origen .app.plugins.temporary = :atd_test # Temporarily sets the current plugin (for this thread only) Origen .app.plugins.temporary = nil # Discard the temp plugin and set it back to the default Origen .app.plugins.current.name # Returns current plugin name A common usage pattern for modern ‘BOM’ style applications is to have a target corresponding to each\nmain pattern type, which typically will correspond to the main plugins that are providing pattern\nsources to the application. The current plugin can therefore be set in the target and then forgotten about, such that it\nwill automatically be set to the correct thing based on the current target: # target/atd.rb load \" #{ Origen .root } /target/dut.rb \" # Load and instantiate the DUT Origen .app.plugins.temporary = :atd_test # target/nvm.rb load \" #{ Origen .root } /target/dut.rb \" # Load and instantiate the DUT Origen .app.plugins.temporary = :nvm_test Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/plugins/development/": {
    "title": "Dev Considerations",
    "subtitle": "Plugins",
    "body": "Plugins Dev Considerations Here are some basic development considerations that all plugin developers should\nfollow: Use Semantic Versioning Use semantic versioning (e.g. v1.2.3) for the plugin application and\nrespect the conventions.\nSee semver.org for details on what is expected. The main takeaway is that breaking API changes are only allowed when changing the\nmajor version counter. In other words an application that depends on version\n1.1.0 of your plugin, should be able to run fine under version 1.99.0. Add Tests Consumers of the plugin should not have to keep their fingers crossed or\nextensively test at their end when pulling a new version of the plugin.\nThe plugin itself needs to take responsibility for ensuring that things don’t\nbreak between releases. Tests are most easily written using diffs - create some dummy patterns\nwithin the plugin application to fully exercise all methods, then make\nsure that the output remains consistent when making changes or adding new\nfeatures. Additionally unit tests can be created using the Ruby Test::Unit or RSpec\nlibraries (new Origen apps come pre-configured for the latter out the box). Origen core already does a good job of testing using both methods described above\nand can be consulted for examples. Use Namespaces The possibilities for naming clashes will increase as more Origen code is\nimported from shared plugins, therefore all plugins should be good\ncitizens and ensure that they don’t pollute the global namespace. All classes defined within a plugin should be contained within a module\nnamed after the plugin. See the section on namespacing here for more details - Naming Models Document as You Go Users of your plugin will appreciate good documentation, the easiest way\nto do this is to document your methods via useful descriptions as you\nwrite them. These descriptions can then be automatically extracted into API\ndocumentation later. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/plugins/environment/": {
    "title": "Dev Environment",
    "subtitle": "Plugins",
    "body": "Plugins Dev Environment Your plugin development environment may need to be setup slightly\ndifferently compared to when working on a standalone application. If the plugin can function and be fully tested standalone, then no special\nconsideration is required and it can be developed like a regular application.\nHowever in some cases you may need a receiving application to\nimport the plugin to allow its\nfunctionality to be fully evaluated and tested. In that case setup up two workspaces: one for the plugin and another to be the receiving application. Within the receiving application’s Gemfile , add a path reference to the plugin\nworkspace like this: # Gemfile gem \" atd_test \" , path : \" /proj/origen_dev/thao/blocks/atd_test \" The receiving application will now be using the plugin from the workspace in exactly the same\nway as it would if it was imported through the Ruby gems system. Origen will not allow the receiving application to be tagged when a path reference is active,\nso you don’t need to worry too much about forgetting to remove it! Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/plugins/importing/": {
    "title": "Using a Plugin",
    "subtitle": "Plugins",
    "body": "Plugins Using a Plugin Plugins are distributed as Ruby gems and are added to an application as described\nhere: Understanding Gems . All plugins should provide documentation that supplies the required\ndetails, here is an example - Origen JTAG Driver Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/plugins/introduction/": {
    "title": "Introduction",
    "subtitle": "Plugins",
    "body": "Plugins Introduction Origen enables easy and wide reaching code re-use via its Plugin system. The plugin system enables models, controllers, drivers and any other Origen-based IP\nto be shared between multiple\napplications while maintaining a single centralized point of ownership\nand development. The Plugins Directory can be consulted to\nreview what plugins are currently available for use by your application. Plugins allow any code from the lib directory, any templates,\nany pattern or program sources files, or any custom commands\nto be shared between applications. Therefore plugins can be constructed to share DUT models, test program\ninterfaces, documentation layouts, VB or C code snippets, entirely\nnew Origen commands, etc., etc. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/plugins/misc/": {
    "title": "Miscellaneous Topics",
    "subtitle": "Plugins",
    "body": "Plugins Miscellaneous Topics Topics on this page relate to plugins in general but do not fit into any of the previous topics and are too minor in scope and content to warrant their own pages. Failing the Application Failing the Application Sometimes, the usage of your application or plugin is not correct, certain conditions are not met, or some other circumstance arises in which the application or\nplugin cannot continue. In these instances, the best course of action is to print the error message and exit the current process. Ruby provides a few methods to do this. Most commonly: throw : raises an exception. fail/raise : raises a runtime error. exit : raises a SystemExit error but still runs ensure blocks and can be rescued. exit! : kills the process immediately. Each of these has their place, but their usefulness is based primarily on the information you, as the developer, provide. For example, using exit! without any error message\njust kills the process, without any information going back to the user. fail can be used to dump a stack trace, but for those that aren’t power users, and\nespecially for those who are newer to programming, this can be almost as bad as providing no details, with the exception of sending the stack trace to someone else. Information on the what, where, when, and why for failing and exiting the process is readily available online, both for Ruby and for programming in \ngeneral. Discussions on those matters get into best practices , use cases , coding styles , etc., and are way out of the scope of this guide. What\nwill be covered is how Origen can help you when you choose to exit the process and/or raise an exception. Origen provides two methods to help with this: Origen.app.fail , and Origen.app.fail! . The former behaves almost identically to the standard fail method, with the exception of accepting a hash instead of string, and prepending the current application that is calling Origen.app.fail . Note that these are Origen::Application instance methods, and Origen.app will always reference the application. For usage in plugins, Origen.app! should be used instead. See here for additional information. Origen .app!.name #=> my_app fail #=> RuntimeError with no message # Just fail the application, without adding details: Origen .app!.fail #=> RuntimeError with message: 'Fail in my_app' # Fail the application with some context: Origen .app!.fail( message : ' An unknown condition occured! ' ) #=> RuntimeError with message: 'Fail in my_app: An unknown condition occured!' # Fail the application with some context and a custom exception: Origen .app!.fail( message : ' An unknown condition occured! ' , exception_class : StandardError ) #=> StandardError with message: 'Fail in my_app: An unknown condition occured!' Note that exception_class should be a class object (of type class ), not an instance of the class. Origen.app.fail! performs the same function as Origen.app.fail but raises a SystemExit and quits the process cleanly\n(no stack trace). It also prints the message using Origen’s Logger ,\ninstead of using the exception message to convey information. The key difference, however, is if the current process is run with debug enabled (using the -d or --debug command line options)\nthen Origen.app.fail! behaves identically to Origen.app.fail . The intention is give a user-facing API a clean exit while displaying in the\nfamiliar Origen-logger format, while allowing users to generate more useful bug reports, or just for the curious user themselves to get more information. Origen .debugger_enabled? #=> false Origen .app!.name #=> :my_app Origen .app.fail!( message : ' An unknown condition occured! ' ) #=> [ERROR] 0.009[0.009] || Fail in my_app: An unknown condition occured! #=> *Process Terminates* Origen .debugger_enabled? #=> true Origen .app!.name #=> :my_app Origen .app.fail!( message : ' An unknown condition occured! ' ) #=> RuntimeError with message: Fail in my_app: An unknown condition occured! #=> *Process terminates with #raise instead of #exit* #=> *Exception and stack trace printed to console* By default, the status of a process exited with Origen.app.fail! will be 1 . You can provide an option exit_status to exit with that status instead. Full API documentation is available on the API Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/plugins/paths/": {
    "title": "Paths & Origen.root",
    "subtitle": "Plugins",
    "body": "Plugins Paths & Origen.root As you may know Origen.root can be used to make references\nto files and paths within Origen application code. In this simple example\nthe variable my_pattern_dir will be assigned to an absolute\npath to the application’s pattern directory regardless of where the workspace\nowner has installed the application: my_pattern_dir = \" #{ Origen .root } /pattern \" However things get a bit more complicated when writing a plugin, for example\nif the above code resides in a plugin do you mean the plugin’s pattern directory\nor the pattern directory of the importing application? By established conventions Origen.root always means the root of the\ncurrent application, so in the above example the variable will always be set\nto the top-level application’s pattern directory even if the code resides in\na plugin. Origen.root! What if you are writing a plugin and you do mean to reference somewhere\nwithin the plugin’s source files? In that case the method Origen.root! can be used instead. If the plugin\nis being run in a standalone manner then the path returned will be the same as that\nfrom the conventional Origen.root . However if the plugin is invoked through\na 3rd party application then it will return the path to the plugin’s source files instead of\nthose of the importing/top-level application. Here is a simple example to illustrate this: # Lives in a plugin called 'atd_test' module ATDTest class ATD16 def root Origen .root end def root! Origen .root! end end end # Lives in the top-level application class SoC def atd @atd ||= ATDTest :: ATD16 .new end def root Origen .root end def root! Origen .root! end end # Say the top-level application has been installed to /proj/c28/workspace1 $dut = SoC .new $dut .root # => \"/prog/c28/workspace1\" $dut .root! # => \"/prog/c28/workspace1\" $dut .atd.root # => \"/prog/c28/workspace1\" $dut .atd.root! # => \"/home/thao/.origen/gems/atd_test\" Origen.root(:plugin_name) Additionally within an application it is sometimes useful to be able to refer\nto a 3rd party plugin’s root directory. This can be done by supplying the name of the\nplugin to Origen.root . An example use case of where this is useful is if you want to re-open and extend\na class that is provided by a plugin: # Ensure the original is loaded require \" #{ Origen .root( :atd_test ) } /lib/atd_test/atd16 \" module ATDTest class ATD16 def my_additional_method puts \" hello \" end end end Origen.top Origen.top always returns the absolute path to the Origen core\ninstallation regardless of whether it is called by top-level application or plugin code. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/code/": {
    "title": "Dynamic Custom Code",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator Dynamic Custom Code A big advantage that the Origen program generator has over other\ntools is that even if you need to generate a test program file that is not\nofficially supported by the generator you can easily work around it \nby dropping down to a template for that specific section of the program. A nice offshoot of this capability is that any custom code in your\ntest program (such as custom Visual Basic or C++ code for example) can be\ndynamically generated via code templates. A Dynamic VB Example Generally using templates within the context of a test program is the same\nas using them in any other context and therefore the Compiler Guide should be consulted\nfor more details on the compiler syntax that should be used. For a tester oriented example here is a snippet of some VB code that has been\nmarked up with Origen compiler directives: NUM_VREGS = <%= $dut .vregs.size %> ' Now initialize DUT variables for each site\nFor lSite = 0 To lSiteCnt\n With oDUTData(lSite)\n Call .Clear\n% $dut.vregs.each do |vreg|\n Call .AddVreg( <%= vreg.nominal_level %> )\n% end\n End With\nNext So for a device with a 1.2V and a 3V regulator this would compile to: NUM_VREGS = 2\n\n' Now initialize DUT variables for each site\nFor lSite = 0 To lSiteCnt\n With oDUTData(lSite)\n Call .Clear\n Call .AddVreg(1.2)\n Call .AddVreg(3)\n End With\nNext Whereas for a device with only a single 1.2V regulator we would end up with: NUM_VREGS = 1\n\n' Now initialize DUT variables for each site\nFor lSite = 0 To lSiteCnt\n With oDUTData(lSite)\n Call .Clear\n Call .AddVreg(1.2)\n End With\nNext Building Dynamic Code Compiling any templates that form part of your test program can be co-ordinated\nwithin a Resources file by calling the compile method.\nAny option arguments passed in will be available within the options hash within the template. Resources .create do compile \" templates/j750/vreg_funcs.bas \" , max_vdd : 5 .V end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/custom/": {
    "title": "Creating Custom Testers",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator Creating Custom Testers Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/doc/": {
    "title": "Documenting the Program",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator Documenting the Program Origen allows test descriptions to be entered quickly and easily within the\ntest flow source file, enabling a test program document to be produced that is extremely\naccurate due to it being derived from the same source as the program itself. The application must also define a documentation interface in order to do the translation\nbetween the application-specific flow API and the Origen test program documentation back end -\nthis is the exact same principle as generating an interface for a specific ATE platform. Typically creating a documentation interface is much easier than creating an ATE platform\ninterface and is discussed later in this guide .\nNote that if you don’t initially have time to set up the documentation interface you should still\ntry and document the program as described here since the code it produces will still be\ncompatible with any tester interface. Then when time allows you can setup the documentation\ninterface with the hard part of actually describing the tests already done. The Documentation Helpers plugin provides off\nthe shelf test flow helpers to render such documentation metadata as a well formatted web document. Flow Markup Flow sections and individual tests should be documented like this: # A Test Sub Module # Test flow modules like this will collapse and nest when they are included in a parent # flow via the import command. The first line will be the name assigned to the collapsible # area, the rest of these comments will be shown when it expands. **It will be parsed for # markdown.** Flow .create do # Any comments in here will attach as a description to the next test func :measure_vreg , bin : 45 , vdd : min # This is a description of what this test does #- Prefixing the line with a '-' will cause it to be private, so this is how you would #- record some implementation detail that is of interest to engineers working on this #- flow, but which is not relevant to its overall operation func :vreg_func1 , bin : 50 # All comments can contain markdown, for example # # * A bulleted # * list func :vreg_func2 , bin : 55 , iload : 50 .uA end When generated against an appropriate documentation interface and passed to the Documentation Helpers plugin, this would generate a\nflow section like this (click to expand): A Test Sub Module Test flow modules like this will collapse and nest when they are included in a parent\n flow via the import command. The first line will be the name assigned to the collapsible\n area, the rest of these comments will be shown when it expands. It will be parsed for\n markdown. Test Number HBin SBin Attributes Description measure_vreg #45000 B45 Vdd : min Any comments in here will attach as a description to the next test vreg_func1 #50000 B50 This is a description of what this test does vreg_func2 #55000 B55 iload : 50E-06 All comments can contain markdown, for example A bulleted list Documenting Structure Tests can be grouped together by wrapping them with the pp helper, here are\nthe two functional tests grouped together with some description added about what the\ngroup contains: # A Test Sub Module # Test flow modules like this will collapse and nest when they are included in a parent # flow via the import command. The first line will be the name assigned to the collapsible # area, the rest of these comments will be shown when it expands. **It will be parsed for # markdown.** Flow .create do # Any comments in here will attach as a description to the next test func :measure_vreg , bin : 45 , vdd : min # Within flow sections should be marked like this (this is the same API to indicate # structure in pattern logic to). This text will appear when the collapsible area is # shown and will be parsed for markdown. pp \" Functional Tests \" do # This is a description of what this test does #- Prefixing the line with a '-' will cause it to be private, so this is how you would #- record some implementation detail that is of interest to engineers working on this #- flow, but which is not relevant to its overall operation func :vreg_func1 , bin : 50 # All comments can contain markdown, for example # # * A bulleted # * list func :vreg_func2 , bin : 55 , iload : 50 .uA end end The functional tests will now be nested in a collapsible group: A Test Sub Module Test flow modules like this will collapse and nest when they are included in a parent\n flow via the import command. The first line will be the name assigned to the collapsible\n area, the rest of these comments will be shown when it expands. It will be parsed for\n markdown. Test Number HBin SBin Attributes Description measure_vreg #45000 B45 Vdd : min Any comments in here will attach as a description to the next test Functional Tests Within flow sections should be marked like this (this is the same API to indicate\n structure in pattern logic to). This text will appear when the collapsible area is\n shown and will be parsed for markdown. Test Number HBin SBin Attributes Description vreg_func1 #50000 B50 This is a description of what this test does vreg_func2 #55000 B55 iload : 50E-06 All comments can contain markdown, for example A bulleted list Dynamic Documentation From Helpers Helper methods can be added to your interface to generate multiple tests or to otherwise dynamically generate a\nsection of the flow. Within these methods the cc method can be used to stage comments that will be attached to\nthe next test to be generated: def program_sequence cc \" Issue a pulse \" func :program_20us cc \" Do a verify \" func :read_margin0 end Creating A Documentation Interface A documentation interface can be thought of as an interface for a really simple tester which only has the\nconcept of a flow and a collection of tests. Here is the basic starting point for any documentation interface: class DocInterface include OrigenTesters :: Doc :: Generator # Add a test to the collection def add_test (name, options)\n tests.add(name, options) end # Add a flow entry def add_flow_entry (test, options)\n flow.test(test, options) end end As with any interface it is then required to create methods to translate your domain specific\nflow API into calls to these two key methods to add a test and a flow entry. Our example flow here has a func method, we might implement the handler for that like this: def func (name, options={})\n add_test(name, options)\n add_flow_entry(name, options) end Over and above that what happens next is very domain specific and depends if any processing\nor sanitizing of the options or names are required to produce an accurate document.\nSome domain specific examples from the simple flow in this guide would be: By default any options passed to the add_test method will be rendered into the\nattributes column. In our case we are supplying the bin as a flow line option and that will\nalready be displayed in the dedicated column when it is passed to the flow entry. To inhibit\nthe bin appearing in the test attributes we can screen the options like this: # Add a test to the collection def add_test (name, options) # Delete any keys that we don't want to assign to the instance, this keeps # the attributes column clean, flow control keys will be screened by Origen automatically [ :bin , :some , :other , :keys ,\n ].each { |k| options.delete(k) }\n tests.add(name, options) end As noted in the above comment any keys related to flow control will be automatically screened and handled by Origen (doc helpers knows how to display this\ninformation to). Another convention from the above example was that we did not supply a test number and it was\nautomatically set to a multiple of the bin number,\nwe can handle that like this: # Add a flow entry def add_flow_entry (test, options)\n options = sanitize_flow_options(options)\n flow.test(test, options) end def sanitize_flow_options (options) # If the number has not been set in the flow then set it to a multiple of the bin, if present options[ :number ] ||= options[ :bin ] ? options[ :bin ] * 1000 : nil options end Note that many of the methods involved in processing the test options such as the sanitize_flow_options method here would be common to all\ninterfaces and therefore should not need special handling specifically for documentation.\nRather you\nshould create a common module that gets included into all interfaces to handle the non-tester-platform\nspecific concerns like these. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/flowapi/": {
    "title": "Managing Flow Control",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator Managing Flow Control The runtime flow control of a test program is an area that can be particularly messy: Need to deal with different and often obscure vendor APIs It can be very hard to decipher both the intention and the actual behavior\nduring code reviews It is easy to make mistakes Mistakes can be costly - there have been many customer quality\nincidents in the past from missed test caused by errors in flow control To deal with these problems Origen provides a simple and intuitive API\nto describe runtime flow logic: Generates legal and battle-tested code Takes care of cross-platform implementation Makes flow control easy to review Covers over gaps or weaknesses in the vendor APIs Conditional tests fall into two categories: Those that will run based on the flow execution environment. For example based on\nthe job selected at runtime or on some enable flag that can be set by the user at\nruntime. Those that will only run based on the outcome of another test - i.e. execute a given\ntest based on whether a previous test passed, failed or ran at all. Execution Based on the Runtime Environment The following methods are available to describe these cases: if_enable / unless_enable - Run the test if a flow runtime option is/is not enabled at runtime if_job / unless_job - Run based on the current job (P1, FR, QC, etc) Here are some examples of how to apply these methods to single tests: # Run this test to characterize the vreg, only if the 'vreg_cz' flag has been enabled para :vreg_meas , softbin : 107 , cz : true , if_enable : \" vreg_cz \" # Apply HVST to the vreg module, unless the 'skip_hvst' flag has been enabled func :vreg_hvst , softbin : 101 , hv : 10 .V, vdd : :max , unless_enable : \" skip_hvst \" # Run this test only at cold para :vreg_meas , softbin : 105 , lo : 1.12 , hi : 1.34 V , if_job : \" FC \" The use of if/unless_enable will make use of flow enable words on Teradyne platforms and user\nflow variables on Advantest.\nThe if/unless_job control will make use of the job column on Teradyne platforms and a user\nflow variable named @JOB on Advantest. Both of these controls support a block form, which allows it to be applied to a group of test\nand, in the case of enable words, it also provides a way to implement AND and OR logic: # OR - Run these tests if either word is set if_enable [ :word1 , :word2 ] do func : :test1 func : :test2 end # AND - Run these tests if both words are set if_enable :word1 do if_enable :word2 do func : :test1 func : :test2 end end Execution Based on a Previous Test The following methods are available to describe these cases: if_ran / unless_ran - Run only if a previous test did or did not run if_failed (unless_passed) - Run only if a previous test failed if_passed (unless_failed) - Run only if a previous test passed All of these methods require you to provide the ID of the previous test on which\nthe conditional execution will depend.\nThis ID must be assigned by you in the flow line of the previous test by adding\nan :id key, like this: para :vreg_meas , softbin : 105 , lo : 1.12 , hi : 1.34 , id : :vreg_meas_1 The ID can be any value you like as long as it is unique, Origen will raise an error\nif any duplicate IDs are encountered. On the dependent tests the API is similar to the previous examples except the ID\nof the previous test is given in place of the enable flag or job name.\nHere are some examples: para :vreg_meas , softbin : 105 , lo : 1.12 , hi : 1.34 , id : :vreg_meas_1 # Automatically characterize the vreg if the measurement fails para :vreg_meas , softbin : 107 , cz : true , if_failed : :vreg_meas_1 # Then bin out bin 3 , softbin : 105 , if_failed : :vreg_meas_1 # Check if the HVST has already been run on this device func :rd_vreg_hvst_passcode , softbin : 50 , vdd : :nom , id : :vreg_hvst_done # If not run it func :vreg_hvst , softbin : 101 , hv : 10 .V, vdd : :max , unless_passed : :vreg_hvst_done # And program the flag for next time func :pgm_vreg_hvst_passcode , softbin : 51 , vdd : :nom , unless_passed : :vreg_hvst_done Origen automatically takes care of setting up all of the tests in the relationship: The parent tests in the relationship are automatically set to continue on fail Flag(s) will be set to indicate whether the parent test passed or failed Conditional execution flags are set on all dependent tests AND and OR conditions can be created by using if_any/all_failed/passed variations as follows: func :test1 , id : :t1 func :test2 , id : :t2 # OR logic - This test will run if either of the referenced tests fail func :test3 , if_any_failed : [ :t1 , :t2 ] # AND logic - This test will only run if both of the referenced tests fail func :test4 , if_all_passed : [ :t1 , :t2 ] # Block forms are available as with all condition APIs if_any_passed [ :t1 , :t2 ] do #... end References to External Tests It is possible to generate conditional relationships between tests that span across\ndifferent flow modules, in that case the test ID must be appended with :extern_ .\nThis will indicate to Origen that the reference is external and\nwill prevent an error being raised for the ID not being found within the current flow. Here is an example: # program/flow_1.rb Flow .create do # This ID can only be referenced within this flow func :test1 , id : :t1 # This ID can be referenced outside of this flow func :test2 id : :extern_t2 end # program/flow_2.rb Flow .create do # This will generate an undefined ID error func :test3 , if_failed : :t1 # But this will work, since the ID's name indicates that it is an intentional external reference func :test4 , if_failed : :extern_t2 end Applying Conditions to Sub-Flows All of the flow control methods have a block form which will apply the\ncondition to all tests within the block. A very useful pattern is to split your code into small re-usable snippets\nand then wrap the import with these flow control methods to apply conditional\nexecution.\nFor example, here the ‘FH’ job requirement will be applied to all tests\nimported from the vreg component: # Only run the vreg tests at hot if_job \" FH \" do import \" components/vreg \" end Conditions Applied to Groups Groups can also be used to implement AND/OR logic, here is an example of how you\nmight implement a speed binning flow: group \" 200Mhz \" , id : :spec200 do func :test1_200 func :test2_200 end # Bin out to bin 1 if passed at 200 Mhz, here if_passed will apply to all tests in the group pass 1 , if_passed : :spec200 group \" 100Mhz \" , id : :spec100 do func :test1_100 func :test2_100 end # Bin out to bin 2 if passed at 100 Mhz, here if_passed will apply to all tests in the group pass 2 , if_passed : :spec100 # Otherwise we have failed bin 3 Manually Setting and Referencing Flags It may be sometimes be necessary to react on a flag that is controlled by a 3rd party and\nwhich will be passed into an Origen-based test block, or to set a flag which a 3rd\nparty test block will later reference. An API exists to manually set and react to flags in these situations: log \" Example of manual flag setting upon pass or fail \" test :test1 , on_pass : { set_flag : :my_pass_flag }, on_fail : { set_flag : :my_fail_flag }, continue : true # Execute only if the above pass flag was set test :test2 , if_flag : :my_pass_flag # Execute only if the above pass flag was not set unless_flag :my_pass_flag do test :test3 end Note that flag names will usually be forced to uppercase, this is to institute a convention that\nflags/flow variables are always uppercased in order to avoid any test program bugs from\nincorrectly referencing a given flag due to case sensitivity. However, if you need to reference a flag from a 3rd party test module that does not follow this\nconvention, then a literal flag can be supplied by prefixing it with $ as shown below: test :test1 , on_fail : { set_flag : :$My_Mixed_Flag }, continue : true test :test2 , if_flag : \" $My_Mixed_Flag \" unless_flag \" $My_Mixed_Flag \" do test :test3 end test :extra_test , if_enable : :$MCEn_extras unless_enable \" $MCEn_test \" do test :test1 test :test2 end In all cases the $ will be removed from the final flag name that appears in the test program. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/flows/": {
    "title": "Creating Flows",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator Creating Flows The test flow is where you describe everything about what your test program\nmust do: The tests it must run The conditions applied by these tests Test limits Bin and test numbers Conditional test execution and other flow control Notes about the reason for running or the methodology behind each test When writing your flow file you should try and distill down the amount of information\nto the bare minimum, the goal here is to write as little as possible yet still\ncapture the details about what makes each test unique. When describing each test the syntax and naming conventions are entirely\nup to you and based on your knowledge about the application domain and the\ntype and variety of tests that you need to generate.\nIt will be the job of the interface (which you will write later) to translate\nthis description into method calls to the generation API for the target platform. Your First Flow File By convention all flow files should reside in the “program” directory within\nthe application top-level directory. Create the file “program/probe.rb” as shown below: # program/probe.rb Flow .create do end The above represents all of the officially required syntax to define a flow, what\ngoes inside is now completely down to the needs of the application. When creating a flow like this it is often useful to supply some context about\nthe environment in which it will run. For example we have indicated via the name that this\nis a flow intended to run at probe, we can also note this in the code: # program/probe.rb Flow .create( environment : :probe ) do end Again the naming of the terms :environment and :probe are\ncompletely arbitrary, you may want to note some details about the temperature, parallelism\nor other details which may be useful to you when it comes to actually generating\nthe flow for a given ATE platform.\nOr not. Don’t worry about this too much right now, in practice it is probably best to\njust add things like this as you find that you need them. The main thing for now is just to\nappreciate that you can pass some details about the execution environment of the given\nflow to the interface via this mechanism. Specifying Numbers Origen extends Ruby to add the following methods which are very helpful\nwhen specifying test conditions: 3 .A # => 3 3 .mA # => 0.003 3 .uA # => 0.000003 3 .nA # => 0.000000003 3 .pA # => 0.000000000003 3 .V # => 3 3 .mV # => 0.003 # => etc 3 .Hz # => 3 3 .kHz # => 3000 3 .MHz # => 3000000 Adding Some Tests So let’s say we are writing a test for a voltage regulator module, we have a functional\ntest and then two parametric tests that we wish to run - one that simply tests the\noutput and one that tests the output under load.\nLet’s start with this: # program/probe.rb Flow .create( environment : :probe ) do log \" Vreg test module \" func :vreg_functional , pattern : \" vreg/functional \" , vdd : :min , bin : 5 , softbin : 101 , tnum : 101000 func :vreg_functional , pattern : \" vreg/functional \" , vdd : :max , bin : 5 , softbin : 101 , tnum : 101001 para :vreg_meas , pattern : \" vreg/meas \" , vdd : :min , bin : 5 , softbin : 105 , tnum : 105000 , lo : 1.12 , hi : 1.34 para :vreg_meas , pattern : \" vreg/meas \" , vdd : :max , bin : 5 , softbin : 105 , tnum : 105001 , lo : 1.12 , hi : 1.34 para :vreg_meas , pattern : \" vreg/meas \" , vdd : :min , bin : 5 , softbin : 105 , tnum : 105002 , load : 5 .mA, lo : 1.10 , hi : 1.34 para :vreg_meas , pattern : \" vreg/meas \" , vdd : :max , bin : 5 , softbin : 105 , tnum : 105003 , load : 5 .mA, lo : 1.12 , hi : 1.34 end This is a good start, we have something that resembles a test flow and we have gone with the\ngeneral convention that a flow line is structured like this: <function> <name>, <attributes> function - The main function of a particular test, here we have gone with the categories\n‘log’, ‘func(tional)’ and ‘para(metric)’. You may wish to have other categories based on your domain.\nFor example in some NVM applications we have ‘program’, ‘read’, ‘erase’, ‘measure’, ‘bitmap’,\nand so on. Each of these functions correspond to the methods that you will need to implement\nin your interface later. name - Almost every test will need a name and so we make this a mandatory argument. attributes - There then follows a free-format list of attributes, use these to describe\nthe test and especially including anything that makes the test unique, such as the load\nattribute which has been used above. As mentioned previously this choice of convention is just that, a personal choice, however\nthis is the convention that is currently used in the flagship Origen applications that are\ncurrently driving the development of the framework.\nAs the Origen program generator matures and the number of applications using it grows, it is\npossible that alternative and better conventions will begin to emerge.\nIf you come across a better approach then please come and tell us about via the Origen community channels ,\nhowever we will stick with this one for now. Eliminate Anything that can be Inferred Remember that the goal here is to be as concise as possible, since the more concise you\nare at this level then the more you can automate later. This eliminates duplication and\nredundancy, reduces the amount of code you need to write to add a new test later, and the\nmore that can be generated the less chance there is for human error. There are a few opportunities for simplification that we can consider at this point: The pattern field seems redundant - it very closely mirrors what has been assigned to the\ntest name, therefore we can infer the pattern name without explicitly declaring it. It is generally\na good approach to name the test after the pattern if you normally have one pattern per test. The bin number also looks to be redundant, it is always 5. In a case like this what\nwe can do is set a default of 5 within the interface, then if it is not declared for a specific\ntest it will be 5, but we can always override it for a specific test. The tnum attribute seems to follow the general rule that it is the softbin number * 1000\nand then a counter. Anything that is the result of a function based on other\nattributes is ripe for elimination. With those optimizations applied we end up with: # program/probe.rb Flow .create( environment : :probe ) do log \" Vreg test module \" func :vreg_functional , vdd : :min , softbin : 101 func :vreg_functional , vdd : :max , softbin : 101 para :vreg_meas , vdd : :min , softbin : 105 , lo : 1.12 , hi : 1.34 para :vreg_meas , vdd : :max , softbin : 105 , lo : 1.12 , hi : 1.34 para :vreg_meas , vdd : :min , softbin : 105 , load : 5 .mA, lo : 1.10 , hi : 1.34 para :vreg_meas , vdd : :max , softbin : 105 , load : 5 .mA, lo : 1.12 , hi : 1.34 end Finally we seem to always be running our tests at min vdd and then max vdd, so again\nthere seems to be a convention that we could choose to implement by default. One issue we\nhave is that the loaded test has a different limit between min and max, so this a\ngood example of one case where we would override the default. So switching to the convention that each test will execute at min and max vdd unless otherwise\nspecified, our final flow is: # program/probe.rb Flow .create( environment : :probe ) do log \" Vreg test module \" func :vreg_functional , softbin : 101 para :vreg_meas , softbin : 105 , lo : 1.12 , hi : 1.34 V para :vreg_meas , vdd : :min , softbin : 105 , load : 5 .mA, lo : 1.10 , hi : 1.34 para :vreg_meas , vdd : :max , softbin : 105 , load : 5 .mA, lo : 1.12 , hi : 1.34 end That very clearly and concisely describes what the flow must do. Also by establishing\nconventions and eliminating redundancy we have made it really easy for us to add\na new test in the future. Flow Control See the next section for details on run-time flow control. For build-time flow control you have complete access to the current target objects if you\nneed to conditionally build some tests. Lets say we have two DUT designs, and one of them has a bug which means that the\nvreg load test will not work properly. Let’s say its a problem with the pad connection\nsuch that the vreg works ok but it just can’t be tested via an external load.\nOur models to represent this situation would look something like this: # lib/dut_1.rb class DUT1 include Origen :: Model end # lib/dut_2.rb class DUT2 < DUT include Origen :: Model bug :vreg_pad end DUT1 .new.has_bug?( :vreg_pad ) # => false DUT2 .new.has_bug?( :vreg_pad ) # => true There are two ways that we could build the flow to ensure that DUT2 can still give a bin 1 - either\nskip the loaded test completely, or else don’t care its result.\nHere is an example of both: # program/probe.rb Flow .create( environment : :probe ) do log \" Vreg test module \" func :vreg_functional , softbin : 101 para :vreg_meas , softbin : 105 , lo : 1.12 , hi : 1.34 # Don't build this test if the target DUT has the bug unless $dut .has_bug?( :vreg_pad )\n para :vreg_meas , vdd : :min , softbin : 105 , load : 5 .mA, lo : 1.10 , hi : 1.34 end # Continue on fail if the target DUT has the bug para :vreg_meas , vdd : :max , softbin : 105 , load : 5 .mA, lo : 1.12 , hi : 1.34 , continue : $dut .has_bug?( :vreg_pad ) end Re-usable Flow Snippets It is ofter useful to extract sections of a flow into a sub-module, so that it can be re-used\nand parameterized.\nIn our case let’s say that we have a new DUT on the horizon which has two vreg instances, so\nlet’s extract this suite of vreg tests to a module so that we can instantiate two of them in\nour flow. All sub flow file names must begin with “_”, this is what tells Origen that it is a sub-flow and\nnot a top-level flow.\nThe sub-flow syntax is virtually identical to the regular flow syntax except that a hash of\noptions are passed in which will contain any arguments passed in by the caller when they\ninstantiate the sub-flow. Let’s convert our flow to a sub-flow in file “_vreg.rb”: # program/_vreg.rb Flow .create do |options|\n\n log \" Vreg test module \" func :vreg_functional , softbin : 101 para :vreg_meas , softbin : 105 , lo : 1.12 , hi : 1.34 # Don't build this test if the target DUT has the bug unless $dut .has_bug?( :vreg_pad )\n para :vreg_meas , vdd : :min , softbin : 105 , load : 5 .mA, lo : 1.10 , hi : 1.34 end # Continue on fail if the target DUT has the bug para :vreg_meas , vdd : :max , softbin : 105 , load : 5 .mA, lo : 1.12 , hi : 1.34 , continue : $dut .has_bug?( :vreg_pad ) end Not much has changed so far - the environment option has been removed from the Flow.create definition since that is more of a top-level concern, and the options have been added. There are a couple of opportunities for improvement here: The flow allows the loaded tests to be skipped, however it would be better if the sub-flow\ndid not define the conditions under which they should be skipped - that decision should be\nmade by to the top-level. If this test is going to be instantiated multiple times it will need some kind of index\nto target the test at vreg 0 or vreg 1. Here is the flow with these modifications: # program/_vreg.rb Flow .create do |options| # These are the option defaults that will be used unless specified by the caller options = { include_loaded_output_tests : true , index : 0 ,\n }.merge(options)\n\n log \" Vreg test module \" func :vreg_functional , softbin : 101 , index : options[ :index ]\n\n para :vreg_meas , softbin : 105 , lo : 1.12 , hi : 1.34 , index : options[ :index ] if options[ :include_loaded_output_tests ]\n\n para :vreg_meas , vdd : :min , softbin : 105 , load : 5 .mA, lo : 1.10 , hi : 1.34 , index : options[ :index ]\n\n para :vreg_meas , vdd : :max , softbin : 105 , load : 5 .mA, lo : 1.12 , hi : 1.34 , index : options[ :index ] end end For now we have not really committed to how the indexed tests will be generated, but we have\npassed the information along to the interface. Most likely when it comes to generating the\npattern name within the interface we will just append the index to the name. So the original top-level flow is now really simple: # program/probe.rb Flow .create( environment : :probe ) do import \" vreg \" , include_loaded_output_tests : ! $dut .has_bug?( :vreg_pad ) end The path argument supplied to the import method can be either a relative path from the\ncurrent file (as it is above), for example \"../components/vreg\" , or an\nabsolute path such as \"#{Origen.root}/program/components/vreg\" . In both cases\nthe underscore prefix is not required. The original reason for doing this was to add support for testing multiple\nvreg instances. To support such a case let’s say that our DUT model will implement a\nmethod called vregs which will return one or more vreg models wrapped\nin an array. Our final flow is: # program/probe.rb Flow .create( environment : :probe ) do $dut .vregs.each_with_index do |vreg, i|\n\n import \" vreg \" , include_loaded_output_tests : ! $dut .has_bug?( :vreg_pad ), index : i end end Documenting Tests All of the test attributes will be available later when it comes to generating documentation\nof the test program, so there is no need to document them manually.\nHowever in some cases it will also be useful to include some\ntext describing perhaps how the test works, or why it is being done.\nSuch information can be added via regular Ruby comments immediately before the given\ntest. Origen will extract these later when it comes to generating documentation. The comments will be parsed as Markdown so this can be used to make things like bulleted lists or tables. Here is our vreg test suite with some example documentation added: # program/_vreg.rb Flow .create do |options| # These are the option defaults that will be used unless specified by the caller options = { include_loaded_output_tests : true , index : 0 ,\n }.merge(options)\n\n log \" Vreg test module \" # This test verifies that the following things work: # # * The vreg can be disabled # * The trim register can be written to and read from func :vreg_functional , softbin : 101 , index : options[ :index ] # Measure the output of the vreg under no load, this is a simple # test to catch any gross defects that prevent the vreg from working para :vreg_meas , softbin : 105 , lo : 1.12 , hi : 1.34 , index : options[ :index ] if options[ :include_loaded_output_tests ] # Measure the output of the vreg under the given load, this is approximately # equivalent to 1.5x the maximum load anticipated in a customer application. para :vreg_meas , vdd : :min , softbin : 105 , load : 5 .mA, lo : 1.10 , hi : 1.34 , index : options[ :index ] # As above para :vreg_meas , vdd : :max , softbin : 105 , load : 5 .mA, lo : 1.12 , hi : 1.34 , index : options[ :index ] end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/generating/": {
    "title": "Running the ProgGen",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator Running the ProgGen The program generator is launched via the Origen generate command, see the command line\nhelp to get details of the most up to date options: origen program -h As this is such a commonly used command it has a short cut alias: origen p -h The generator can be run on a single file: origen p program/probe/sort1.rb or it can be run on a whole directory: origen p program/probe Program list files can also be used, by convention these should be kept in the list directory\nand should have the extension .list : origen p list/program/production.list Here is an example of a list file: # List files can be commented like this\n# Simply list the name of the files that you would use on the command line\nprogram/probe/sort1.rb\nprogram/probe/sort2.rb\n# List files can also call other lists\nft.list The generated files will be put in whatever directory\nis returned by the config.test_program_output_directory attribute in application.rb . Submit to the LSF by appending -l and optionally interactively\nwait for completion: origen p list/program/production.list -l -w Regression Testing Everytime Origen generates a file it will check to see if it has generated it before, and\nif so it will compare the current version to the previous version and alert if there is a\ndifference. This can be used to check for regressions when making changes that you don’t want\nto affect the output, or to verify that the change is what you intended in cases where you\nare intentionally modifying the output. The diff is a smart diff and will not care about any changes to comments, only about changes\nthat will affect the file’s operation. In the case of a difference being found Origen will automatically present you with the diff command\nto run if you want to view the change. To accept changes or to start tracking the differences in a file (or files) run the following command\nafter generating: origen save all Programatically Launching the Generator If you start writing your own commands you may want\nto launch the generator from Ruby, do that as follows: Origen .app.runner.launch action : :program , files : \" list/program/production.list \" This can be combined with Target Loops to run the\ngenerator for multiple targets. A generate job can also be posted to the LSF by supplying the same options that you would use\non the command line like this: Origen .lsf.submit_origen_job( \" p program/probe/sort1.rb \" ) Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/interface/": {
    "title": "Creating an Interface",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator Creating an Interface To re-cap the purpose of an interface is to translate your behavioral\ndescription of the test flow into a test program for a specific ATE\nplatform.\nThis step is where most of the work comes in and interfaces can grow to\nbe quite large pieces of code depending on the complexity of your flow. An interface is a regular Ruby class which would be created in your lib\ndirectory.\nContinuing with the vreg example and assuming that all of our code was namespaced in the Vreg module,\nwe could create an initial interface like this: # lib/vreg/interface.rb module Vreg class Interface include OrigenTesters :: ProgramGenerators # The methods called by the flow files will be implemented here end end Required Methods For an interface to run it must implement all of the methods that will be called\nby your flow.\nIt is also customary to create an initialize method that will capture any options\nthat are passed in to Flow.create (such as declaring the environment\nas probe in our flow example). Here is an interface shell to handle the test flow that we created in the previous\nsection: # lib/vreg/interface.rb module Vreg class Interface include OrigenTesters :: ProgramGenerators # Add a regular attribute to our interface to allow us to query the # execution environment attr_reader :environment # Any options passed to Flow.create can be captured here and assigned # to instance variables which can be used later to modify the output from # your other interface methods. def initialize (options={})\n options = { environment : :ft , # Set the environment to FT unless otherwise specified }.merge(options) @environment = options[ :environment ] end # Record the given message to the datalog def log (msg, options={}) end # Create a functional test and call it from the flow def func (name, options={}) end # Create a parametric test and call it from the flow def para (name, options={}) end end end Note that you do not need to define methods to handle the Flow Control API , the included generator\nmodule will already take care of those. At this point you can now generate your flow for the first time to make sure\nthat there are no methods missing: origen p path/to/your/flow.rb All being well this should run cleanly without actually generating any of your tests,\nif you get some errors your should be able to work out what methods need to be added to\nyour interface from the error messages. The contents of these methods will be discussed in the following platform-specific\nsection of the test program guide. Avoiding Duplicate Tests The astute reader may at this point note that the intention of the above methods\nis to both generate a test and to add it to the flow. Well how do we avoid duplicate\ntests from being generated if the same method is called multiple times within the same flow? The answer is that you don’t need to worry about this, Origen will take care of suppressing\nduplicate entries in things like a test instance or a test pattern file, depending on the\nneeds of the target platform.\nSo your interface does not need to keep track of details like whether a test has previously\nbeen generated or not. Just generate all the resources required to run a particular test\nevery time that your method is called and Origen will take care of optimizing it. When assessing whether or not a test already exists Origen does not simply just look at the\nname, all of the attributes of a particular test are considered as well. If a test of the\nsame name already exists but with different attributes then Origen will create a new test\nand apply a version of ‘_v1’ to the original test and ‘_v2’ to the new one. The flow will\ncall the correct version at the correct place as you would expect. Generally you should keep an eye on what is being generated and if you start to see\n‘v1’ or ‘v2’ tests being generated then it is a sign that your test naming\nconvention is not including some detail that is required to uniquely identify each test.\nSo while the program generated will be functionally correct, it will not be obvious to\na user of the test program what the difference is between ‘test_v1’ and ‘test_v2’.\nFor example say that your test name does not include the vdd, yet your flow generates the same\ntest to run at min, nom and max vdd. In that case Origen will generate these as versions\n1, 2 and 3.\nAdding the vdd to you test names would resolve this problem and the program would now\ninclude tests called ‘test_min’, ‘test_nom’ and ‘test_max’ which is much more\ndescriptive. If you are not comfortable with this approach for some reason and would prefer separate\ncontrol over test generation and flow insertion then Origen also supports a\na more traditional workflow where you can generate a library of tests and then call them\nfrom a separate flow definition.\nHow to do that is discussed in the Resources section.\nHowever the combined test generation and flow insertion is the recommended way and\nfully leverages Origen’s unique ability to completely generate a new test from adding a single\nline to the test flow (once you have an interface already setup). Additional Methods The interface can also define whatever additional methods it needs to help implement\nthe main flow API.\nIn this example, let’s just add the following method to help us generate the full\ntest names: # lib/vreg/interface.rb def namer (basename, options={})\n name = basename if options[ :vdd ] # In our world let's have the convention that if the vdd is not included in # the name then it is nominal, otherwise it will be in the name unless options[ :vdd ] == :nom name = \" #{ name } _ #{ options[ :vdd ] } \" end end name end In reality some interfaces can get quite complex, and breaking the code down to additional\nRuby class or modules is common. Re-using Interface Methods The interface, or portions of it, can be easily extracted to a plugin\nfor future use in another application. See the Origen Plugins section for details on how to do this. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/introduction/": {
    "title": "Introduction",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator Introduction Origen provides a powerful object-oriented test program generator which has a\nunique architecture which fully separates an application’s test flow logic\nfrom its implementation on a given test platform. This architecture offers many advantages but most notably: It is extremely efficient. Adding additional tests is very quick after you have\ninitially bootstrapped your program generator, in many cases only requiring\none line to be added to your source code. It keeps you sane. As test flows and programs get larger and larger it really\nhelps to be able to use object-oriented programming techniques to keep\neverything organized. It eliminates bugs. The architecture encourages you to write the least amount of\ncode possible to create a new test, this maximizes the re-use of working code\nand reduces the number of moving parts and opportunities for bugs to occur. It supports multi-platform and documentation. The same test flow source file\ncan be used to generate the program on different platforms, including\ncreating documentation of the test program. Dynamic custom code is supported. Custom VB/C++ code can be compiled through\nOrigen, this eliminates the need to keep DUT configuration information in your\ntest program code - write it to support a single device, then modify it later\nto work with another configuration with Origen. Architecture An overview of the program generator architecture is shown below: Origen provides a rich generator for each supported platform, this takes care of\nall formatting concerns and tries to automate some details of the platform API which\ncan be particularly error prone - for example flow control logic. The application then provides a Flow file which contains a behavioural description\nof each test and the order that they should be executed in. Note that there should be no consideration given to the underlying platform implementation\nof the test at this level , the job of the flow is to describe the electrical\nproperties of each test and pattern dependencies, but should not worry about things\nlike test instances, interpose functions, test methods, etc. The application must then provide an interface which has\nthe job of translating the flow definition to the one or more of the target test platform APIs.\nFor example the interface may say “ok when the flow asks\nfor a functional test then create a new patset, create a new functional test instance\nwhich will reference that patset, setup the instance based on the electrical\nproperties of the test, and then finally add an entry in the flow sheet”. In this way the tedium of having to create a test instance, then a pattern set, then\na flow entry, then go back to the test instance because you named the pattern set\nwrong, etc, etc…is eliminated along with many opportunities for errors. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/j750/": {
    "title": "J750 API",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator J750 API Be sure to read and understand the guide to Creating an Interface before\nreading this section.\nThis guide will describe the API to generate J750/IG-XL test program \ncomponents from within an interface file. To re-cap this is the shell required to implement an interface: # lib/vreg/interface.rb module Vreg class Interface include OrigenTesters :: ProgramGenerators # An example method that can be called from your test flow to generate a functional test def func (name, options={}) # If your interface supports multiple platforms, add conditional logic like this, if you # only ever want to support one platform then you don't need this if tester.j750? # Functional test implementation for J750 elsif tester.v93k? # Functional test implementation for V93K end end end end The OrigenTesters::ProgramGenerators will provide the interface\nwith access to all of the platform generator APIs for the platforms that it supports. If your interface supports multiple platforms then add conditional logic to separate\nthem as shown above. Creating a Test Instance When generating a J750 program most of the effort is in generating the test\ninstances. To start with the basic method of creating and decorating test instance\nobjects will be discussed and then at the end of this section some recommendations\nwill be given on how to structure your test instance generation methods. The method test_instances returns an instance of OrigenTesters::IGXLBasedTester::J750::TestInstances which provides additional\nmethods to generate new test instances.\nThe API should be consulted for the most up to date information on the methods available. A new test instance can be instantiated like this: test_instances.add( :vreg_func , :functional ) This one line of code does a lot of things: Creates a new test instance sheet if one doesn’t exist already Instantiates a new test instance object Sets its name to ‘vreg_func’ Applies the default attributes for a J750 functional test instance\n(basically the same attributes that would be present when you added a new functional\ntest instance within IG-XL) Adds the new test instance to the test instance sheet If you were to add that line and generate your program you would now get\na test instance sheet generated with a single functional test instance in it\ncalled ‘vreg_func’. Not bad. Convenience methods exist where you can call a method named after the type of the test instance,\nthis is equivalent: test_instances.functional( :vreg_func ) You will of course want to decorate your new test instance with attributes that are specific\nto your application, to do that you simply assign the returned instance to a variable and\nthen you can programmatically set the attributes that you want.\nFor example: ins = test_instances.functional( :vreg_func )\nins.ac_category = \" Spec \" ins.ac_selector = \" Default \" ins.time_sets = \" Tim \" ins.pin_levels = \" Lvl \" The name of these methods is the underscored (to align with general Ruby conventions)\nversion of the name in the IG-XL columns headers and they should hopefully be very\nintuitive. Note that you don’t need to do anything here to save or push the instance into the sheet,\nthis will all be done automatically. Attributes can also be passed in when instantiating the new instance, this is equivalent\nif you prefer: ins = test_instances.functional :vreg_func , ac_category : \" Spec \" , ac_selector : \" Default \" , time_sets : \" Tim \" , pin_levels : \" Lvl \" Instance Type Specific Attributes Additional methods will be available depending on the instance type that you\nspecified.\nFor example in our functional instance we can set the pattern and call a pre-test\ninterpose function like this: ins.pattern = \" vreg_functional \" ins.pre_test_func = \" someInterposeFunc \" Again the method names should hopefully be intuitive and should correspond to\nthe IG-XL names. To see what the method names are called refer to the TEST_INSTANCE_ALIASES constant\ndefinition at the top of the J750 TestInstance API . Supported Test Instance Types Currently supported test instance types are (although check the API for the latest\ninformation): functional board_pmu (bpmu) pin_pmu (ppmu) other empty If you need a different type you can still call the add method, the difference in the\nreturned instance for an unrecognized type is: The instance will be completely empty and all attributes will need to be\nadded by your application code. The named attribute methods will not be available. The latter means that instead of using convenience methods to set the attributes you\nwill need to use argX format instead, where argX corresponds to the column name\nin IG-XL. So the previous example of adding a pattern and interpose function call to our functional\ninstance could be re-written as shown below: ins.arg0 = \" vreg_functional \" ins.arg3 = \" someInterposeFunc \" You would also need to configure the basic attributes such as the template type and name.\nTo get an idea of what is required refer to the TEST_INSTANCE_DEFAULTS constant\ndefinition near the top of the J750 TestInstance API . If you do find yourself in this situation please get in touch via the community channels and\nwe can quickly work with you to add the new instance type to Origen, then the names attribute\nmethods will be available for everyone. What Are the Defaults? Generally the test instance defaults should match exactly what you get from IG-XL (that is\nthe intention at least). To see what the defaults are for a given test instance type refer to the TEST_INSTANCE_DEFAULTS constant\ndefinition near the top of the J750 TestInstance API . Helper Methods A number of helper methods are available to make test instance generation easier. A good example is setting the current range of a parametric test instance where the value\nstored in the IG-XL workbook is not at all intuitive and bears little resemblance to the numeric\nrange value that it represents.\nA set_irange method is available to help, here are some examples: ins.set_irange( :smart )\nins.set_irange( ua : 2 )\nins.set_irange( 2 .uA) # Same as above ins.set_irange( ma : 200 )\nins.set_irange( 0.2 ) # Same as above ins.set_irange( a : 0.2 ) # Same as above A useful pattern when using this method is just to set the range to the test upper\nspec limit, Origen will then take care of rounding this to the correct range. See the J750 TestInstance API for details on the currently available helper methods. If you have a good helper method in your application that you think would be a\nuseful addition to Origen please do create a pull request with the additions to the Origen Testers plugin . Avoiding Duplicate Test Instances Your interface does not need to keep track of duplicate instances, Origen will automatically\nget rid of them.\nSee the discussion “Avoiding Duplicate Tests” in the Creating an Interface guide. A Note on Test Instance Groups IG-XL has the concept of a test instance group, that is a group of test instances that\nyou can call from a single line in the test flow. However the syntax for this in the test instance\nsheet does not lend itself to easy generation - \nthat is a test instance with the same name as an existing one will be treated as a group if\nthey occur next to each other, whereas it will be a validation error if they are apart.\nThis poses some problems for Origen when it comes to test instance generation - how does it\nknow when the instance your application has requested is a duplicate that should be screened\nvs. an intentional generation of a group? To avoid pushing responsibility of duplicate tracking to the application there is a dedicated\nmethod for generating groups. Any instances generated within the given block of code will\nbe treated as a group: test_instances.group( \" vreg_func_all \" ) do |group| $dut .vregs.each_with_index do |vreg, i|\n test_instances.functional( \" vreg_func \" ) end end See the group method API for more details and examples. Structuring Your Instance Methods As mentioned at the start the vast majority of your J750 interface code will be concerned\nwith generating test instances, so it pays to spend a bit of time up front thinking about\nhow to organize this code into a maintainable architecture. The following techniques have proved to be useful in organizing the test instance generation\nfor some very large and complex test flows. Create Base Instances Add methods to create base test instances, that is\ntest instances which contains all of the attributes that every instance in your\napplication will have. def base_instance (name, type, options={})\n ins = test_instances.add(name, type)\n ins.dc_category = \" VREG \" if options[ :vdd ]\n ins.dc_selector = options[ :vdd ].to_s.capitalize # If :min, :max for example else ins.dc_selector = \" Typ \" end ins.ac_category = \" Spec \" ins.ac_selector = \" Default \" ins.time_sets = \" Tim \" ins.pin_levels = \" Lvl \" ins # Remember to return the newly created instance object to the caller end def func (name, options={})\n ins = base_instance(name, :functional , options) # Additional functional specific configuration here end This pattern can be extended to provide additional methods like “base_functional_instance”, \n“base_bpmu_instance” and so on. Use Decorator Methods A decorator method is a method that decorates (or adds to) a test instance with specific\nfunctionality.\nFor example in the flagship Origen application, some of our functional test instances required match\nloop support while others did not, so we created a decorator that we could call to add\nthis feature: def add_match (ins)\n ins.post_test_f = \" MatchBinFails \" ins.pat_flag_f = \" MatchLoopPatFlagFunc \" ins.set_wait_flags :a end def func (name, options={})\n ins = base_instance(name, :functional , options)\n ins.add_match(ins) if some_logic_to_gate_this end Split Your Application Instances into Logical Groups In the flagship application we found it best to conceptually split our test instance\ngenerators by application-specific types rather than by sticking to the IG-XL types\nlike functional, BPMU, PPMU, etc. It is hard to give a universal example here since this area is so application specific,\nbut to hopefully give you some food for thought… In the flagship application we had a lot of parametric tests and initially we went down the\npath of having an instance generation method for all BPMU tests and one for all PPMU tests.\nHowever within those groups some of the tests were very different and it led to a\nlot of complexity within those methods. When we took a step back and looked at our application our tests were not really split into\n2 types, rather they were comprised of 4 types - a high-voltage measurement, a high-voltage\ncalibration, a low-voltage measurement and a low-voltage calibration.\nWhen we continued this process through our test flow as a whole we ended up with 14 different\ntest classifications and we then added a method dedicated to generating the test instance\nfor each one. You should probably not go down this path initially, but once you get a feel for the\ngeneration process and if your interface is starting to get complex, then this is a step\nto consider. Creating a Pattern Entry The hard part is over, creating pattern sets and groups is trivial by comparison to\ncreating test instances.\nA similar API is provided to generate pattern resources in your test program and a nice\nby product is that Origen will keep track of the referenced patterns and will produce a required\nlist of patterns at the end (which you can then pass to the pattern generator). As with test instance generation Origen will deal with the suppression of duplicates in all\ncases. To add a pattern set call as follows: patsets.add( \" vreg_func_pset \" , pattern : \" patterns/VREG/vreg_func.PAT \" ) Multiple patterns can be specified by passing an array as the 2nd argument: patsets.add( \" vreg_func_pset \" , [{ pattern : \" patterns/VREG/vreg_func.PAT \" },\n { pattern : \" patterns/VREG/vreg_global_subs.PAT \" , start_label : \" subr \" }\n ]) Creating pattern groups is identical, just substitute patsets with patgroups . Normally you would create a dedicated method for creating pattern sets to avoid\nduplication, something like this: def add_patset (name)\n patsets.add( \" #{ name } _pset \" , pattern : \" patterns/VREG/ #{ name } .PAT \" ) end The pattern set or group object can be assigned to the pattern attribute of a test\ninstance directly: def func (name, options={})\n ins = test_instances.functional(name)\n ins.pattern = add_patset(name) end If you just want to add a pattern reference outside of a pattern set or group then\nadd it to the referenced_patterns array to ensure that it gets added\nto the list of required patterns that is output from the program generation process: referenced_patterns << \" some_vreg_pattern \" Creating a Flow Entry Within your interface the flow method will return an instance of\nthe J750 flow generator which provides methods for adding tests and other entries\nto your test flow. See the API for full details. So for example to enter a log print statement in the flow you can call: flow.logprint \" Start of the vreg test section \" Going back to the earlier example from the Creating Flows guide we had this in our flow: log \" Vreg test module \" This is probably the simplest method to implement in our interface: def log (msg)\n flow.logprint(msg) end The most common call will be to the test method which will insert a call\nto a test instance in the flow. Note that it is recommended that you pass all options from the test flow into any flow methods,\nthis ensures that any flow control logic will get implemented . Here is a complete interface method for the first time that will generate a test instance,\nadd a pattern set reference to it, and now finally call the instance from the\ntest flow: def func (name, options={})\n ins = test_instances.functional(name)\n ins.pattern = add_patset(name)\n flow.test(ins, options) end The object returned from flow.test is an instance of OrigenTesters::IGXLBasedTester::J750::FlowLine and this does provide a few methods that may be of use. However in general most of the\nmethods are there to support flow control and it is not recommended that you use these\ndirectly, rather use the flow control API to\ndo this. However it is recommended that you look at the TESTER_FLOWLINE_ATTRS , ALIASES ,\nand DEFAULTS definitions as this will tell you what the generator calls the IG-XL attributes. For example you can\nsee that the test number attribute is called tnum and that this is also aliased\nto 'number' . This means that you can set this attribute via this style (which is most useful\nfor passing attributes through directly from the flow file): flow.test(ins, tnum : 10000 ) Or it can also be set via a method call: flow_line = flow.test(ins)\nflow_line.tnum = 10000 It is recommended that you create a dedicated method for flow insertion as this gives you\na single place to implement defaults and to perform any translation between what the flow has\ncalled an attribute and what the J750 generator would call it: def add_flow_entry (ins, options) # Defaults options = { bin : 5 , tname : options[ :tname ] || options[ :name ] || ins.name,\n }.merge(options) # Some translations options[ :softbin ] = options[ :sbin ] if options[ :sbin ] # Add the flow entry flow_line = flow.test(ins, options) # Some final decoration flow_line.continue_on_fail if options[ :continue ]\n\n flow_line end Here is an example interface method using this add to flow method: def func (name, options={})\n ins = test_instances.functional(name, options)\n ins.pattern = add_patset(name)\n add_flow_entry(ins, options) end Finally you may on occasion wish to call a test from your flow where the instance\nis not available - maybe the instance is generated by another test module for example.\nIn this case the :instance_not_available option can be set to true to prevent Origen from trying to match up the flow with an instance object. flow.test( \" POR_INSTANCE \" , instance_not_available : true ) What About My DC Specs? Other IG-XL sheets do not currently have generators available, although that is likely\nto change in the future. For now though the existing Origen-based applications have found that the other sheets tend\nto be simple enough that they can be easily handled via a template-based approach. To create a template simply build the sheet in IG-XL, export it to ASCII and this becomes\nyour initial template, then add Ruby snippets as required to make parts of it dynamic. See the Dynamic Custom Code guide for more details\non how to compile a template automatically during a program generation process. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/philosophy/": {
    "title": "Philosophy",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator Philosophy Documentation of a test program is important to allow non-test-engineering stakeholders\nto understand what is in a given program, or what a given bin number refers to.\nSo Origen fully embraces the notion that test programs should be documented, that\nthis documentation should not have an opportunity to be wrong, and that no one\nshould have to waste their time manually trying to keep a document and the program\nin sync. However many tools in this area approach this\nproblem by trying to turn documentation into a test program.\nOrigen turns this problem on its head and unashamedly asserts that the test program\nitself is the true source of authority as to what it does, and that documentation\nis the follower instead of the leader. This approach has the following advantages: Test programs are large and complex, who really wants to write the whole thing\nout manually? It is much more efficient (and less error prone) to write it in code,\nthen we can use subroutines, variables, object-orientation, meta-programming (code\nthat generates other code) and any other programming\ntechniques to eliminate duplication and opportunities for error. Document first approaches are always constrained by the fact that some tests are\nmore complicated than others. In a recent industry conference a leading document-first\ngenerator stated that typically it could handle 80% of tests, for the other 20%\nyou were on your own. With Origen’s approach 100% of your tests will be generated. The Chicken and the Egg Problem One problem with the Origen approach is how do you bootstrap a new program, intuitively\nyou may want to document it first. This problem can be solved via the following workflow: The Flow file syntax is designed to be as simple and human-readable as possible,\nand it is self contained and can exist long before any interfaces are ever written.\nTherefore it you know enough to be able to write a document of a flow, then you\nknow enough to be able to write an Origen flow file for that flow. Nonetheless some early stakeholders may want to get involved in the definition \nbut won’t feel comfortable with the code layer. In this case it is recommended\nthat you immediately setup a documentation interface (these are trivially simple\nand will probably eventually come from free with Origen), and begin generating\ndocumentation of the flow from day 1. Definition can continue as required by iterating on the flow file, all the while\nthe documentation stays in sync. When it comes to finally implementing the flow the test engineering team will\ncreate the interface which will turn it into a real test program. An alternative approach is to have a short-lived hand-written document that is used\nto get the team up to the first release of the test program. At that point authority\nshould switch to the program itself and a ticketing system should be used to iterate on\nthe program… How Do I Specify a Program Change if I Don’t Know How to Code? The underlying program application should use a ticketing system.\nAny non-test-engineering stake holders can review the documentation to see what the test program\ncurrently does, then if they want it to do something else they will raise a ticket\nrequesting it. Once the change has been implemented the ticket can be closed and the documentation\nwill automatically pick up the change. This workflow is much easier to monitor and track status vs. the alternative approach where\nthe non-technical stakeholder release new versions of a document and the TE has the job of trying\nto keep the program in sync. But I already have a document containing a lot of my test details! As the flow file is written in Ruby, it is perfectly feasible to build higher level structures\nsuch as an importer, or even a spreadsheet-based interface on top of this. The early users of the Origen test program generator have not had a need for such an approach,\nhowever this is definitely an area where the community could start\nto build new features. Shouldn’t a Program Generator build me a complete test? It’s Origen’s job to provide a solid generation platform, however it deliberately does not\ntry to dictate how a functional/parametric/bitmap/ATD ramp/etc. test should be set up.\nFirstly the scope of such an effort is too large, but secondly the Origen developers do\nnot necessarily have the knowledge required to dictate what is the best practice\nin a lot of these areas. However the idea of eliminating the interface layer is appealing and the good news is\nthat it is achievable. The Origen Plugins feature provides a way\nfor Origen code to be easily packaged into a re-usable plugin and shared between projects. So for\nexample, an ATD interface module could be written and then anyone wishing to create ATD\ntests, could import this into their application and completely bypass the interface\ncreation step altogether. Just call the interface methods from the flow file and you will get a\nguaranteed working (and hopefully efficient!) ATD test. If you are a test expert in a given area, and you are using Origen to generate your program,\nthen we would encourage you to share your expertize by making your test setups available\nas an Origen plugin. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/resources/": {
    "title": "Additional Resources",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator Additional Resources When generating a complete test program it may be necessary to build some components\nthat don’t naturally fall out of the regular flow generation.\nSome examples of this might be: Creating a test which does not have a flow entry, but perhaps you want to keep it\navailable in your program for engineering use. Creating a test program sheet or file that is not supported by an Origen generator,\ne.g. the IG-XL DC Specs sheet does not currently have a generator. Creating custom VB, C++ or similar code to support your tests. All of these goals can be fulfilled by using a Resources file. Resources files are\nvery similar to the Flow files that we have already seen, the main difference is that\nany flow entries generated within a Resources file will automatically be inhibited. This makes generating tests and their resources (e.g. pattern sets, etc.) without a flow\nentry extremely easy - just use the same code that you would normally use in the Flow\nfile and you will automatically get everything needed for the test without the flow\nentry. Resource files are syntactically equivalent to Flow files except that all references to Flow are replaced by Resources : # program/probe_resources.rb Resources .create do end So for example without changing our interface at all we can drop some of our previous\nFlow code into the resources file (flow specific attributes such as bin numbers can\nbe removed): # program/probe_resources.rb Resources .create do func :vreg_functional para :vreg_meas , lo : 1.12 , hi : 1.34 end This would generate the same program as before but with no flow entries for the generated\ntests. Parameterizable sub-resource files can be created in exactly the same way as sub-flow files. Compiling Templates Another common use case for a Resources file is to co-ordinate the compilation of template\nfiles. See the Compiler section for details on\nhow to create templates. A compile method is available with a Resources file to invoke and customize\nthe compilation of a specific file. Any arguments passed in will be accessible within the\ntemplate via its options method. # program/common_resources.rb Resources .create do compile \" templates/j750/DCSpecs.txt \" , max_vdd : 5 .V\n\n compile \" templates/j750/GlobalSpecs.txt \" , vreg_period : 40 .ns end Separating Test Generation from Flow Generation As discussed previously a conventional Origen program generation flow would be to generate\nboth the flow and the tests from a single flow file. However it is also possible to\ngenerate the program in a more traditional way where the test and flow generation are\nseparated. To do this use Resources files to generate the tests and all of their dependencies. This\nwould look very much like the flow file examples we have seen so far, the main difference\nwould be that each test would only ever appear once (although if you did generate duplicates\nby accident Origen would still take care of it). Then to define the flow you would have Flow files that called interface methods to insert\nflow entries only.\nThis flow file would be a simplified version of what we have seen so far since the\nattributes of the test are no longer required.\nFor example you might make a new interface method called ‘test’ which calls a test\nin the flow - at flow level there is no longer any conceptual difference between\na parametric test and a functional test and so they can all use the same method.\nHere is a previous example that only contains the flow concerns (includes ‘cz’ and\n‘bin_out’ methods since these are also flow level concerns): Flow .create do test :vreg_meas , softbin : 105 , id : :vreg_meas_1 if_failed :vreg_meas_1 do # Automatically characterize the vreg if the measurement fails cz :vreg_meas , softbin : 107 # Then bin out bin_out softbin : 105 end # Check if the HVST has already been run on this device test :rd_vreg_hvst_passcode , softbin : 50 , id : :vreg_hvst_done unless_passed :vreg_hvst_done do # If not run it test :vreg_hvst , softbin : 101 # And program the flag for next time test :pgm_vreg_hvst_passcode , softbin : 51 end end If you want to use the same methods in the Resources and Flow files you can use the resources_mode? method within your interface to control when the flow\nor the tests should be generated. This method will return true if the interface method\nhas been called from a Resources file: # lib/vreg/interface.rb # Create a functional test and call it from the flow def func (name, options={})\n name = namer(name, options) if resources_mode? # generate the test else # generate the flow entry end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/ultraflex/": {
    "title": "UltraFLEX API",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator UltraFLEX API Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/v93k/": {
    "title": "V93K API",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator V93K API Flow Considerations By default, a top-level Flow.create call in Origen will generate a standalone V93K testflow file which is\ninternally wrapped by a flow group, like this: group <FLOW_NAME> {\n // Flow content here\n} When such flows are imported into a master flow file, SmarTest does not provide a standard enable mechanism\nto control which sub-flows are executed. However, Origen provides the ability to generate V93K flow modules with an enable-word wrapper, thereby allowing\nthe top-level flow to easily enable/disable the execution of flow modules via flow variables. By enabling this feature in the target like this: OrigenTesters :: V93K .new( add_flow_enable : :enabled ) the flow will now generate like this: group <FLOW_NAME> {\n if @<FLOW_NAME>_ENABLE == 1 {\n // Flow content here\n }\n} The @<FLOW_NAME>_ENABLE variable will be initialized to 1 in the generated variables file for the given flow,\nmeaning that the module will run by default if the top-level flow does nothing with this variable. Alternatively, the variable can be initialized to off like this: OrigenTesters :: V93K .new( add_flow_enable : :disabled ) Meaning that by default, the module will not run and the top-level flow must always enable it by including @<FLOW_NAME>_ENABLE = 1 before hitting the module. Setting this attribute in the target means that it will apply to all flows. Alternatively, it can be set within\nthe flow itself (or the interface) if it is necessary to use this feature for only a subset of flows, or to override\nthe default setting for a particular flow. Here is an example: Flow .create interface : ' MyApp::Interface ' do # Ensure that this flow is always generated with an enable word wrapper that is enabled by default self .add_flow_enable = :enabled # Some functional test func :blah end This same API may be used to implement similar features on other platforms in future, but for now only the V93K is implemented. Interface Considerations Be sure to read and understand the guide to Creating an Interface before\nreading this section.\nThis guide will describe the API to generate V93K/SmarTest test program \ncomponents from within an interface file. To re-cap this is the shell required to implement an interface: # lib/vreg/interface.rb module Vreg class Interface include OrigenTesters :: ProgramGenerators # An example method that can be called from your test flow to generate a functional test def func (name, options={}) # If your interface supports multiple platforms, add conditional logic like this, if you # only ever want to support one platform then you don't need this if tester.j750? # Functional test implementation for J750 elsif tester.v93k? # Functional test implementation for V93K end end end end The OrigenTesters::ProgramGenerators will provide the interface\nwith access to all of the platform generator APIs for the platforms that it supports. If your interface supports multiple platforms then add conditional logic to separate\nthem as shown above. Creating a Test Suite Most of the effort in generating a V93K test program is in generating the test suites and their\nassociated test methods. A new test suite and test method can be instantiated and linked together like this: t = test_suites.add( :vreg_func )\nt.test_method = test_methods.origen.functional_test These lines of code do the following things: Instantiates a new test suite object and assigns it to the local variable t Sets its name to ‘vreg_func’ and inserts it into the flow file (but not into the actual test flow) Instantiates a new functional test method object and attaches it to the test suite Inserts the test method into the flow file (but not into the actual test flow) You will of course want to then decorate your new test with attributes that are specific\nto your application, here for example to set the levels and timing: t.tim_equ_set = 15 t.tim_spec_set = 1 t.timset = 1 t.lev_equ_set = 20 t.lev_spec_set = 8 t.levset = 1 If the test method provides parameters, you can set them in the same way. As a convenience,\nOrigen will automatically work out whether the reference is to a parameter of the test suite\nor of the test method, and will assign it accordingly.\nFor example, let’s say this functional test method had a parameter named checkShutdown , you\ncould set that like this: t.check_shutdown = 1 # By Ruby convention, use the lower-cased underscored version of the C++ name # The above is a shorthand equivalent to: t.test_method.check_shutdown = 1 Attributes can also be passed in when instantiating the new test suite/method, this is equivalent\nif you prefer: t = test_suites.add(:vreg_func, tim_equ_set: 15, tim_spec_set: 1, timset: 1, lev_equ_set: 20)\nt.test_method = test_methods.origen.functional_test(check_shutdown: 1) Limits The limits can be set for all test objects using the following API, see here for some examples of the available unit helpers : t.lo_limit = 100 .uA\nt.hi_limit = 150 .uA Built-in Test Methods SmarTest comes with a standard AC and DC test method library and Origen provides a built-in API to\ngenerate a test flow which uses those test methods, here are some examples: # Execute a functional test test_method = test_methods.ac_tml.ac_test.functional_test # A basic DC voltage measurement test_method = test_methods.dc_tml.dc_test.general_pmu force_mode : ' CURR ' , force_value : 100 .uA Generally the parameter naming is the lower-cased and underscored version of the name that appears\nin the SMT documentation. See the DC library API and the AC library API for up-to-date details of the implemented test methods and the parameter names. However, some of these test methods are not particularly good and the recommendation from Advantest these\ndays is generally not to use them. Since that means there is now a void where a universally available test method library should be, work is\nunderway to provide an Origen standard test method library.\nThe aim of this is to provide a complete generation solution from Origen so that those who have\na fairly conventional use case can rapidly build a complete test program from off-the-shelf\ncomponents, but that is still a work in progress and not yet ready for prime time use. Many users of the V93K program generator however, are likely to want to use it in combination\nwith their own custom test method library… Custom Test Methods An API exists to define the naming and parameter signature of test methods provided by\na 3rd party library, enabling them to be used within an interface exactly like in the examples above.\nAdditionally, it is possible to define helper methods that are associated with each test method,\nmaking them easier to use within an Origen test program interface. This is best shown by example, here is how to define a custom test method library and a custom\ntest method within an Origen interface: # lib/vreg/interface.rb module Vreg class Interface include OrigenTesters :: ProgramGenerators def initialize (options={})\n add_my_tml if tester.v93k? end # Define the test methods from a custom V93K library def add_my_tml # The identifier you give here is what you will use to access the test methods from your interface # code, for example: test_methods.my_tml.my_test # # This will also be the C++ namespace that is used within SMT to access the test method classes # defined in this library. add_tml :my_tml , # [OPTIONAL] If you need the C++ namespace to be different to the above identifier then you can # specify the C++ name like this: class_name : ' MyTmlNamespace ' , # Here is a test definition. # The identifier should be lower-cased and underscored, in-keeping with Ruby naming conventions. # By default the class name will be the camel-cased version of this identifier, so 'myTest' in # this case. my_test : { # [OPTIONAL] The C++ test method class name can be overridden from the default like this: class_name : ' MyTestClass ' , # Parameters can be defined with an underscored symbol as the name, this can be used # if the C++ implementation follows the standard V93K convention of calling the attribute # the camel cased version, starting with a lower-cased letter, i.e. 'testerState' in this # first example. # The attribute definition has two required parameters, the type and the default value. # The type can be :string, :current, :voltage, :time, :frequency, or :integer pin_list : [ :string , ' ' ], samples : [ :integer , 1 ], precharge_voltage : [ :voltage , 0 ], settling_time : [ :time , 0 ], # An optional parameter that sets the limits name in the 'testmethodlimits' section # of the generated .tf file. Defaults to 'Functional' if not provided. test_name : [ :string , ' SpecSearch ' ] # An optional 3rd parameter can be supplied to provide an array of allowed values. If supplied, # Origen will raise an error upon an attempt to set it to an unlisted value. tester_state : [ :string , ' CONNECTED ' , %w( CONNECTED UNCHANGED DISCONNECTED ) ], force_mode : [ :string , ' VOLT ' , %w( VOLT CURR ) ], # The name of another parameter can be supplied as the type argument, meaning that the type # here will be either :current or :voltage depending on the value of :force_mode force_value : [ :force_mode , 3800 .mV], # In cases where the C++ library has deviated from standard attribute naming conventions # (camel-cased with lower cased first character), the absolute attribute name can be given # as a string. # The Origen accessor for these will be the underscored version, with '.' characters # converted to underscores e.g. tm.an_unusual_name ' An.UnusualName ' => [ :string , ' NO ' , %w( NO YES ) ], # Attribute aliases can be defined like this: aliases : { my_name : ' An.UnusualName ' , precharge : :precharge_voltage ,\n }, # Define any methods you want the test method to have methods : { # If you define a method called 'finalize', it will be called automatically before the test # method is finally rendered, making it a good place to do any last minute attribute # manipulation based on the final values that have been set by the user. # The test method object itself will be passed in as an argument. # # In this example it will set the pre-charge if it has not already been set and a voltage is # being forced above a given threshold. finalize : -> (tm) { if tm.force_mode == ' VOLT ' && tm.precharge_voltage == 0 && tm.force_value > 3.5 .V # Set the pre-charge level to 1V below the force value tm.precharge_voltage = tm.force_value - 1 .V end }, # Example of a custom helper method, here to provide a single method to force a current and # which will configure multiple test method attributes. force_current : -> (tm, value) {\n tm.force_mode = ' CURR ' tm.force_value = value\n },\n }\n }, my_other_test : { # Define another test in exactly the same way... } end end end Here is an example of how the above definition might be used with test program interface logic: # An example method that can be called from your test flow to generate a DC measurement test like this: # # measure :vreg, force: 10.uA, lo_limit: 1.25, hi_limit: 1.75 # # measure :iref, force: 1.2.V, lo_limit: 20.uA, hi_limit: 30.uA, type: :current def measure (name, options={})\n t = test_suites.add(name, options)\n t.test_method = test_methods.my_tml.my_test( pin_list : ' @ ' ) if options[ :type ] == :current # Force mode is 'VOLT' by default per the above definition t.force_value = options[ :force ] else # Here calling the helper method to configure the method for force current mode t.force_current(options[ :force ]) end end Distribute as a Plugin Commonly, a custom test method library will not be specific to any one test program application and\nit will be used by many test programs within a group or company.\nIn such a case, you don’t want to have the Origen definition of the given library be duplicated in all\nof your applications. Rather, it is preferable to develop and maintain the definition in a central place\nand then include it in all of the applications that wish to use the library. This can be easily achieved by wrapping the Origen definition in an Origen plugin . Here is an example of how to package a library definition for inclusion in a plugin: # lib/my_library.rb within the my_library plugin module MyLibrary # Define the test methods from a custom V93K library def add_my_library # The definition here is identical to the original example above add_tml :my_tml , # [OPTIONAL] If you need the C++ namespace to be different to the above identifier then you can # specify the C++ name like this: class_name : ' MyTmlNamespace ' , # Here is a test definition. # The identifier should be lower-cased and underscored, in-keeping with Ruby naming conventions. # By default the class name will be the camel-cased version of this identifier, so 'myTest' in # this case. my_test : { # ... end end # [OPTIONAL] You can also supply complete interface method definitions which use this library # An example method that can be called from your test flow to generate a DC measurement test like this: # # measure :vreg, force: 10.uA, lo_limit: 1.25, hi_limit: 1.75 # # measure :iref, force: 1.2.V, lo_limit: 20.uA, hi_limit: 30.uA, type: :current def measure (name, options={})\n t = test_suites.add(name, options)\n t.test_method = test_methods.my_tml.my_test( pin_list : ' @ ' ) if options[ :type ] == :current # Force mode is 'VOLT' by default per the above definition t.force_value = options[ :force ] else # Here calling the helper method to configure the method for force current mode t.force_current(options[ :force ]) end end end Then simply add the plugin to a given application, and it can be used within an interface like this: module MyApp class Interface include OrigenTesters :: ProgramGenerators include MyLibrary def initialize (options={})\n add_my_library end # You don't need to do anything here, and your flow will already support the measure method! # Some application-specific flow method that uses the library: def some_test (name, options = {})\n t = test_suites.add(name, options)\n t.test_method = test_methods.my_tml.my_other_test\n t.some_parameter = #... end end end For a more advanced integration which gets rid of the need to even call add_my_library , you\ncan refer to how the origen_std_lib interface integration works here . Test Name Uniqueness Test (suite) naming collisions can occur when importing multiple independent test flow modules into a\nV93K master flow file. To prevent that from ever occurring, Origen will generate and append a unique signature to the end of\nall test names by default, for example: t = test_suites.add( \" my_test_name \" , options)\n\nt.name # => \"my_test_name_E32ABE8\" Applications can override this default behavior by setting the corresponding test interface attribute, unique_test_names , to one of the following values: :signature - this is the default which will generate a unique signature as shown in the above example nil - no value will be appended to the test names at all :flowname - the name of the current top-level flow will be appended to all test names Setting this attribute to any other value will append that value directly to all test names This attribute can be set in the environment file when instantiating\nthe tester: OrigenTesters :: V93K .new unique_test_names : nil This provides a single place to control the behavior within a monolithic application architecture . However, under a distributed application architecture a given test flow module may be generated under a target/environment that is controlled by a 3rd party. In that case, it is recommended to either set it at the flow-level, which will override any setting set at the\nenvironment-level: # program/wt1_start.rb Flow .create interface : ' MyApp::Interface ' , unique_test_names : ' wt1 ' do end Or, it can be set directly within your interface logic which will take the highest precedence: # lib/my_app/interface.rb self .unique_test_names = :flowname Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/environment/": {
    "title": "Environment",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Environment All environments are defined by files that reside in the environment directory.\nEnvironments are regular Ruby files and they should be simply named: <identifier>.rb In a test engineering application where the environment is used to select the target test platform,\nthey are normally named after the tester, e.g. environment\n|-- j750.rb\n|-- uflex.rb\n|-- v93k.rb\n`-- jlink.rb Creating an Environment To create a new environment, simply create the file containing whatever Ruby code you need.\nThey are usually very concise and in a test engineering application would normally only instantiate the\ntarget tester driver, here are some examples: # environment/j750.rb $tester = OrigenTesters :: J750 .new # environment/v93k.rb $tester = OrigenTesters :: V93K .new # environment/jlink.rb $tester = OrigenDebuggers :: JLink .new If the given driver supports configuration options, then you may have some variations\nfor a given platform - e.g. j750_probe.rb to configure the driver slightly differently\nfor generating probe test patterns: # environment/j750_probe.rb $tester = OrigenTesters :: J750 .new $tester .available_power_supplies = 64 Setting a Default Environment A default environment can be defined that will be used withing a new workspace unless the user\nspecifies otherwise. This is not required and should only be added if it makes sense within the\ncontext of the application - i.e. you may choose not to have a default to avoid the situation where the user\nbuilds something without really understanding what configuration they are targeting. A default is specified by creating an environment file called environment/default.rb ,\ntypically this is a symbolic link to another environment file: ln -s environment/j750.rb environment/default.rb Getting and Setting the Environment The current environment for a given application workspace can be queried by running the origen environment command, or origen e for short, this will show\nyou the content of the current environment file: > origen e\n\nCurrent environment: j750.rb\n**********************************************************************\n $tester = OrigenTesters::J750.new\n********************************************************************** The environment can be changed by running the same command and supplying the desired environment: > origen e environment/j750.rb\n\n> origen e v93k As shown above, a full path or any snippet which is enough to uniquely identify one of the available\nenvironment files is sufficient. Additionally all Origen commands allow an override to be supplied at runtime: > origen g my_pattern -e jlink Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/global/": {
    "title": "Global Setup",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Global Setup Origen re-loads the runtime environment immediately before every pattern, test program or compile\njob.\nTherefore both the target and environment files can be used to set some global state that\nwill later be applied to all patterns or similar. Note that you cannot actually generate any output from the target or environment, that will only\nhappen from within the pattern, program or template source files. However what you\ncan do is setup some initial state within your models to influence what will\nbe generated by the source files later. In other words any changes that you make to the models after instantiating them\nwill persist into the remainder of the generation flow.\nIt is not recommended to put a lot of logic into target files, but when used\nresponsibly this can be a useful addition to your tool box. Origen Configuration The target and environment files can also be used \nto override any Origen configuration settings that would otherwise be specified in\nthe config/application.rb file. An example might be to set up product-specific LSF strings for utilization tracking: # target/eagle_1.rb $dut = MyApp :: Eagle .new( version : 1 ) Origen .config.lsf.project = \" eagle.te \" # target/falcon_1.rb $dut = MyApp :: Falcon .new( version : 1 ) Origen .config.lsf.project = \" falcon.te \" Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/introduction/": {
    "title": "Introduction",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Introduction Typically an Origen application will contain source code to generate IP that can be\napplied to many different products, and/or which can run on many different test platforms.\nIt is the job of the target and the environment to setup the runtime conditions that will\ndefine what combination of product and tester platform will be targeted by the\ngenerated output. The target is normally used to define the product side of the runtime environment, with one\ntarget file existing for every product/device that the application supports.\nTarget files are usually very short and normally just instantiate the model of the target\ndevice, assigning it to the global variable $dut . For test engineering applications, the test platform selection is usually handled by environment\nfiles. These are very similar to target files and there is usually one per supported test\nplatform. Each environment will typically instantiate the target tester model/driver, assigning it\nto the global variable $tester .\nFor non-test engineering applications, the environment layer can either be omitted or\nelse it can be used to define whatever other global state makes sense to be applied across\nmultiple device targets. Additionally, Origen has the concept of an operating mode and this can be considered a\nthird component of the runtime environment. How the Runtime Environment is Applied Before compiling any template, or generating any pattern, test program or other source file,\nOrigen will do the following: Apply the active mode Execute the active environment file Execute the active target file This means that the active environment can override the active mode, and that the active target can\noverride both the mode and the environment. This sequence will be repeated between jobs if multiple\nfiles are being compiled/generated by a given Origen thread of execution (each source files is an individual job).\nThis prevents model state from a previous job from carrying over to the next one and ensures that the\noutput is never affected by generation order. This sequence of reloading the mode, environment and target is generally referred to as \n \"reloading the target\".\n No API exists within Origen to reload only one of these component, so anytime you see a reference\n to the target being re-loaded it means that all three of the runtime environment components will be\n refreshed. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/loadorder/": {
    "title": "Load Order",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Load Order The number of global objects instantiated by a runtime environment should be kept to a minimum,\nhowever even the most basic of setups is likely to instantiate both a $dut and a $tester object. It is important that the initialization of each of these objects does not depend on the other\nto avoid introducing a dependency on the order in which they must be instantiated.\nSuch a dependency is fine when the application is young and the number of configurations is small, but as\nit grows this can become painful to manage and hard to anticipate when new engineers\ncome onto the team. Nonetheless it is very likely that sooner or later the case will arise where an object\nmust be initially configured differently depending on what tester platform it is\nrunning on, or on what top-level device object it has been integrated into. So how to do that initial configuration without introducing an instantiation\norder dependency? The answer is to use an on_create method to complete any initialization\noperations that depend on other objects. Using on_create on_create is an Origen callback\nand the callback guide should be consulted \nfor background information and for details on how to setup your model to use callbacks. Whenever Origen loads a runtime environment it will automatically call the on_create methods of any objects that have just come into being at the end of loading the target/environment files. It is therefore guaranteed that on_create will be run before any\noperations are invoked on the model outside of the target/environment files and it should be though of\nas similar to the standard Ruby initialize method but with the guarantee\nthat all runtime objects already exist by the time it is called. Here are some examples of cases where on_create should be used in\npreference to initialize : # In the $dut model def initialize # This would be creating an instantiation order dependency by doing this here, # i.e. $tester must exist before the $dut # $tester.do_something end def on_create # But not here $tester .do_something end # In a model that is not $dut def initialize # This would be creating an instantiation order dependency by doing this here, # i.e. $dut must exist before this model # if $dut.test_pin_muxed_with_reset? # add_pin_alias :test, :reset # else # add_pin :test # end end def on_create # But not here if $dut .test_pin_muxed_with_reset?\n add_pin_alias :test , :reset else add_pin :test end end Any Downside to Using on_create Instead of initialize? Not really. Using initialize for object construction/initialization is perhaps preferable in some\nsense since it is a standard Ruby method and therefore clearer for someone new to Origen\nto understand how the model is initially being configured. However generally anything that can be done in initialize can be safely\nmoved to on_create and the eventual state of the model instantiated by the\nruntime environment files will be identical. One major difference is that parameter options cannot be passed into on_create from the target, whereas options can be passed into the initialize method.\nSuch parameter dependent cases can still be moved to on_create but the\noptions will need to be saved by the initialize method. def initialize (options={}) @intial_options = options end def on_create if @intial_options [ :uti ] $tester .do_something end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/mode/": {
    "title": "Mode",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Mode Origen supports the following operating modes: Production - To be used whenever generating output destined for production use. Debug - To be used whenever developing an application. Simulation - To be used whenever generating output destined for a simulation. The default operation mode is production , and in this mode Origen will enforce the following\nrestrictions: Origen will not run if there are modified files within the environment workspace (i.e. edits that are not checked in) Origen will not run if plugins are imported from a local path reference Both debug and simulation modes remove these restrictions and are essentially the same\nas far as Origen is concerned. However plugin and application developers may implement\ndifferent behavior if the output is targeting simulation rather than real silicon. Note that the origen new command for creating a new application will make it\n look as though debug is the default mode, but this is just to make life convenient for the new\n application developer who is obviously about to go on and develop the new app. If the new\n app was cloned to a new workspace by another user, \n then it would come up in production mode. Getting and Setting the Mode The current default mode for a given application workspace can be queried by running the origen mode command, or origen m for short: > origen m\n\ndebug The mode can be changed by running the same command and supplying the desired mode: > origen m production\n\n> origen m debug\n\n> origen m simulation Any shortcut which provides enough detail to uniquely identify one of the available modes can be used: > origen m sim Additionally all Origen commands allow an override to be supplied at runtime. Aside from overriding\nthe current default mode, this will also override any mode setting applied by the current environment\nor target: > origen g my_pattern -m simulation Programmatically Getting and Setting the Mode Origen.mode returns an object representing the current mode ,\nthis provides the following API for sniffing the mode at runtime: Origen .mode.production? # => false Origen .mode.debug? # => true Origen .mode.simulation? # => false Note that simulation is also considered a debug mode, the API will respond as follows\nif simulation mode is set: Origen .mode.production? # => false Origen .mode.debug? # => true Origen .mode.simulation? # => true For example this API can be used to create simulation workarounds if required: if Origen .mode.simulation? # Generate something that is more simulation-friendly else # Generate a pattern construct which works on the tester, but doesn't simulate well end The mode can be set like this: Origen .mode = :production Origen .mode = :debug Origen .mode = :simulation Note that the mode can be frozen in which case the above will have no effect. If the mode\n is supplied via a --mode option to the current command, then it will be automatically frozen\n to allow it to override any mode assignment made by the target or environment files via the\n above API. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/production/": {
    "title": "Production Targets",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Production Targets The following concerns may arise when releasing your application to 3rd parties\nwho will then go on to use it to generate production grade IP: Your application may support many different devices and targets, however only\na subset of these may be considered production ready at a given release\npoint. When lots of targets are available how do we ensure that the user picks the\ncorrect one? This is certainly an area where Origen has scope for further improvement, but for\nnow the following system works adequately and is being used today in large-scale\nproduction applications… Select the Target by Maskset Number Establish the convention with your user base that when generating IP for production\nthe target must always be selected by providing the maskset number (including\nthe revision). So for example someone using an application to generate production IP for a device\nwith maskset 1M79X should select the target like this: origen t 1m79x This keeps things simple for the end user and removes the need for them to\nchoose a target. Mapping Masksets to Targets To enable the above feature a map must be added to your config/application.rb file like this: # config/application.rb config.production_targets = { \" 0m79x \" => \" eagle_0 \" , \" 0n30d \" => \" falcon_0 \" , \" 1n92a \" => \" osprey_1 \" ,\n} Now whenever a maskset number is entered as a target the above table will be referred\nto automatically to select the actual target file. If giving the user a choice over the actual target to use is unavoidable, the number\nof options can be reduced by mapping a given maskset to multiple targets: # config/application.rb config.production_targets = { \" 0m79x \" => [ \" eagle_0_func \" , \" eagle_0_bist \" ], \" 0n30d \" => \" falcon_0 \" , \" 1n92a \" => \" osprey_1 \" ,\n} Now a user selecting 0M79X will be presented with a message showing the two options\nand will be asked to choose one of them. Although not generally recommended, it is also possible to map multiple maskset numbers\nto the same target: # config/application.rb config.production_targets = { \" 0m79x \" => [ \" eagle_0_func \" , \" eagle_0_bist \" ], \" 0n30d \" => \" falcon_0 \" , \" 1n30d \" => \" falcon_0 \" , \" 1n92a \" => \" osprey_1 \" ,\n} Finally if a specific target(s) is not supported for a given release it can be easily disabled\nby commenting out the relevant line(s): # config/application.rb config.production_targets = { \" 0m79x \" => [ \" eagle_0_func \" , \" eagle_0_bist \" ], # \"0n30d\" => \"falcon_0\", # \"1n30d\" => \"falcon_0\", \" 1n92a \" => \" osprey_1 \" ,\n} Now any requests to select target 0N30D or 1N30D will give a not found error. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/programming/": {
    "title": "Programming",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Programming This guide discusses how to programmatically change the target, note that this will also\nreload the environment as discussed here: How the Runtime Environment is Applied If you start writing your own commands you may want to programmatically define or manipulate the target. A single target should always be loaded by using the following method, it\ncan be called again to later switch to a different target: Origen .load_target( \" falcon_1 \" ) To load the default target, or to reload the current target, call the same method\nwith no argument: Origen .load_target Warning - \n If you browse the API you may see some similar methods described for loading\n the target, however these should be avoided. The above method is the intended\n public API and will ensure that all dependencies are setup correctly. With the above warning in mind the Origen::Application::Target API can be consulted to see what additional methods are available to work with\nthe target,\nan instance of that class is available via Origen.target . For example to get the name of the current target: Origen .target.name # => \"falcon_1\" Configurable Targets Any options passed into the Origen.load_target method can be accessed\nfrom within the target and used to customize it by the caller. For example here is a target where the device version is left for the caller\nto specify: # target/falcon.rb MyApp :: Falcon .new( version : options[ :version ]) This would be used like this: Origen .load_target( \" falcon \" , version : 1 ) $dut .version # => 1 Origen .load_target( \" falcon \" , version : 2 ) $dut .version # => 2 Target Loops Target loops (where some code is repeated for a collection of targets) are\nvery common and Origen provides some dedicated helpers for this. The Origen.target.loop method is the most useful in a\ncommand situation and is designed to\ngenerate a loop based on the value of a :target key in an\noptions hash. This option can contain the name of a target or an array\ncontaining multiple names, and if none are present it will fall back to the\ndefault target following the normal conventions. It is therefore ideally suited to creating a command where the user can\nsupply one or more targets and could be used like this: opt_parser = OptionParser .new do |opts|\n opts.on( \" -t \" , \" --target NAME1,NAME2,NAME3 \" , Array , \" Override the default target, NAME can be a full path or a fragment of a target name \" ) { |t| options[ :target ] = t } end opt_parser.parse! ARGV Origen .target.loop(options) do |options| # The current target is already loaded, the name of the current target has been substituted into options[:target] puts \" The name of the current target is: #{ options[ :target ] } \" # Implement your command logic here... end The above would work with any of the following inputs: # Execute for the current default target\norigen my_command \n\n# Execute for a single specific target\norigen my_command -t falcon \n\n# Execute for multiple specific targets\norigen my_command -t falcon,eagle Production Target Loops If your application has defined a production target map then some additional methods are available to loop on that: Origen .target.each_production do |maskset| # Do something for each maskset line defined in the map end Origen .target.each_unique_production do |masksets| # Do something for each unique target defined in the map end The latter will only execute for unique target files, so if the same file is used\nby multiple maskset numbers it will only be looped once and the masksets argument\nwill be an array containing all maskset numbers that use that target. Forcing Debug Mode All of the above looping methods accept an option to force all targets to debug mode,\nthis can be useful depending on the purpose of your command, but should obviously\nbe avoided in cases where the command is concerned with generating production IP. Origen .target.each_production force_debug : true do |maskset| # As above except Origen is running in debug mode regardless of the mode defined by the environment end Anonymous Targets Mostly intended for use in test cases, a temporary target can be declared on the fly with\na block of code like this: Origen .target.temporary = -> do MyDUT .new OrigenTesters :: V93K .new end Any calls to load or reload the target will now execute the above function. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/target/": {
    "title": "Target",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Target All targets are defined by files that reside in the target directory.\nTargets are regular Ruby files and they should be simply named: <identifier>.rb Normally the target is used to select the target device and they are simply named after\nthe device that they instantiate, e.g. target\n|-- eagle.rb\n|-- falcon.rb\n|-- vulture.rb\n`-- osprey.rb Creating a Target To create a new target, simply create the file containing whatever Ruby code you need.\nThey are usually very concise and normally only instantiate the\ntarget device model, here are some examples: # target/eagle.rb MyApp :: Eagle .new # target/falcon.rb MyApp :: Falcon .new A common variation on this theme is to have different targets for different versions of\nthe device that are available, or perhaps to configure the model differently for different\ntypes of test: # target/eagle_1.rb MyApp :: Eagle .new( version : 1 ) # target/eagle_2.rb MyApp :: Eagle .new( version : 2 ) # target/falcon_func.rb MyApp :: Falcon .new( configuration : :func ) # target/falcon_bist.rb MyApp :: Falcon .new( configuration : :bist ) Setting a Default Target A default target can be defined that will be used withing a new workspace unless the user\nspecifies otherwise. This is not required and should only be added if it makes sense within the\ncontext of the application - i.e. you may choose not to have a default to avoid the situation where the user\nbuilds something without really understanding what configuration they are targeting. A default is specified by creating a target file called target/default.rb ,\ntypically this is a symbolic link to another target file: ln -s target/falcon_bist.rb target/default.rb Getting and Setting the Target The current target for a given application workspace can be queried by running the origen target command, or origen t for short, this will show\nyou the content of the current target file: > origen t\n\nCurrent target: falcon_bist.rb\n**********************************************************************\n MyApp::Falcon.new(configuration: :bist)\n********************************************************************** The target can be changed by running the same command and supplying the desired target: > origen t target/falcon_func.rb\n\n> origen t falcon_bist As shown above, a full path or any snippet which is enough to uniquely identify one of the available\ntarget files is sufficient. Additionally all Origen commands allow an override to be supplied at runtime: > origen g my_pattern -t eagle_2 Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/simulation/app/": {
    "title": "Application Setup",
    "subtitle": "Simulation",
    "body": "Simulation Application Setup Generally speaking, an Origen application setup is the same whether you are generating\na pattern/flow for the ATE or if you wish to simulate it. Therefore, the rest of the guides are applicable for how to setup a model and a controller for your DUT,\nand how to create a pattern . However, there are still a few simulation-specific points that are worth noting to help\nmake your application simulation-ready. Pin Definitions To simulate, you will at the very least need a model that corresponds to your DUT and which\ndefines the pins that you want to wiggle. It is not necessary to define all the pins of your DUT in the model, but for those that you do\ndefine the IDs should match up between the model and the top-level Verilog module for your\nDUT. The easiest way to achieve this is to define your model’s pins by importing the pins that were\nextracted from the design (using sim:build as described in the Compiling the DUT section ). This will guarantee that your model exactly matches the design, and if you want\nto use different pin names in the ATE patterns you can define these as aliases and add a pin_pattern_order statement to choose the alias instead of the h/ware names: module MyApp class MyDUT include Origen :: TopLevel def initialize (options = {})\n import ' my_dut ' , dir : \" #{ Origen .root! } /vendor/pins \" , namespace : nil # Add aliases if you want to use different names in your application and in ATE patterns add_pin_alias :resetn , :reset_neg_async end end end Alternatively, if you already have your pins defined manually in the application and you need to\nreconcile these with what they are called in the design, then you can add the rtl_name attribute\nto your definition: add_pin :resetn , rtl_name : :reset_neg_async Once you have your pins defined, you can immediately create a pattern and simulate it\nto see if you can see the pins wiggling! # pattern/sign_of_life.rb Pattern .create do 10 .times do dut.pin( :my_pin ).drive!( 1 )\n dut.pin( :my_pin ).drive!( 0 ) end end To simulate it: origen g sign_of_life -e environment/sim.rb Simulation Startup When simulating a pattern, the same startup callback (that you might use to implement a mode entry or other setup sequence) will be called as it would\nwhen you are generating for an ATE. However, sometimes you may need to do some additional setup in simulation, for example to drive\nsome power pins that would be handled by a power supply on an ATE - i.e. they are not normally\ncared about in the pattern. A simulation-specific callback exists for this purpose, this will be called immediately upon a\nsimulation starting and before the pattern or flow creation gets underway - i.e. it will be\ncalled before the regular startup callback. def simulation_startup # Drive these power pins to 1, these are not included in the ATE patterns and will be handled # be a power supply on the tester pin( :vdd ).drive( 1 )\n pin( :vddc ).drive( 1 )\n pin( :vss ).drive( 0 ) end Note that if multiple patterns are being generated back-back in a single simulation, then the simulation_startup will only be called once at the very start of the simulation. In contrast,\nthe startup method will be called at the start of every individual pattern within the simulation. Simulation Specific Code Any simulation-specific code in your application can be gated as shown below: if tester.sim? # Only executed when simulating end Starting the Simulator in an Interactive Session When in an interactive session ( origen i ) the simulator can be started by typing tester.start . If you want this to happen automatically every time you start an interactive session when\nthe simulation environment is selected, add this to the interactive startup callback : def interactive_startup # Always start the simulator immediately if I open an interactive session with the # simulation environment selected tester.start if tester.sim? end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/simulation/artifacts/": {
    "title": "Artifacts",
    "subtitle": "Simulation",
    "body": "Simulation Artifacts When OrigenSim runs, it will change the current directory to run the simulator. This is not necessarily the\nsame directory that the compiled snapshot resides in and will most likely break relative paths compiled into the\nsnapshot. OrigenSim provides an artifacts API to handle this problem. Artifacts are just files or\ndirectories that need to be available in the run directory prior to the simulation start. This can be used to\nreconstruct the run directory regardless of vendor or target configurations, and without requiring you to build in the\nlogic into the application itself. OrigenSim will automatically look for artifacts in the directory #{Origen.app.root}/simulation/application/artifacts .\nAnything in the this folder will be moved to the run directory and placed in application/artifacts just before the\nsimulation process starts. These artifacts will be populated across targets. You can override an artifact with one\nspecific to your target by placing an artifact with the same name in simulation/TARGET/artifacts . For example, if I have an artifact simulation/application/artifacts/startup.sv that I need for \nthree targets, rtl , part_analog , and all_analog , this same artifact will be used\nwhenever any of those targets are used. Then, consider I have a new target gate , which has a different startup.sv to run. By placing this at simulation/gate/artifacts/startup.sv , OrigenSim\nwill replace the artifact in simulation/application/artifacts with this one, in the same run directory. Warning: Default artifacts only go a single level deep. Directories placed at simulation/TARGET/artifacts will override an entire directory at application/artifacts . If you need more\ncontrol over the artifacts, you can see further down in this guide for manually adding artifacts. OrigenSim provides two further customizations to the default setup. Like the target directory, you can pass additional user_artifact_dirs , which will override any artifacts found at either the default or target artifact levels.\nThese artifacts will override each other in the order of the Array definition. All of these artifacts have different sources, but they are placed in the same artifact_run_dir , which\ndefaults to application/artifacts . This location is customizable as well with the artifact_run_dir option. OrigenSim ::cadence do |sim| # Add a user artifact directory sim.user_artifact_dirs [ \" #{ Origen .app.root } /simulation/testbench \" ] # Change the artifact target location, within the context of the run directory. # NOTE: this is relative to the run directory. This expands to /path/to/run/dir/testbench sim.artifact_run_dir \" ./testbench \" end Note here that the artifact_run_dir is implicitly relative to the\nrun directory. Relative paths are expanded in the context of the run directory, not relative to\nthe current script location. Artifacts can be populated either by symlinks or by copying the contents directly. By default, Linux will symlink the\ncontents and unlink to clean them. However, due to the elevated priveledges required by later Windows systems to symlink objects,\nthe default behavior for Windows is to just copy files. This does mean that larger, and/or a large number, of artifacts\nmay take longer. This behavior can be changed however: OrigenSim ::cadence do |sim| # Force all artifacts to be copied artifact_populate_method :copy # Force all artifacts to be symlinked artifact_populate_method :symlink end OrigemSim’s artifacts can be queried, populated, or cleaned, directly by accessing the OrigenSim.artifact object (note: the exclusion of the s ). Some methods also exist to retrieve and list the current artifacts: # Populate all the artifacts tester.simulator.artifact.populate # Clean the currently populated artifacts tester.simulator.artifact.clean # List the current artifact names tester.simulator.list_artifacts # Retrieve the current artifact instances (as a Hash whose keys are the names returned above) tester.simulator.artifacts # Retrieve a single artifact tester.simulator.artifacts[my_artifact]\ntester.simulator.artifact[my_artifact] The OrigenSim::Artifacts class inherits from Origen::Componentable ,\nso any of the componentable methods are available. Additional single-artifact items can be added manually: # in environment/sim.rb tester = OrigenSim ::cadence do |sim| end tester.simulator.artifact( :my_artifact ) do |a| # Point to a custom target a.target \" /path/to/my/artifact.mine \" # Point to a custom run target # Recall this will expand to /path/to/run/dir/custom_artifacts # This ultimately places the artifact at /path/to/run/dir/custom_artifacts/artifact.mine a.run_target \" ./custom_artifacts \" # Indicate this artifact should be copied, regardlesss of global/OS settings. a.populate_method :copy end Note that this takes place outside of the initial tester instantiation, but can still occur in the environment\nfile. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/simulation/compiling/": {
    "title": "Compiling the DUT",
    "subtitle": "Simulation",
    "body": "Simulation Compiling the DUT The details of how to build a given IP or SoC design can be complicated and can vary significantly\nfrom case to case; it is something that is best managed by the design or verification team for\na given design under test (DUT). Therefore, OrigenSim does not attempt to manage the simulation build process but instead provides\ncomponents that should be integrated into the target DUT’s existing design build flow in order to\nproduce an output that is compatible with OrigenSim. High-Level Flow The high-level flow that we are aiming for here is as follows: The design flow owner runs an Origen command to create the Origen components, the top-level Verilog\nis supplied as an input to this command and this will be used to create a DUT-specific Origen testbench The design flow owner incorporates these components into their build flow and executes it, stopping\nafter elaboration to create the Origen simulation object The design flow owner delivers the Origen simulation object to the Origen flow owner (e.g. the test engineer) The Origen flow owner integrates this simulation object into an Origen application This process should be repeated from step 1 anytime either of the following occur: Changes are made to the top-level pin interface of the DUT A new version of OrigenSim is available with some new features that need to be compiled into the DUT The process should be repeated from step 2 anytime: Changes have been made to the internal operation of the DUT (design changes) and you wish to be included\nin Origen simulations Creating the Origen Components The OrigenSim plugin provides a command called sim:build to create the Origen components that should\nbe incorporated into the design build process. To check if this is available, run the origen command outside of an application workspace, you should\nsee something like this: > origen\n\nUsage: origen COMMAND [ARGS]\n\nThe following commands are available:\n new Create a new Origen application or plugin. \"origen new my_app\" creates a\n new origen application workspace in \"./my_app\"\n interactive Start an interactive Origen console (short-cut alias: \"i\"), this is just\n IRB with the 'origen' lib loaded automatically\n\nThe following global commands are provided by plugins:\n sim:build Build an Origen testbench and simulator extension for a given design\n\nMany commands can be run with -h (or --help) for more information. Note the sim:build command is noted as being provided by a plugin at the bottom. If you don’t see that\nthen it means that OrigenSim needs to be installed into your global Ruby, if you have the required admin\nrights you can do this by simply executing: gem install origen_sim If you don’t have the required permission then speak to your system administrator to have them do this.\nMore detailed information on how to manage your globally available plugins like this can be found in\nthe advanced guide on how Origen is invoked . If the origen command does not work at all, then first refer\nto the guide on how to install Origen . Once you have verified that you have the sim:build command available, execute it by supplying the\npath to your top-level Verilog file like this: origen sim:build path/to/my_top_level.v It is highly recommended that you supply a stub model here, all that Origen needs to know about is the\ntop-level pin interface and reducing the amount of superfluous design code will reduce the chance\nof parse errors during this step. Multiple files can be passed in, for example to include a defines file: origen sim:build path/to/my_defines.v path/to/my_top_level.v If you prefer, it also works by supplying the source file directory path(s) separately: origen sim:build my_defines.v my_top_level.v -s path/to The sim:build command does have some rudimentary support for evaluating and applying Verilog compiler\ndirective rules, though at the time of writing it does not evaluate Verilog parameters. If you find that it does choke on your design files please do enter a ticket describing the code\nwhich failed to parse here - https://github.com/Origen-SDK/origen_verilog/issues In most cases any parse issues can be resolved by moving to a stub model or by simply removing the\noffending code to create a partial stub. Once you see a message like this, you are ready to move onto the next step: -----------------------------------------------------------\n\nTestbench and VPI extension created!\n\nThis file can be imported into an Origen top-level DUT model to define the pins:\n\n /path/to/origen/my_top_level.rb\n\nSee above for what to do now to create an Origen-enabled simulation object for your particular simulator. Building the Design We need to start from a command which can compile and elaborate the DUT only, so any 3rd party testbench\nshould be removed from the build process before we go any further. The output from the previous step contains compiler-specific instructions on what files and switches\nshould be added to your build command, here for example for Cadence: -----------------------------------------------------------\nCadence (irun)\n-----------------------------------------------------------\n\nAdd the following to your build script to create an Origen-enabled simulation object (AND REMOVE ANY OTHER TESTBENCH!):\n\n /path/to/my/origen/origen.v \\\n /path/to/my/origen/*.c \\\n -ccargs \"-std=c99\" \\\n -top origen \\\n -elaborate \\\n -snapshot origen \\\n -access +rw \\\n -timescale 1ns/1ns\n\nThe following files should then be used for Origen integration:\n\n /home/nxa21353/Code/my_origen/origen/my_design_top.rb\n INCA_libs/ (created by irun) At the time of writing Cadence, Synopsys and Icarus Verilog simulators are supported. Simply add the files and switches as instructed to your baseline build command and it should then create\na snapshot of your design that is ready to talk to Origen. The compiler-specific notes also mention what files should be given to the Origen application integrator, in\nthis case for Cadence the INCA_libs directory and an Origen file that defines the DUT’s pins. Once you are in possession of these files, you are ready for the final step: Integrating the Simulation Object One of the generated components from the sim:build command is an Origen file that defines the DUT’s pins. If you wish to use this\nin your model (optional, you can define them in the model by hand or any other way you like), then check it\ninto your application’s vendor directory and import it within your model’s initialize method like this: # Import pin definitions as extracted from the design import ' my_top_level ' , dir : \" #{ Origen .root! } /vendor/wherever/i/like \" , namespace : nil Note that 'my_top_level' corresponds to the name of the file. Your application should already have a target setup that corresponds to this DUT, if not create one. The copy the compiled design files into simulation/TARGET/SIMULATOR/. , where TARGET is the name\nof the target, e.g. my_dut and SIMULATOR is either cadence , synopsys or icarus . For example, the INCA_libs directory in this Cadence example might be copied to simulation/my_dut/cadence/INCA_libs . You can check these simulation files into your application’s revision control system, but since they can be very large binaries\nit is recommended that you add the simulation directory to your .gitignore and use an alternative revision control\ntool like DesignSync to store them. This will be further discussed in the environment setup, which is the next section of this guide to simulation… Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/simulation/debugging/": {
    "title": "Interactive Debugging",
    "subtitle": "Simulation",
    "body": "Simulation Interactive Debugging Register Reading reg.sync Added an API to allow application code to force a simulation fail, which piggy backs on the way that log output from the simulator can make the simulation result be classed as a fail: When running in simulation, verify this node which is not observable on the tester if tester.sim?\n if tester.simulator.peek(“origen.dut.path.to.some.node”).to_i == 1\n OrigenSim.error “The internal blah warning was asserted!”\n end\nend Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/simulation/environment/": {
    "title": "Environment Setup",
    "subtitle": "Simulation",
    "body": "Simulation Environment Setup By convention, the OrigenSim simulator driver is configured within the file environment/sim.rb . Usually the simulator configuration may be different for each DUT target, so often this file is structured like this\nto enable a single Origen simulation environment setup file to support multiple DUT targets within the\napplication: # environment/sim.rb case Origen .target.name when \" my_dut1 \" OrigenSim .cadence do |sim| # Configuration of Cadence simulator to be used for DUT1 here end when \" my_dut2 \" OrigenSim .synopsys do |sim| # Configuration of Synopsys simulator to be used for DUT2 here end else Origen .log.error \" No simulation environment has been setup for target #{ Origen .target.name } , edit environment/sim.rb to add one. \" exit 1 end Configuring The Simulator Here is an example of configuring the simulator with some generic options that are supported by all simulators: OrigenSim .cadence do |sim| # By default a simulation will be given 60 seconds to startup, if it fails to start within this time the # simulation will be abandoned and considered failed. If a particular simulation is known to be slow to start, # the timeout can be extended as shown in this example (5 minutes): sim.startup_timeout 5 * 60 # Sometimes due to different Verilog timescale references, the time specified by Origen may not align to what # is seen in the simulation. For example, your Origen application might define a cycle period of 40ns but in # the simulation this manifests as 400ns. Such differences can be fixed by specifying this time factor which # will be multiplied with all time advancements defined by Origen. This can be any value like 0.01, 0.1, 10, # 100, 1000, etc. to make the cycle period seen in simulation bigger or smaller. sim.time_factor 100 end Note that defining a configuration like this will also instantiate an instance of OrigenSim::Tester and assign it to\nthe global variable tester .\nThis tester object will behave like any other Origen tester driver and your application will be unaware that it is\ndriving a simulator rather than an ATE-specific pattern renderer. Note also that the post_process_run_cmd option is available for all simulators, however it is reserved for discussion\nlater in this guide since it is more of an advanced topic. Cadence (irun) Specific Configuration Additionally, a Cadence simulator setup supports the following vendor-specific options: OrigenSim .cadence do |sim| # By default the simulation will be run by calling 'irun', this can be changed to anything you want, but it # is usually a good idea to use this option to lock to a specific version of irun (the same version that was # used to compile the DUT snapshot) sim.irun ' /tools/cadence/15.10.023/bin/irun ' # The default wave viewer is 'simvision', this can also be changed sim.simvision ' /tools/cadence/15.10.023/bin/simvision ' # The cadence simulator configuration does support the use of forces, though this is generally discouraged sim.force { ' origen.dut.vref_0v8 ' => 1 , ' origen.dut.pmc.some.internal.node ' => 1 ,\n } # Custom probes can be specified, e.g. to include memory contents in the wave dump sim.tcl_inputs %Q( probe -create -shm origen.dut.mems.user -all -memories -variables -unpacked 262144 -depth all\n probe -create -shm origen.dut.mems.cache -all -memories -variables -unpacked 262144 -depth all ) end Synopsys Specific Configuration Here are the vendor-specific options for Synopsys: OrigenSim .cadence do |sim| # By default the simulation will be run by calling 'vcs', this can be changed to anything you want, but it # is usually a good idea to use this option to lock to a specific version of vcs (the same version that was # used to compile the DUT snapshot) sim.vcs \" /tools/synopsys/L-2016.06/bin/vcs \" # The default wave viewer is 'dve', this can also be changed sim.dve \" /tools/synopsys/L-2016.06/bin/dve \" end Icarus Verilog Specific Configuration Here are the vendor-specific options for Icarus Verilog: OrigenSim .cadence do |sim| # By default the simulation will be run by calling 'vvp', this can be changed to anything you want, but it # is usually a good idea to use this option to lock to a specific version of vvp (the same version that was # used to compile the DUT snapshot) sim.vvp \" /tools/icarus/0.9.7/bin/vvp \" # The default wave viewer is 'gtkwave', this can also be changed sim.gtkwave \" /tools/gtkwave/3.3.66/bin/gtkwave \" end Generic and Advanced Simulator Configuration A generic simulator configuration allows you to use a tool that is not supported out of the box by OrigenSim . For these, it \nis your responsibility to provide the command to start the simulation process, however, this allows for arbitrary commands to\nstart the process and allows end users to still use origen g as if with a fully OrigenSim supported\nsimulator configuration. An example of such a configuration could be: OrigenSim .generic do |sim|\n sim.generic_run_cmd do |s| # Return the command to start the simulation \" path/to/custom/sim/script +socket+ #{ s.socket_id } \" end end Here is an example using the predecessor of the supported Cadence tool irun , ncsim : OrigenSim .generic do |sim|\n sim.testbench_top ' na_origen ' sim.generic_run_cmd do |s| \" ncsim na_origen -loadpli origen.so:bootstrap +socket+ #{ s.socket_id } \" end end The following commonly used options are available to a generic simulation configuration: testbench_top - Defines the testbench name if different from origen . view_waveform_cmd - Required for generic configurations - prints out this statement following a simulation instructing the\nuser on how to open the waveforms for viewing. For supported simulators, this is already provided, but can be overwritten. generic_run_cmd - Either a string, array to be joined by ‘ && ‘, or a block returning either of the aforementioned that\nthe generic configuration will use to launch the simulation. post_process_run_cmd - Block object to post-process the command that OrigenSim will launch the simulation with. This can be used\nto post-process the command for any supported vendor. This block should return the command to run, as a string. An example of the post_process_run_cmd usage is: OrigenSim .cadence do |sim|\n sim.post_process_run_cmd do |cmd, s| # cmd is the current command that will be run. s is the simulator object, same as sim in this case. # this should return either a string or an array to be joined by ' && ' (chain commands) # note that we must RETURN the string. We cannot just edit it. # add an environment variable and run setup script as an example return \" export PROJECT=my_rtl && source #{ Origen .app.root.join( ' settings.sh ' ) } && #{ cmd } \" # or, we could return return [ ' export PROJECT=my_rtl ' , \" source #{ Origen .app.root.join( ' settings.sh ' ) } \" ,\n cmd\n ] #=> \"export PROJECT=my_rtl && source #{Origen.app.root.join('settings.sh')} && #{cmd}\" end end Simulation Object Checkin/Checkout Environment setups can also include information on the url and version of where the compiled simulation object\nis to be stored - often this will not be checked into the same repository as the main application code since\nfor example Git, which is good for application code storage, is not really so good for storing large binaries\nlike the simulation objects. Here is an example setup: OrigenSim .synopsys do |sim|\n sim.rc_dir_url ' sync://sync-12345:12345/Projects/origen_sim_snapshots ' sim.rc_version ' Trunk ' end The rc_dir_url option should point to a directory in the repository where the snapshot files should be\nstored, not to the snapshot file itself. The rc_version can be set to the version to use, which can be a pointer to latest like ‘Trunk’ or ‘master’ or\nto an absolute version. The object should be committed to the repository by running the origen sim:ci command with the environment/target\nsetup to select the object to be checked in.\nOrigen Sim will then automatically tar up the object and check it in. This same command can be run again in future to check in new versions. Origen Sim will then automatically check for the presence of the object in the local workspace and will fetch\nit as required - i.e. if not present or if the rc_version has been updated. Note that when a latest pointer is used as the version, the remote repository is not automatically checked for updates.\nIf you want to fetch the latest version or force a re-checkout at anytime you can run the origen sim:co command. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/simulation/flows/": {
    "title": "Simulating Flows",
    "subtitle": "Simulation",
    "body": "Simulation Simulating Flows A flow, meaning a sequence of patterns, can be simulated in two ways - by supplying\na list of patterns or by configuring a test program generator flow to support simulation. Simulating a Pattern List If you were to run this: origen g my_pat_1 my_pat_2 -e environment/sim.rb then it would run the two patterns as two independent simulations, creating two waveforms named after each pattern. They can be combined into a single simulation by adding a --flow option: origen g my_pat_1 my_pat_2 -e environment/sim.rb --flow my_flow This will simulate the given patterns back-back and dump them to a waveform named after the flow option, in this case “my_flow”. The list of patterns can also be supplied via a list file: origen g list/regression.list -e environment/sim.rb --flow regression Simulating a Test Program Flow To simulate a pattern sequence defined by a test program flow , it is necessary\nto setup your interface to support the simulation tester driver\nas if it were another ATE. The simulation tester driver has no concept of test methods, suites or instances, so its interface setup is very simple -\nonce you have the pattern name simply pass that to the test method: # Example interface method def func (name, options = {}) # Resolve the pattern name as required pattern = extract_pattern_name(name, options) if tester.sim?\n test(pattern, options) elsif tester.v93k?\n t = test_suites.add( :vreg_func )\n t.test_method = test_methods.origen.functional_test\n t.pattern = pattern\n test(t, options) else fail \" The test program interface has not been setup for #{ tester.class } ! \" end end To simulate the flow, run the program generator as normal but with the simulation environment selected: origen p program/my_flow.rb -e environment/sim.rb The generated wave will be named after the flow, my_flow in this example. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/simulation/howitworks/": {
    "title": "How It Works",
    "subtitle": "Simulation",
    "body": "Simulation How It Works Here are some technical details on how OrigenSim works which should provide some context when it comes\nto compiling your DUT design to work with OrigenSim . Origen provides components that can be compiled into a simulation object along with the design under test (DUT),\na high level view of the process looks like this: The main Origen Ruby process is invoked by generating a pattern as usual, e.g. origen g my_pattern ,\nbut with the environment setup to instantiate an instance of OrigenSim::Tester instead of say OrigenTesters::V93K .\nThe OrigenSim tester will start off a Verilog process in parallel which will run a simulation on an object that\nhas been created beforehand. This simulation object contains the DUT wrapped in an OrigenSim testbench, and which\nhas been compiled into a snapshot/object that also includes a Verilog VPI extension which provides a communication interface between Origen and the simulation world. When the simulation process starts, the VPI extension immediately takes control and halts the simulator while it\nlistens for further instructions from a Linux socket which was setup by OrigenSim before the simulation was started.\nAs the Origen pattern generation process executes, the OrigenSim::Tester will translate any requests\nto drive or expect pin values, or to generate a cycle, into messages which are passed into the Linux socket.\nUpon receving these messages, the VPI process will manipulate the testbench’s pin drivers to drive or read from\nthe DUT and it will advance time by a cycle period every time a cycle is generated in the pattern.\nThe testbench to wrap and instantiate the DUT is generated by OrigenSim and it provides a standard interface through\nwhich Origen can access any DUT. In principle the DUT object can be any design view that is wrapped by a conventional top-level Verilog module, meaning that\nOrigenSim can be used to run RTL or gate-level simulations depending on what has been compiled into the snapshot. Note also that the DUT can be either an IP-block or an SoC, and so OrigenSim can be used equally well for running\nboth IP-level and top-level simulations. The Testbench The testbench is quite simple and it does little more than instantiate the DUT module and connect all of its pins to\ninstances of this pin driver module .\nThe testbench module is named origen by default and all OrigenSim simulation dumps will have this same top-level structure: .\n└── my_pattern\n └── origen\n ├── debug // Contains an error count, pattern name and comments, and other debug aids\n ├── dut // Your DUT\n └── pins\n ├── tdi // Driver for the TDI pin (for example)\n ├── tdo\n └── tck The driver contains a number of registers which are written to directly by the VPI process, allowing it to drive or expect a\ngiven data value (stored in origen.pins.MYPIN.data ) by writing a 1 to origen.pins.MYPIN.drive or origen.pins.MYPIN.compare respectively.\nIf the value being driven by the pin does not match the expect data during a cycle, then an error signal will be asserted by the\ndriver and this will increment an error counter that lives in origen.debug.errors[31:0] . An error count > 0 will result in the pattern simulation status being reported as a FAIL by Origen and this can be used\nto create simulation-based regression test suites for your application. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/simulation/introduction/": {
    "title": "Introduction",
    "subtitle": "Simulation",
    "body": "Simulation Introduction OrigenSim is a plugin that enables semiconductor test patterns (and flows) written in Origen/Ruby to be run\nin a dynamic Verilog simulation, similar to what is commonly known as a Virtual Test simulation in other workflows. It provides a simulation tester driver (which can be used as a direct replacement for Origen’s\nconventional ATE tester drivers) which will\npass requests to drive or expect pin values onto a simulator instead of rendering them to an ASCII file. Since\nthe application-level Origen code is the same in both cases, it guarantees that what happens in the simulation\nand in the final pattern are the same and that ultimately they will work first time on silicon. For debugging, OrigenSim supports the injection of regular Ruby debugger breakpoints anywhere in the pattern\nsource code. This will halt the simulation at the given point in time, allowing it to be interactively\ndebugged at the Origen-source-code level. Similarly, an Origen interactive session ( origen i ) can be launched with an OrigenSim driver,\nallowing designers and test engineers to use Origen APIs to interactively manipulate a live simulation of their\nDUT while viewing the response in real time in a wave viewer. Adding OrigenSim To Your Application To enable your application to use OrigenSim, simply add the plugin to your Gemfile: gem \" origen_core \" and then create a simulation environment setup . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/simulation/log/": {
    "title": "Simulator Log Output",
    "subtitle": "Simulation",
    "body": "Simulation Simulator Log Output Log output from simulations is often very verbose, which can make it hard to distinguish between messages\nthat are important and those that can be safely ignored. By default, OrigenSim will automatically suppress all simulator log output except for any lines that\ncontain the text WARNING or ERROR ; both of these will be logged to the console and any occurrences of\nthe latter will also make the result of the simulation be classed as a FAIL. All log output can be shown in the console by running with the -d or --debug switches, and the log files will\nalways contain everything that was output by the simulator. OrigenSim will also consider any output from the simulator to STDERR as a sign that something has gone wrong\nand this will also cause the simulation result to be classed as a FAIL. If your simulation produces STDERR output which you don’t care about (and which you don’t want to make your\nsimulation FAIL), then you can configure OrigenSim to ignore all STDERR messages via: OrigenSim .fail_on_stderr = false Alternatively, a safer solution is to declare which specific messages on STDERR should be ignored.\nFor example, say that in an early design build the ADC is not configured correctly and this results\nin a message about this being output to STDERR.\nHowever, since this problem does not affect the particular IP that we are testing we do\nnot want our simulations to FAIL because of it. In such a case you can add strings to the stderr_string_exceptions array and any STDERR lines which contain\nthe given text will by ignored: OrigenSim .stderr_string_exceptions << ' invalid adc config ' Similarly, if you find that the default of matching for ERROR in STDOUT messages is being overly aggressive,\nexceptions can be added in a similar way: OrigenSim .error_string_exceptions << ' uninitialized value in ROM at ' This means that a log line resembling ERROR uninitialized value in ROM at 0x1000 will not fail the simulation,\nbut the line ERROR uninitialized value in RAM at 0x2000 will fail. On the other hand, if you find that simply matching for ERROR is not catching some cases which you would\nlike to cause a FAIL, you can add additional strings to watch out for like this: OrigenSim .error_strings << ' FAILED ' If you want to remove ‘ERROR’ from the list of error strings (in there by default), you can assign a new array\ninstance: OrigenSim .error_strings << ' FAILED ' OrigenSim .error_strings # => ['ERROR', 'FAILED'] OrigenSim .error_strings = [ ' FAILED ' ] OrigenSim .error_strings # => ['FAILED'] Similar variables exist to configure what you want to catch as a warning: OrigenSim .warning_strings # => ['WARNING'] OrigenSim .warning_string_exceptions # => [] and also to match and output lines that you simply want to be shown in the console by default: OrigenSim .log_string # => [] It is conventional to do all such configuration like this with environment/sim.rb , where you can decide\nto make it global (applies to all targets), target-specific, or a combination of both: # environment/sim.rb # Will apply to all targets OrigenSim .error_strings << ' FAILED ' case Origen .target.name when \" my_dut1 \" OrigenSim .cadence do |sim| # Configuration of Cadence simulator to be used for DUT1 here end # Known problem with this specific DUT only OrigenSim .error_string_exceptions << ' uninitialized value in ROM at ' when \" my_dut2 \" OrigenSim .synopsys do |sim| # Configuration of Synopsys simulator to be used for DUT2 here end # ... Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/simulation/patterns/": {
    "title": "Simulating Patterns",
    "subtitle": "Simulation",
    "body": "Simulation Simulating Patterns Patterns are simulated by simply generating the pattern with\na simulation environment selected: origen g my_pattern -e environment/sim.rb Most of the common pattern API is supported\nby OrigenSim and therefore you should expect to find the simulation environment\na drop-in replacement for your conventional ATE environment driver. If you come across an API that OrigenSim does not support but you think that\nit should, please raise a ticket here describing what you\ntried to do https://github.com/Origen-SDK/origen_sim/issues . Waiting For Events When your pattern invokes some DUT action and you need to wait for it to complete, you\nnormally have two options: Calculate how long it should take and wait for a fixed delay Implement a match loop to dynamically wait for an expected response to occur Both of these are fully supported by OrigenSim, see the Timing and Waiting guide for more information on these APIs. However, if your pattern generation flow is going to be supported by simulation, then you also have\na third option - to derive the required wait time from the simulation itself. OrigenSim makes this very easy via the following API: cc \" Wait for the program command to complete \" tester.sim_delay :program_command do dut.pin( :done ).assert!( 1 ) end The sim_delay method provides the convenience of a match loop for the purposes of\ndelay calculation but will still generate a static pattern for the ATE. It will automatically calculate how\nlong the given block takes to pass and then insert that delay when later generating the pattern for an ATE. An ID must be given to each delay, :program_command in this example, and if the same ID is used in multiple\ncalls to sim_delay then it means that the same delay will be used for each occurrence. When simulating a pattern that contains sim_delay block(s) for the first time, the delay will\nbe calculated from the simulation and stored in an Org file (Origen native pattern format) within your\napplication’s pattern directory. These files should be committed to your revision control system and considered\nas part of your application. The next time that you simulate it, the previously calculated delay will be inserted into the\npattern and therefore the simulation will be verifying that the delay is correct. If you want to re-calculate the delays during a simulation then run with the --sim_capture switch: origen g my_pattern -e environment/sim.rb --sim_capture Additional padding can be added to the calculated delay like this (all the usual time_in_us: style\nof time options are supported): tester.sim_delay :program_command , padding : { time_in_cycles : 10 } do dut.pin( :done ).assert!( 1 ) end By default, the block will be evaluated constantly until it passes when calculating the delay from\nthe simulation. If the time is long and this is making your simulation run too slow, you can use lower resolution\nby supplying a :resolution option, either as a number of cycles: tester.sim_delay :program_command , resolution : 10 do dut.pin( :done ).assert!( 1 ) end or by supplying a hash filled with the usual time options: tester.sim_delay :program_command , resolution : { time_in_ns : 50 } do dut.pin( :done ).assert!( 1 ) end Capturing Responses from the Simulation Sometimes the response from your DUT maybe hard to predict and/or complicated to model in Origen, think about a digital data\nstream response from a pin when testing a communications protocol. OrigenSim provides an API for such a case which allows pin output values for a subset of pins/vectors\nto be sampled during a simulation. The response is then captured and converted into the corresponding\nexpect data when the same pattern is later generated for the ATE. Capturing is really easy, just wrap the operation you want to capture in your pattern source code like this: tester.sim_capture :cmd55 , :dout , :test_bus , :tdo do dut.pins( :din_port ).drive!( 0x1234_5678 )\n dut.cmd.write!( 0x55 ) 60 .cycles end The first argument is an ID for the capture, this can be anything but the user must assign it.\nThen supply a list of pin/pin_group IDs (or pin objects) that you want to capture. If you use the same ID more than once it means that the same captured data will be used in multiple places. When you add this to the pattern an error will be raised if you try to generate an ATE pattern, this will\nadvise that the data has not been captured yet and it must be run in a simulation first. When you run it in a simulation for the first time, the data will be captured and stored to your application\nin the pattern/sim_capture directory. These files should be checked into your application as if they were regular patterns. On subsequent simulation runs, the data will not be captured but instead will be re-played from the simulation\n- i.e. the pattern will assert that the DUT output matches what is in the capture file.\nIn other words, by adding this and then simulating twice using the same command, you are both capturing and\nthen verifying the captured data. Add this switch to update the captures during a subsequent simulation run: origen g my_pattern --sim_capture To use the captured data in an ATE pattern, simply switch to an ATE target and generate as normal. A known limitation of this feature is that the pin state data is currently captured at the end of a cycle, not\nat the point during the cycle where it will be read by the pattern.\nHowever, if this were to be a problem in a particular application, you would see it fail when re-playing the\ncaptured data in simulation. Creating Simulation-Only Assertions Users are of course encouraged to write patterns that test the DUT via its pin interface since such\npatterns will work in physical environments like the ATE. However, it can be useful to supplement your patterns with simulation-only assertions which peek inside\nthe DUT to check that it is behaving as expected. Such assertions can report useful failure information\nback to the user which may help when debugging a failed pattern simulation. # This code must be skipped when the pattern is generating for an ATE target environment if tester.sim?\n value = tester.simulator.peek( \" origen.dut.path.to.net \" ).to_i[ 7 .. 4 ] if value != 0xA OrigenSim .error \" The internal node was #{ value.to_hex } instead of 0xA! \" end end Note the use of OrigenSim.error to report the error message, this will cause the simulation result\nto be reported as a FAIL, even if all pin level assertions otherwise pass. Also note that the value returned from the peek method is converted into an integer. This is because peek returns an instance of Origen::Value which can also handle X or Z values. So for example, if you actually wanted a given bit to be Z you could write your assertion as: unless tester.simulator.peek( \" origen.dut.path.to.net \" )[ 4 ].z? OrigenSim .error \" Bit 4 of some net was not in hi-Z mode! \" end It is also possible to force nets within the DUT via a corresponding poke method: if tester.sim?\n test.simulator.poke \" path.to.some.net[15:8] \" , 0x51 end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/app/": {
    "title": "Creating a New App",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Creating a New App Once you have installed Origen, you should\nfind that you now have access to an ‘origen’ executable from anywhere. Run origen from the command line and you should see this: Usage: origen COMMAND [ARGS]\n\nThe following commands are available:\n new Create a new Origen application or plugin. \"origen new my_app\" creates a\n new origen application workspace in \"./my_app\"\n interactive Start an interactive Origen console (short-cut alias: \"i\"), this is just\n IRB with the 'origen' lib loaded automatically\n\nMany commands can be run with -h (or --help) for more information. Because you are currently outside of an Origen application, there is a reduced set\nof commands available. The origen new command should be used to generate a new application. Running the New Application Command To create a new application run the command like below and answer the questions\nat the command prompt: origen new my_app_name The new application will be custom built depending on your answers to the\nquestions and it should need no additional configuration to get started. You can immediately start adding your application specific logic to the lib directory. As your experience with Origen grows, you can extend the origen new command to\nadd your own customized starter applications. This process is described in the\nadvanced guides, see: Creating Custom Application Generators . Documenting Your Application All new applications come with a pre-built framework for creating web-based\ndocumentation of your application - just like the page that you are currently\nreading. To build the initial example documents: origen web compile -a Then just follow the instructions to point your browser to the address that\nis output from the above command. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/architecture/": {
    "title": "Application Architecture",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Application Architecture When first using Origen to build something for a specific product, you shouldn’t\nbe overly concerned about how to scale your application to handle a large product family in the\nfuture. On the other hand, if you follow a few simple conventions early on, then you will find it easy\nto transition your application from handling a single product to multiple products if you need to\nin the future. This guide provides some advice on how to organize your early application code, and then provides\nan example of what a complex and mature Origen application eco-system might look like. Monolithic Application Architecture For anyone starting with Origen for the first time, the recommendation is always to build everything\nyou need within a single application, a so-called monolithic application. Here is a walk-through of how the code should evolve within a single application architecture… You would typically have a single target, and a single file for your code within lib : App Root (Origen.root)\n|\n+---target\n| device1.rb\n|\n\\---lib\n | device1.rb # This file is used to load everything\n | \n \\---device1\n top_level.rb # The application code lives in here As your device code grows, you might start to split it out in separate modules: App Root (Origen.root)\n|\n+---target\n| device1.rb\n|\n\\---lib\n | device1.rb # This file is used to load everything\n | \n \\---device1\n top_level.rb # Deals with top-level concerns\n adc.rb # Everything related to ADC\n ram.rb # Everything related to RAM, etc.\n flash.rb For complex modules, you might develop another layer of hierarchy: App Root (Origen.root)\n|\n+---target\n| device1.rb\n|\n\\---lib\n | device1.rb # This file is used to load everything\n | \n \\---device1\n | top_level.rb # Deals with top-level concerns\n | adc.rb # Everything related to ADC\n | ram.rb # Everything related to RAM, etc.\n |\n \\---flash\n model.rb\n controller.rb\n bist.rb At this point you should be trying to keep your code namespaced based on where it lives,\nso for example, the lib/device1/flash/bist.rb file would contain this: module Device1 module Flash # Model for the flash BIST class BIST end end end Now let’s say that the need to support a 2nd device comes along, we could start that process\nby just copying everything from lib/device1 to lib/device2 . We may also realize that we made a mistake initially by calling our app device1 , so we’ll\ntake the opportunity to rename it after the name given to the product family, let’s say family : App Root (Origen.root)\n|\n+---target\n| device1.rb\n| device2.rb\n|\n\\---lib\n | family.rb # This file is used to load everything\n | \n \\---family\n +---device1\n | | top_level.rb # Deals with top-level concerns\n | | adc.rb # Everything related to ADC\n | | ram.rb # Everything related to RAM, etc.\n | |\n | \\---flash\n | model.rb\n | controller.rb\n | bist.rb\n |\n \\---device2\n | top_level.rb # Deals with top-level concerns\n | adc.rb # Everything related to ADC\n | ram.rb # Everything related to RAM, etc.\n |\n \\---flash\n model.rb\n controller.rb\n bist.rb There is a high chance of duplication here, especially if the devices both instantiate some of the\nsame physical IP blocks. Let’s say they both use the same flash IP, in that case we can remove some\nof the duplication by popping the flash code up a level: App Root (Origen.root)\n|\n+---target\n| device1.rb\n| device2.rb\n|\n\\---lib\n | family.rb # This file is used to load everything\n | \n \\---family\n +---device1\n | top_level.rb # Deals with top-level concerns\n | adc.rb # Everything related to ADC\n | ram.rb # Everything related to RAM, etc.\n |\n +---device2\n | top_level.rb # Deals with top-level concerns\n | adc.rb # Everything related to ADC\n | ram.rb # Everything related to RAM, etc.\n | \n \\---flash # Common flash module, used by both devices\n model.rb\n controller.rb\n bist.rb For comparison, our flash bist module now looks like this: module Family module Flash # Model for the flash BIST class BIST end end end Finally, we might find that since these devices come from the same family, much of the top-level code\nmight be the same. For example, if we are creating patterns, perhaps they both use the same code to\ncreate a mode entry sequence, so we can make that common: App Root (Origen.root)\n|\n+---target\n| device1.rb\n| device2.rb\n|\n\\---lib\n | family.rb # This file is used to load everything\n | \n \\---family\n | mode_entry.rb # Common mode entry logic, shared by both devices\n |\n +---device1\n | top_level.rb # Deals with top-level concerns\n | adc.rb # Everything related to ADC\n | ram.rb # Everything related to RAM, etc.\n |\n +---device2\n | top_level.rb # Deals with top-level concerns\n | adc.rb # Everything related to ADC\n | ram.rb # Everything related to RAM, etc.\n | \n \\---flash # Common flash module, used by both devices\n model.rb\n controller.rb\n bist.rb By continuing to follow these same principles, this application can be further expanded to support many\nadditional devices features, while still being maintainable by minimizing duplication and by keeping\nthings organized. Distributed Application Architecture You can get very far by following the monolithic approach. In fact, the very first Origen application was supporting\nalmost 50 devices and had been generating production test IP for years before we decided to start splitting it up into\na more distributed architecture. The main reasons you might consider splitting up a monolithic application are as follows: All device setups within the monolithic architecture must use the same version of Origen and all of the gems\nand plugins that you use. Over time, device-specific cases might emerge which mean that a particular device\nsetup must remain on a specific plugin version. That is not possible to implement with the monolithic\narchitecture. If the number of people working on the application grows, then it might be easier to organize them around several\ndiscrete applications rather than all contributing to different areas of a single application. If a sub-module area, for example the flash in this example, becomes much larger than the rest and especially if\nit has a dedicated team supporting it, then it might be easier to manage by making it its own entity. If some of the IP within the application is re-usable within a different product family, then it may be more desirable to\nsplit out that IP to enable re-use by a 3rd party, rather than try to add more engineers and un-related product setups\ninto the original monolithic application. Here then, is a typical approach to how this monolithic application might be split up when making\nthe following assumptions: The flash is a complex IP with a dedicated team supporting it The RAM code is common to both products, but its pretty simple The ADC (at this point in time) is unique to each product and we are not sure if any of it will be re-used in future Each device is now defined and managed within a dedicated top-level Origen application. In a test engineering example,\neach application would typically be owned and managed by the lead test engineer for each device.\nThe job of this application is to implement anything that is truly device-specific, to decide what plugins are required,\nand to maintain which versions of the plugins to use. i.e. it is a bill of materials describing what components from the Origen\neco-system (meaning both internal and external to a given company) are required for the given product.\nFor that reason, these are commonly referred to as “BOM apps”: App Root (Origen.root)\n|\n+---target\n| device1.rb\n|\n\\---lib\n | device1.rb # This file is used to load everything\n | \n \\---device1\n top_level.rb # Deals with top-level concerns\n adc.rb # Everything related to ADC, seems to be product specific for now App Root (Origen.root)\n|\n+---target\n| device2.rb\n|\n\\---lib\n | device2.rb # This file is used to load everything\n | \n \\---device2\n top_level.rb # Deals with top-level concerns\n adc.rb # Everything related to ADC, seems to be product specific for now Our flash IP is managed by a dedicated team, so becomes its own Origen plugin : App Root (Origen.root)\n|\n\\---lib\n | flash.rb # This file is used to load everything\n | \n \\---flash\n model.rb\n controller.rb\n bist.rb The product team/community maintains another plugin that provides everything that is common amongst the\ndevice family, including the RAM module for now: App Root (Origen.root)\n|\n\\---lib\n | family.rb # This file is used to load everything\n | \n \\---family\n mode_entry.rb # Common mode entry logic, shared by all devices in this family\n ram.rb # RAM code shared by all devices in this family, but nowhere else for now With this distributed architecture, all duplication has been aggressively eliminated, making it very easy\nfor a central group or person, like the flash team in this example, to roll out an improved module to the\nwhole company. i.e. the flash team release a new version of their plugin, then the BOM application owners\ncan decide when they are ready to pull it in. The job of supporting a new device is now easy as well. The footprint of the top-level/BOM apps is usually very\nsmall, making it easy to create a new one, and this is typically made even easier at this point by creating a custom app generator to build them. By following these guidelines, you now have a very scalable eco-system which provides: central ownership and maintenance\nof complex blocks, re-use of IP between otherwise un-related product families, and the ability to maximise\nre-use when bringing up derivative products. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/commit/": {
    "title": "The Initial Commit",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen The Initial Commit Origen applications should be configured with details of the revision control\nrepository that they will be checked into, this will enable the following features: A release command which will tag and perform common post-release tasks. A common project-level history will be maintained, regardless of the underlying system used. An API for programmatic control of the revision control system, this provides\napplication and plugin developers with a common API to call regardless of the underlying system that\na given application uses - Revision Control API . A common command, origen rc to provide a common interface for application users to\nperform basic revision control operations regardless of their proficiency with the underlying system. Supported Systems Origen currently supports integration with the following revision control tools: Git DesignSync We would like to add support for Subversion and any other commonly used systems. If you have knowledge\nof how an additional target revision control system works and you would like to be involved in developing\nand piloting a driver for it, please get in touch via the community channels . Having said that, the Origen core team recommends using Git, even if you have had little or no\nexperience of it so far.\nIt has significant advantages and is fast becoming the de facto standard revision control tool used\nin software engineering. Initial Configuration Configuration information for your application resides in config/application.rb and an initial version of this file will have been created for you. This file contains a lot of configuration options which you should find fairly well commented.\nThe option that defines the revision control system is called rc_url and it should\nbe set as follows. For Git: # config/application.rb # Example for Github config.rc_url = \" git@github.com:myaccount/myapp.git \" # Example for Atlassian Stash config.rc_url = \" ssh://git@sw-stash.mycompany.net/myproject/myapp.git \" For DesignSync: # config/application.rb config.rc_url = \" sync://sync-1234:1234/myproject/myapp \" Setting Your Name and Email Origen will maintain a history log for your application at doc/history . The name of the person who did each release will be recorded\nif Origen can work out who you are (your name will also included within generated pattern headers\nand similar). Setting up your username and email in Git is the recommend way, even if you don’t actually\nuse Git for the given application.\nYou can set these details by executing the following commands: git config --global user.name \"John Doe\"\ngit config --global user.email johndoe@example.com If you don’t have Git available then alternatively you can set the following environment\nvariables: ORIGEN_NAME = \"John Doe\"\nORIGEN_EMAIL = \"johndoe@example.com\" You can test whether your changes have been picked up by opening an Origen console ( origen i )\nand running the following: User .current.name # => \"John Doe\" User .current.email # => \"johndoe@example.com\" An alternative path to determining your details could be via your company’s employee directory\nsystem. Origen’s company configuration settings allows\nthe credentials for an LDAP system to be entered, and this approach is used within NXP\nto identify the current user. We are not sure if the current support for this within Origen is\ngeneric enough to apply to other companies or not, please get in touch if\nyou are interested to help further develop and pilot this system for use within your company. Commit and Tag With your repository and user details setup, we can now do an initial commit and tag. Warning! - \n When executing this command pay attention to the prompts and confirm that\n the target repository reference exists and is correct. cd myapp\n\norigen rc init We are now ready to tag, to do this simply execute the following command and\nfollow the prompts: origen rc tag At this point Origen will send an email to your application’s maillist to notify them of the new release. History Your commit history will be saved in your history file which by default lives\nat doc/history . The content of that file is automatically formatted for future presentation on a web\npage, the Origen Release Notes are simply the Origen\ncore history file converted to HTML. When writing your release notes you can use markdown to control how they will be presented when they are later converted to HTML. You can also pre-write your release notes by writing them to release_note.txt in the top level of your application directory - \nrun origen rc tag -h for more details. Universal Revision Control Command Once your application has been committed for the first time you can then use the origen rc command to work with your revision control system (or you can\nof course continue to use it directly if you prefer). See origen rc -h for details of the available commands. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/company/": {
    "title": "Company Customization",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Company Customization A mechanism is provided to customize the Origen installation to a particular\ncompany. The main customization options that this currently provides are: An internal gem server. This can be used to distribute private Origen plugins\nwithin your company. When this is defined any new Origen applications that are created\nwill automatically come configured to read from your server in addition to rubygems.org. Integration with your company’s email delivery system, allowing your applications to\neasily send transactional email to their users. Integration with your company’s LDAP user authentication system. This API may not be\ngeneric enough yet, but it is used within NXP and we are keen to work\nwith anyone who wants to pilot it within another company. How The Configuration System Works Whenever an application is invoked, one of the first things that Origen will do is search\nfor a company configuration file called origen_site_config.yml . Starting from the application directory, the file system will be checked for the presence\nof any valid configuration files within the application’s config or root directories, and then in any of its parent\ndirectories until it hits the file system root directory. It will then check for a configuration file within the directory where Ruby is installed,\nand then again recursively through any of its parent directories. If multiple files are found then they will all be applied, with highest priority given\nto the files that are found first - i.e. those located closest to the current application. So for example, if everyone in your company uses a common Ruby installation, then you can put a config\nfile somewhere in Ruby’s directory and it will be globally applied. Alternatively, if all of your users have their workspaces underneath /proj or\nsimilar, then /proj/origen_site_config.yml may be a good place to put it.\nThis also provides a mechanism for per-project or even per-application overrides by\nadding additional config files higher up the tree. Creating the Configuration File To create a config file simple copy the default configuration from Origen core and edit it as required. The values present in this default file are the ones that will be applied by default in\nan installation where no custom configs are present. Testing the Configuration File To test if your configuration values are being applied, open a console within an\nOrigen application: origen i You can then query the current live values via the following API, where the method names\ncorrespond directly to the attribute names in the config file: Origen .site_config.gem_server # => nil Origen .site_config.gem_manage_bundler # => true Dynamic Configurations The Origen site config has some basic methods to dynamically get, set, and remove values. Getting Values Origen .site_config.get(var) #=> gets the current value of a site config variable 'name' #=> if var doesn't exist, nil is returned Origen .site_config.get_all(var) #=> gets all values of a site config variable 'name' #=> returns an array of values, where the higher priority values are earlier in the array #=> i.e., get_all(var).first is the current value and highest priority #=> get_all(var).last is the lowest priority value #=> same as Origen.site_config.add_as_highest(var, value) Origen .site_config[var] #=> same as Origen.site_config.get(var) Info! You can also get a value using the method name corresponding to the site config variable, \n as described in the aforementioned section. Setting Values Origen .site_config.add_as_highest(var, value) #=> add a new site variable at the highest priority Origen .site_config.add_as_lowest(var, value) #=> add a new site variable at the lowest priority #=> essentially, this sets a new default value Origen .site_config[var] = value #=> same as Origen.site_config.add_as_highest(var, value) Removing Values remove_highest(var) #=> remove the highest instance of var #=> returns the value of the variable removed #=> if var doesn't exist, nil is returned remove_all_instances(var) #=> remove all the instances of var #=> returns an array of the values, from highest priority to lowest #=> if var doesn't exist, the an empty array is returned purge(var) #=> aliase to remove_all_instances clear #=> clears the site config completely Adding New Configuration Files You can also add a new configuration file that is not in the default paths using the methods below: # Adds a new site config file as the highest priority add_site_config_as_highest(site_config_file) # Adds a new site config file as the lowest priority add_site_config_as_lowest(site_config_file) Warning Using the site config is this way requires that Origen has already booted. So, using these\n methods to dynamically change site config variables like user_gem_dir , or user_install_dir won't have the desired\n effect. Warning For append_dot_origen and append_gems , nil and false are not the same. If either of those are undefined ( nil ) they will resolve to true. To\n disable, they must be explicity set to false . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/core/": {
    "title": "Core concepts",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Core concepts There are some core concepts and terminology that should be understood up front in order for\nthe rest of the documentation to make sense. Origen Application An ‘Origen Application’ is an engineering application of some sort that has been built using the Origen\nplatform. Origen Core ‘Origen Core’ refers to the Origen platform itself.\nAlthough different applications may be using different versions of Origen core at any one time,\nit does follow a single thread of development and the latest version should be able to support\nany Origen application. Origen core (or one of its plugins) should take care of all of the common tasks that are not application\nspecific. This means that an application developer should spend most of their time working\non things are unique to their particular application domain, and not worrying about how to open a file for\nwriting, or what the vector format for a given ATE is. APIs The term API stands for ‘Application Programming Interface’, which basically means a set of methods\nthat are exposed to the application to allow an engineer to programatically tell Origen what to do or build. Origen provides various APIs for different functions such as to describe the registers within a model,\nto generate pattern vectors, to build web pages, etc. Plugins The Origen platform provides a plugin system that allows 3rd parties to develop additional APIs to\nsupplement those provided by Origen core.\nThe Origen core team maintain a collection of important plugins which are considered extensions of\nOrigen core, but anyone in the community can create and share a plugin. Application owners can control what versions of what plugins are used in their application. Origen also has a mechanism for companies to maintain an internal plugin repository so that its plugin\nsystem can be used to internally distribute proprietary code such as test blocks for a given silicon\ntechnology. Ruby Ruby is the programming language that has been used to create Origen, all Origen applications are\nalso written in Ruby. Anatomy of an Origen Application An Origen application is comprised of the following main components: Models Models are the foundation of an Origen application and encapsulate all meta-data about the silicon\nobject that they represent.\nThis can include but is not limited to: registers and bits, pins, and specs. \nModels can also instantiate other models, thereby allowing a full hierarchical representation of the target\ndevice to be constructed. The models also track state (while generating a test pattern for example), with the register and pin\nobjects behaving much like their silicon counterparts. Controllers Controllers are a concept used in test engineering applications, where each model is assigned\na controller that will be responsible for defining APIs to perform pattern operations based on the\ngiven model. For example, the controller for a analog-to-digital converter (ATD) model might define a ‘convert’\nmethod. This method would define\nthe sequence of register transactions that are required to do an ATD conversion. A ‘method’ by the way, is simply a function that is associated with a given object in a object-oriented\nprogramming language. Drivers Drivers, is the term generally used to refer to objects that control a protocol (e.g. JTAG) or some\npiece of non-silicon hardware like a tester for example. There is no dedicated Driver class in Origen and these will usually be constructed from the same\nOrigen APIs as used for Models and Controllers. Indeed the drivers could well be composed of a model\nof the associated hardware and a controller for it. Target While your application could define many different models for different silicon products, the\nonly one that matters at any one time is the one that you are targeting - that is the one that the\ngiven output should be compatible with or represent. An application can have many targets where each one is responsible for instantiating a model (or models)\nthat represent a single runtime condition or context that Origen should apply when\ngenerating content. In test engineering applications, it is usual for the target to instantiate a single top-level\nmodel called $dut , representing the device under test. Generally the term ‘target’ is used to refer to the current combination of target + environment… Environment The environment can be thought of as a higher level target, which is used to define runtime setup that can\nbe used in conjunction with many different targets. In test engineering applications, it is usual to use the environment to instantiate the target\ntest platform, normally this is assigned to the global variable $tester . Templates Origen has two main ways of generating dynamic ASCII output, the first is via the use of templates.\nThis is the most flexible way of generating dynamic content - the application provides a template\nfile which has been marked up with where dynamic content should go, Origen will then process it\nwithin the context of the current target to generate a target specific version. Origen does not care about what the template represents and it could be anything from design IP, to\nweb pages, to tool configuration files. Sources The second way of generating content is via APIs. In this case the generated content comes from\ncalling Origen methods via Ruby code, rather than from compiling a pre-written template.\nFor example, when creating a test\npattern the act of writing a register can be expressed via an API - $dut.myreg.write!(0x5) -\nwhich will then be translated into the necessary vector stream by Origen. The files which co-ordinate the APIs to build a specific output are called source files. For test engineering applications, source files are used to describe patterns and test flows, though\nOrigen does also support a source-less approach to pattern generation based on the pattern name. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/gems/": {
    "title": "Understanding Gems",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Understanding Gems Ruby gems is the de facto standard package manager used by the Ruby community. This allows Ruby code\nto be packaged up so that it can be used throughout the community while being maintained from a single source. RubyGems.org provides free, centralized hosting for these gems and anyone\ncan create a new gem and upload it there. The job of a dependency manager is to resolve the gem version requirements\nof all gems used within an application (an application can depend on a gem, which may itself depend on\nother gems), so that they will all have access to a runtime environment containing the correct versions\nof the gems that they need.\nAt the time of writing, the Ruby gems system does not provide dependency management and this roll is\nfulfilled by a 3rd party tool called Bundler (though it is planned for Bundler to be integrated into Ruby\ngems in future). Origen and all of its plugins are distributed as Ruby gems and Bundler is used for the dependency\nmanagement. This guide will teach you how to use Ruby gems within your applications, tell you what you need to\nknow about using Bundler within the context of an Origen application, and give you an appreciation for\nhow the Origen runtime environment works. Specifying Gems Every Origen application has a file named Gemfile in its root directory, this is where\nthe gem dependencies for the given application will be specified. Here is an example Gemfile: source ' https://rubygems.org ' gem ' origen ' , ' >= 0.5 ' gem ' origen_debuggers ' gem ' roo ' gem ' origen_testers ' , path : ' /path/to/local/origen_testers ' gem ' origen_jtag ' , git : ' https://github.com/Origen-SDK/origen_jtag.git ' , ref : ' ad323f ' Points to note on the above: The source line specifies the gem library where the gems are hosted, in the Ruby community every\ngem is hosted on rubygems.org. Multiple sources can be used, and in practice for an Origen application this\nmeans that you can also add a company internal gem server to host private Origen plugins ( see below ). The origen gem import line shows how you can specify a dependency on a specific (or in this case minimum)\nversion of a given gem. See this section section of the RubyGems.org documentation for details on how to specify version numbers within a semantic\nversioning system. The origen_debuggers and roo lines show how to add Origen plugins and non-Origen\ngems to your application - the process is identical. Note that with no version specifier the latest production\nversion will be fetched when your gem bundle is built. The origen_testers line shows how to use a local copy of a given gem/plugin, this allows you\nto make changes to the given gem to add a feature or fix a bug, and then try it out within your application.\nOrigen will not allow execution with a path reference in production mode, since it is an inherently a non-reproducible\nenvironment for the future. Git references can also be used, here to pick up a specific commit of the origen_jtag gem direct from its repository. This can be used to pick up a pre-release version of a gem that contains\na specific feature or bug fix that you need immediately. The Gemfile system is provided by Bundler and the Bundler guide on Gemfiles can be consulted for more information. Importing Gems Origen takes care of setting up Bundler so that it will work in the common corporate scenario where the\nuser does not have the root access required to install the gems to the system Ruby installation.\nTo ensure that Bundler is properly configured, it is critical that an Origen command is run first in\na new application workspace, before any attempts are made to run Bundler directly. A common way of doing this is simply to run the origen -v command upon first setting\nup a new application workspace. This command will invoke Bundler with the required configuration\nautomatically and all of the required gems will be installed to ~/.origen/gems . Unfortunately Origen has not yet managed to completely wrap Bundler and sometimes there will be a\nneed to invoke it directly.\nThis usually occurs when you have changed the version requirements of a particular gem within\nyour Gemfile. Once you have changed the requirement you should run: bundle update <gem_name> This will tell Bundler to update the version of the given gem, but leave the versions of everything else\nas they are. Sometimes however the new version of the given gem will itself require a new version of\nsome other dependent gem, in that case you will get an error and you can try running this command\nto resolve it: bundle If you still have an error, then updating the complete bundle will resolve it: bundle update Note that this will fetch the latest version of every gem in your bundle that has an open-ended\nversion dependency. This can result in more changes to your environment than you really want/need\nand is therefore usually best kept as a last resort. Company Internal Gems As experience with Origen grows, you will begin to start creating your own plugins/gems, many of\nwhich will contain company proprietary IP that you will not want to release via the open source\ncommunity.\nTherefore a way of privately hosting these gems is required. An easy way of doing this initially is to use Git as the revision control tool for your plugins,\nthen you can use Git references within your Gemfiles as discussed above. A better solution though, is to setup a gem server within your company intranet, and we recommend this server .\nYou will likely need to work with your IT department to get this setup and maintained. When it is available, simply update your Gemfiles with the additional server like this: source ' https://rubygems.org ' source ' https://gems.mycompany.net:9292 ' gem ' origen ' gem ' private_test_block ' #... At that point you should also update your company’s Origen configuration with the details of the new server, in that way the origen new command will automatically\nconfigure your new applications with the required source reference in the Gemfiles. Gemfile.lock A file called Gemfile.lock will be created by Bundler in the application’s top-level\ndirectory and this should be checked into the revision control system. The purpose of this file is to record the absolute versions of all gems that are currently\nused by the given application. This means that when another developer, or one of your application’s\nusers, checks out a given version of your application into a new workspace, then the exact same\ngem versions will be used as when it was originally tested and checked in. This means that it safe (and in fact recommend) to leave the gem versions largely unspecified by your Gemfile,\nas it does not mean that different user environments will be running different gem versions. Executables If your gems provide command line executables that you wish to run, then these need to be invoked through\nBundler to make them run within the context of the application’s gem environment (bundle).\nSay for example that a given gem provides an executable called clean , then to run this from your\napplication’s command line you should do: bundle exec clean This applies to the origen executable too, however as this is cumbersome to write and\neasy to forget, Origen employs some tricks that will enforce this wrapping automatically, so Origen\ncan always be invoked with just: origen <command> Bundler will build wrapped executables within an application’s lbin directory, these\ncan be invoked directly without the need for the bundle exec prefix, so for example the clean executable could be correctly invoked by running: ./lbin/clean This is arguably easier to write than bundle exec , but it can still be easy to forget. Therefore\nif your application has a need to run 3rd party executables a lot, then it is recommend to add\nthe application’s lbin directory to your path so that you can simply run: clean System Origen It was noted in the Origen installation guide that the base Origen version installed to your system Ruby does not really matter, and it does not need to\nbe updated to the latest version of Origen on a regular basis. This is because the base Origen is only used to either create a new Origen application, or to initially\nboot an Origen command within an existing application. In both cases, the version used to initially boot\nOrigen is unimportant. In the case of creating a new application, Origen will always pull in the latest and greatest application generator\nand this is not statically linked to the version of Origen that is being executed to build the new app.\nSimilarly, when running an Origen application the thread will immediately switch over to run the version\nof Origen specified in the Gemfile instead of the system version. This system therefore ensures that application owners are in control of what version of Origen is used by\nthe users of their application, however neither the application owner or their users need permissions to\nupdate the system Ruby installation in order to achieve the required runtime environment.\nThey simply checkout the version of the given application that they want, and then Origen/Bundler\ntakes care of guaranteeing that the runtime environment is the correct one. Warning! Although the above note is true for most cases, there are two corner cases. The first is\n any changes to the boot process will that version of Origen. For example, some of the following guides will discuss moving\n around install directories, but this requires later versions of Origen to accomplish. You can check the release notes\n for when features were added.\n \n The second case is for running plugins from system gems. However, the gem install process will update\n the Origen version for you, so this is more of an FYI in case you see your Origen version change after installing\n a plugin in the system Ruby. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/installing/": {
    "title": "How to Install",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen How to Install Origen can be installed on Linux or Windows, this guide refers to the Linux installation. If running on windows is of interest then please see this guide instead: How to Install Origen on Windows Background Origen is distributed as a Ruby gem, which is the Ruby language’s package manager. Installation of Origen consists of the following steps: Install Pre-Requisites Install Ruby Install Origen Customize your installation (optional) 1. Install Pre-Requisites To install Ruby, your system will need a C compiler and the Make utility. Installation of this\nwill vary depending on your particular Linux distribution, but for example on Ubuntu\nthe required build environment can be installed by running: sudo apt-get install build-essential It is also recommend to install a recent version (2.x) of Git, if you don’t know how to\ndo that, google for “how to install Git on <your distribution>“ . 2. Install Ruby Origen requires a minimum Ruby version of 2.1.0 , you can install this or the latest version. If you are working from a personal Linux box (or VM), or if you want to install Ruby for\nyourself only, we recommend that you install it via rbenv and follow these installation instructions . This will install Ruby to your home directory and will not require you to have root access. If you are working from a corporate environment where a central Ruby installation will\nbe used by many users, we recommend that you follow the instructions on the official Ruby installation guide . Most likely building from source will be the most appropriate choice in this case, especially\nif dealing with an older Linux distribution, since the version available from your system’s\npackage manager will probably be quite old. If you have any particular problems installing Ruby, please use this discussion thread so that we can build up a record of common problems and solutions. 3. Modify Your $PATH All Origen applications will create an lbin directory that contains the origen executable (and others), you should add these directories to your $PATH . Executing this command will do that for bash: echo 'export PATH=\"./lbin:$PATH\"' >> ~/.bashrc 4. Install Origen Once you have Ruby successfully installed, Origen can be installed very easily via: gem install origen --no-rdoc --no-ri You can then verify Origen availability by running origen -v at which point you should see something like this: Origen: 0.35.0 Congratulations, Origen is now installed! Note that the version of Origen that is installed to your Ruby installation does not need to\nbe kept up to date with the latest version of Origen. You can now consider your Ruby environment\nto be frozen for the foreseeable future. See the section on Understanding Gems for details on\nwhy that is. A Note on Nokogiri A common problem with the final step of installing Origen is to run into problems installing\na gem called Nokogiri (which is one of Origen’s dependencies). Generally the more recent your Linux distribution is, the less likely you are to have problems\nwith this. It is beyond the scope of this document to deal with likely causes and solutions, however if\nyou do run into problems google should yield plenty of hits of similar cases and hopefully\nwith guidelines on how to fix it. You can also report problems via this Origen forum thread on Nokogiri Installation Issues and we will do our best to provide help, or you can actually just comment below… Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/installwin/": {
    "title": "How to Install (Windows)",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen How to Install (Windows) Origen can be installed on Linux or Windows, this guide refers to the Windows installation. If you want to run on Linux then please see this guide instead: How to Install Origen on Linux Last updated on 15th February 2017 The vast majority of Origen use in production is on Linux, and over time this Windows guide can\n become out of date and no one realizes.\n If you do experience any issues when following this guide, then please do let us\n know via the comments below and we will update it as required. 1. Install a Better Console Download Console by following this link . Move the .zip file to C:/Program Files , then right click it and select Extract All... . Open the unzipped folder and right click on Console.exe and select Send to > Desktop (create shortcut) . Open the console from your desktop and execute the following command, we recommend that you create all of\nyour Origen application workspaces in C:\\origen : mkdir C:\\origen Select Edit > Settings from the console menu and enable the checkbox at the bottom\nof the settings called Save settings to user directory . Execute the following command to get a sensible set settings to start off with: @powershell New-Item -ItemType directory -Force -Path %appdata%\\Console; (new-object System.Net.WebClient).DownloadFile('https://origen-sdk.org/files/console.xml','%appdata%\\Console\\console.xml') Opening the Console The rest of this guide requires you to open the console with administrator privileges and then execute\n the given commands, do this by right-clicking on the desktop shortcut you just created and selecting Run as administrator . Some of the operations will require that you open a new console session in order for the previous operation\n to take effect. If any errors are encountered please start a new console session and try again before\n reporting it. 2. Install Pre-Requisites Before starting this next section you should ensure that the following environment variables\nare set if your computer accesses the internet via a proxy (the proxy url here is an example and\nthe real one will be specific to your company environment): HTTP_PROXY = https://proxy.my_company.com:8080\nHTTPS_PROXY = https://proxy.my_company.com:8080 Here is a link to a 3rd party tutorial on How to Create an Environment Variable in Windows . The next step is to install a package manager, please copy the text below into the console (running as administrator) @powershell -NoProfile -ExecutionPolicy Bypass -Command \"iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\" Now re-open the console (Run as administrator) Install some required packages by running these commands from the console: choco install git -y --force\nchoco install unxutils -y --force\nchoco install consoleZ -y --force Now re-open the console (Run as administrator) 3. Install Ruby 3.1 Install the Ruby Executable choco install ruby -y --version=2.3 --force\nchoco install ruby2.devkit -y --force Now re-open the console (Run as administrator) Execute the following command from the console: 3.2 Install RubyGems @powershell (new-object System.Net.WebClient).DownloadFile('https://rubygems.org/downloads/rubygems-update-2.7.3.gem’,'C: ubygems-update-2.7.3.gem') && gem install --local C: ubygems-update-2.7.3.gem && update_rubygems --no-ri --no-rdoc && gem uninstall rubygems-update -x The version of Ruby is just a recommendation from the Origen development team. Origen has proven to\n work on several versions of Ruby. However, changing the version of Ruby may also require you to reevaluate\n the version of RubyGems used. For example, we've found that Ruby 2.2.4, is not fully compatible RubyGems 2.6.7,\n for all gems (we run into issues with Symlinks on Windows that are resolved by updating RubyGems) but\n it works with RubyGems 2.2.3. Also, the version of RubyGems that ships with your installation of Ruby may be\n fine. See the RubyGems website for additional details. The conclusion of this alert box is don't stress too much about the exact versions you're using and if you\n run into issues installing gems, consider possible incompatabilities between the versions of Ruby, RubyGems,\n or the gem that you are trying to install. You can also use RubyGems to manually install the gems yourself,\n to bypass any installation options Origen may try to set. Open C:\\tools\\DevKit2\\config.yml in your favorite editor and write this at the\nbottom: - C:/tools/ruby23 Save it, and then execute the following commands from the console: cd C:\\tools\\DevKit2\\\nruby dk.rb install Ensure that you see the following output when running the above command, if not review\nwhat you have added to C:\\tools\\DevKit2\\config.yml : [INFO] Installing 'C:/tools/ruby22/lib/ruby/site_ruby/2.2.0/rubygems/default\n[INFO] Installing 'C:/tools/ruby22/lib/ruby/site_ruby/devkit.rb' Now re-open the console (Run as administrator) 4. Install Origen Finally, run this command to install Origen: gem install origen --no-ri --no-rdoc This can take several minutes to finish without updating the screen, so please be patient. You can then verify Origen availability by running origen -v at which point you should see something like this: Origen: 0.35.0 Congratulations, Origen is now installed! Some users have reported an error at this point which complains about the HOME environment variable not being set. If you see that, set it to something like this by\nfollowing this 3rd party tutorial on How to Create an Environment Variable in Windows : HOME = C:\\Users\\my_user_id Note that the version of Origen that is installed to your Ruby installation does not need to\nbe kept up to date with the latest version of Origen. You can now consider your Ruby environment\nto be frozen for the foreseeable future. See the section on Understanding Gems for details on\nwhy that is. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/introduction/": {
    "title": "Introduction",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Introduction Welcome to the Origen guides! The Origen platform is written in Ruby\nand following this documentation will take you from a complete beginner to an\nOrigen expert. However, help is always at hand and if you have a question that is not covered by these guides,\nor if you find that something is unclear, then the best place to get help is to ask a question on Stack Overflow , using the origen-sdk tag. This site is focussed specifically on the Origen API, but for background on Ruby the\ninternet is your friend.\nRuby is very popular for web development and as such it is extremely easy to Google\nfor solutions to any Ruby-related problems that you may come across, or to find\ntutorials from which to learn. The official Ruby website contains a quick tutorial on Ruby to get you started: Ruby in 20 Minutes Previous engineers who have learned Ruby have recommend the following resources: Learn Ruby at rubymonk.com Learn Ruby at codeacademy.com Ruby for Newbies Video Tutorials Ruby Koans If you want to use regular expressions in your code the following website is invaluable: Regular Expression Editor Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/invoking/": {
    "title": "Invoking Considerations",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Invoking Considerations As you may have noticed, running origen or origen -h gives you a different set of commands\ndepending on where you run. When you invoke Origen, one of the first things it will do is figure out what\ntype of invocation you’ve issued. The type of invocation isn’t something you need to control neccessarily, \nbut its important to understand why Origen’s behavior seems to arbitrarily change. Application Invocations When you invoke Origen from within an application (or a plugin), you’re using Origen’s application invocation .\nThis will most likely be the invocation used for any test or product engineer that is not creating a new application. \nYou’ll notice that when you first run\nOrigen from an application, you’ll see Bundler start to do some stuff… but what’s it doing? Bundler is building\nup a custom bin folder ( lbin , to be exact) which it will channel future invocation within the\napplication through. This ties this particular application to the gems specified in the Gemfile and gives\nyou the application invocation . So, what does that mean? Application invocations begin by booting up the application and all needed plugins. The\nbest way to see that will be to just run origen -h from inside and outside an appication. When running\nfrom within an application, you’ll get the core application commands, \nany Shared Commands from plugins, and any Global Commands from plugins. Global Invocations Global Invocations are the opposite of the aforermentioned Application Invocations . These\ninvocations are obviously for when origen is run without any application. The default core global commands are just new and interactive . This makes sense, since its not\nappropriate to create a new application if you’re already running from one, and when there is no application you’ll\nmost likely want to create a new one. You can see here for creating a new application . However, global invocations can also run other global commands . This allows Origen to become a platform\nfor tool distribution, allowing for developers who use Origen to use all that Origen offers to build and distribute\nother tools or scripts. Using global commands may require a bit of additional setup. The commands that are available depend on\nhow exactly the global invocation was induced. There are multiple ways to do this, as described in\nthe next section. Note that this section only covers invocations. For a guide on how to actually create global commands, please see the section on global commands . System Invocations For new Origen users, this will be the most likely way of globally invoking Origen. This runs Origen straight from\nthe system installed gem (i.e., what was installed when you ran gem install origen ).\nOrigen invocations stemming from the this are known as system invocations . When these occur, Origen will search through all of the dependencies of each gem that is currently installed on the\nsystem. If any of these gems have origen as a dependency, then Origen will assume that it is a plugin and\nboot that gem during Origen’s own booting process. Thus, it is possible to install plugins that have global commands and also have them active by just running gem install . Since these are available at the system level, if this is done on a shared system or on a server, all users will\nsee those commands become available. User Invocations System invocations have the potential problem of requiring administrative access rights. When running on your own\nsystem, this is not an issue, but when run on corporate accounts, most users won’t have these permissions. User installations are more involved. These require using the site config to indicate to Origen that you have a global Gemfile setup somewhere. The full details are beyond a\nstartup guide, so this is marked as an advanced topic and can be found here Please don’t let that scare you away. However, a tool distribution platform is not Origen’s primary purpose,\nso unless you know you’ll need it, you can skip the advanced topic until you have more familiarity with Origen. The basic procedure is: Create a custom site config in your Origen home directory. Enable users installs. Add dependencies to your user Gemfile . Not that bad, right? If this seems like something you’d like to tackle now, go ahead and check out the topic here . Once this is setup, invoking Origen through this Gemfile is known as User Invocation . Tool-Repo Invocations Tool Repo invocations look very similar to user invocations. However, the usage for these is different.\nThese installations are built and maintained by an experience user and has the purpose of giving a set of users, or\nusers running from a particular directory, access to a pre-built dependency set. At this point, you will most likely be a user of such an invocation. If so, you would have received some instructions\nfrom the installation manager on how to use it. Setting these up is an involved process. An advanced topic on this is also\navailable in the advanced topics . \nFor now, that is all that will be said on Tool Repo invocations. Info! Each one of these cases above, and the application invocations , are handled independently.\n That is, installing a gem in the system ruby, or installing it in your user install will NOT enable\n that gem to be used in all your applications. Likewise, installing a gem in the system ruby will not make it\n attainable automatically in all tool repo installs or in your user install. This is so the Gemfile remains the master dependency list, with the only exception being the system install which has no Gemfile . So, if you want to use a specific gem for all your applications, tool repo installs, and\n your own user install, you will have to add it to the Gemfile of each. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/workspace/": {
    "title": "Workspace and Dependency Management",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Workspace and Dependency Management This guide provides advice on how to create new application workspaces and how to\nsafely update your application’s dependencies. This advice is particularly critical when running in a corporate Linux environment where\nthe Linux distribution is older and/or you don’t have permission to write to the\nsystem Ruby installation. Fix My Workspace The most important takeaway from this guide is to add the origen_updater plugin to your\napplication, this provides a command which should fix your workspace if you ever end up\nin a situation where the origen or bundle commands are no longer working. Add it to your application’s Gemfile like this: # Gemfile source ' https://rubygems.org ' gem ' origen_updater ' Note that if your application is a plugin you should always add this to your Gemfile too,\ni.e. don’t put it in the .gemspec. After adding it for the first time run: origen -v This will invoke the plugin and it will create a new executable in your\napplication - bin/fix_my_workspace . This file should be committed to your revision control system to ensure that it is\nalways available to you in the future . It’s contents may be changed automatically from time-to-time if you upgrade\nto a new version of the origen_updater plugin, in which case the changes should be committed\nto revision control too. To fix your workspace at any time simply run: ./bin/fix_my_workspace Creating a New Workspace Creating a new workspace means setting up an existing application within a new directory\nfor the first time. The most important thing to remember in this case is to always run origen -v as the first step after importing the application files from your revision control system. Doing this ensures that Origen provides some basic configuration of Bundler which will ensure that it runs well within a restricted corporate environment. After doing this for the first time, you can then safely run the bundle command\ndirectly if you want to. If you forget to do this and run bundle first, then you can recover by running\nthe fix_my_workspace command as described above. Updating Dependencies Updating dependencies means changing the version of a given gem/plugin within your Gemfile\nor .gemspec. In some cases (depending on what gems you already have installed locally), you can simply make\nthe edit and then continue running the origen command without any problems. If you don’t already have the gem version installed locally, you will get a Bundler error which may or may not clearly describe the problem. The easiest way to resolve things at this point is to simply run the fix_my_workspace command as described above. Alternatively, following this sequence will create a working environment with the new dependency\nin most cases: > bundle\n\n// If that doesn't work try this, where gem_name is the name of the gem you just updated in\n// your Gemfile/.gemspec\n> bundle update <gem_name>\n\n// If that doesn't work try this, this will completely re-build your gem bundle, which will pull in the\n// latest versions of all gems which satisfy the rules defined in your Gemfile\n> bundle update Workspace Size Considerations By default, all downloaded dependencies are placed in the home_dir , which is likely pointing to ~/.origen/gems . However, gems can be large,\nand bigger projects (or working on several unrelated projects) means that the gems directory can\nquickly swell in size. This can be problematic particularly on corporate Linux systems, which usually do not\nhave sufficient home directories to handle the size and quantity of gems we are dealing with. There are a few\nways to deal with this. Bundle Clean Bundler comes with its own clean-up command. Running bundle clean when inside\nof an application will remove all of the ‘unused’ gems currently taking up space, where ‘unused’ gems are defined\nas gems not currently being used by the current application. This can be a quick solution if you know that you have\nseveral old, outdated gems that will likely never be used again. The only down side being other applications\nwill require you to reinstall gems that running bundle clean deleted. You can see bundler’s own documentation on this feature by running bundler clean -h at your\nconsole, or be visiting the bundler docs . Relocating Your Gems Individually, you can control where your gems are installed by using either the site configs ,\nor by setting an environment variable . This will build or rebuild all of your gems at that\nlocation, which is generally a project drive or somewhere else where space is less of an issue. You can set the site config variable user_gem_dir to point to the new location that you\nwish your gems to be installed at. Alternatively, you can set the environment variable ORIGEN_USER_GEM_DIR to accomplish the same in a more ‘linux-like’ way. Recall from the site config page that environment variables will overrule\nsite config variables. Info! This will only move the location of the downloaded gems. It will not change the\n full install directory, meaning that your Origen session , \n logs, and global Gemfile will stay in your home_dir .\n These items are small, and should not fill up even a minimal, corporate Linux home directory. For details on\n moving this as well, please see the advanced topic here . Warning! If you are doing this inside of an application, you will need to remove the .bundle and lbin directories to see this take effect. These store links and\n configuration settings to your original gems directory. Don't worry though, Origen will rebuid them for you,\n with the updated gem directory this time. Deprecation Warning! To support older applications, the site variable gem_install_dir and its environment variable counterpart ORIGEN_GEM_INSTALL_DIR are still valid. However, these fulfill the same\n purpose as user_gem_dir , with user_gem_dir taking precedence. Tool Repo (TR) Directories Origen supports setting up Tool Repository gem builds. This is considered an advance topic, and can\nbe difficult to implement unless you are familiar with Origen’s boot process and site configs, but it mentioned\nhere as being an effective means for advanced users or project managers to oversee a group of user’s gem\ninstall directories. For additional details, please see the advanced topic on invoking Origen . Configuring the Home Directory Location The previous section is an example of using the site config to manage your gems workspace. However,\nthere’s more to the workspace than just the gems directory. The workspace is divided into three sections: The Origen Home Directory: Essentially Origen’s scratch space. The User’s Installation Directory: Location where user installation customizations can be found. The User Gem Directory: Location to install the gems. The above list is a top-down listing of the sections, but we’ll actually discuss in detail from the bottom-up view.\nEach of the sections can be customized using the site config . Evaluating Paths Before we get started, the variables user_gem_dir , user_install_dir , and home_dir will be evaluated as paths , meaning that there’s some magic that happens between what you type into the\nsite config, and what actually gets used. This involves: The ~ means username . For example, if I’m logged in as coreyeng , the path /proj/~/my_origen becomes /proj/coreyeng/my_origen . The path is evaluated per Ruby’s File.expand_path .\nMeaning that a leading ~/ becomes /home/coreyeng or C:/users/coreyeng (or whatever your OS evaluates ~/ to). Not starting the path with either ~/ or / is a relative path, where the current path is\nprepended. For example, running from /proj/my_project and using origen/~ becomes /proj/my_project/origen/coreyeng . You can escape the ~ using the \\ symbol. If the path provided already ends with the append_dot_origen or append_gems , then those\nwill not be reapplied ( append_dot_origen and append_gems will be covered in the next section). User Gem Directory The user gem directory indicates where the gems should be installed. Moving this directory around will\nchange where Bundler places all of your gems. There are three site config variables to consider. Below are those variables as well as some examples of how to use them. Default: If no user_gem_dir is specified, the gem directory falls back to home_dir . # By default, user_gem_dir defaults to wherever the home directory is. # origen_site_config.yml append_dot_origen : true # Appends .origen to the path append_gems : true # Appends gems to the path # In interactive session Origen .site_config.user_gem_dir #=> '/home/<username>/.origen/gems' Move the user_gem_dir # origen_site_config.yml user_gem_dir : /proj/my_gems/ append_dot_origen : true append_gems : true # In interactive session Origen .site_config.user_gem_dir #=> '/proj/my_gems/.origen/gems' Set append_dot_origen and append_gems to false to have them removed # origen_site_config.yml user_gem_dir : /proj/my_gems/~ append_dot_origen : false append_gems : false # In interactive session Origen .site_config.user_gem_dir #=> '/proj/my_gems/<username>' Set append_dot_origen and append_gems to custom values to have the moved # origen_site_config.yml user_gem_dir : /proj/my_gems/ append_dot_origen : my_workspace append_gems : .my_gems # In interactive session Origen .site_config.user_gem_dir #=> '/proj/my_gems/my_workspace/.my_gems' To review quickly, you can move the install directory for the gems by moving </code>user_gem_dir</code>. By default,\nthis will automatically append .origen/gems to the directory path, unless append_dot_origen and append_gems specify otherwise. Deprecation Warning! This warning from the previous section is repeated here:\n To support older applications, the site variable gem_install_dir and its environment variable counterpart ORIGEN_GEM_INSTALL_DIR are still valid. However, these fulfill the same\n purpose as user_gem_dir , with user_gem_dir taking precedence. User Installation Directory The user_install_dir indicates where the user’s customization settings are located. Right now, this\nonly includes where the global Gemfile can be located, but site configs can also be\nlocated there. Future user customization settings will also use this directory location. Default: If no user_install_dir is specified, the home_dir is used instead. # Default # origen_site_config.yml append_dot_origen : true # Appends .origen to the path. # In interactive session Origen .site_config.user_install_dir #=> '/home/<username>/.origen' Move the user_install_dir append_dot_origen : true user_install_dir : /proj/~/install # In interactive session Origen .site_config.user_install_dir #=> '/proj/<username>/install/.origen' Disable appending .origen # Note this also affects the user_gem_dir append_dot_origen : false user_install_dir : /proj/~/install # In interactive session Origen .site_config.user_install_dir #=> '/proj/<username>/install' Origen .site_config.user_gem_dir #=> '/proj/<username>/install/gems' Customize the appended directory # Note this also affects the user_gem_dir append_dot_origen : my_origen user_install_dir : /proj/~/install # In interactive session Origen .site_config.user_install_dir #=> '/proj/<username>/install/my_origen' Origen .site_config.user_gem_dir #=> '/proj/<username>/install/my_origen/gems' Home Directory The home_dir takes care of everything else. In general, this acts as Origen’s scratch space. For example,\nthe LSF logs and the global session are stored in this location. Default : if no home_dir is specified, it defaults to ~/, which will be expand\nto your home directory (for example, /home/coreyeng on Linux, or C:\\users\\coreyeng on\nWindows). home_dir is also the topmost path. So, if user_install_dir and/or user_gem_dir are not defined, they default back to home_dir . If no home_dir is specified, ~/ is used # Default # In interactive session Origen .site_config.home_dir #=> '/home/<username>/.origen' Origen .site_config.user_install_dir #=> '/home/<username>/.origen' Origen .site_config.user_gem_dir #=> '/home/<username>/.origen/gems' Move the home_dir # origen_site_config.yml home_dir : /proj/origens/~ # In interactive session Origen .site_config.home_dir #=> '/proj/origens/<username>/.origen' Origen .site_config.user_install_dir #=> '/proj/origens/<username>/.origen' Origen .site_config.user_gem_dir #=> '/proj/origens/<username>/.origen/gems' Move the home_dir and disable append_dot_origen # origen_site_config.yml home_dir : /proj/origens/~ append_dot_origen : false # In interactive session Origen .site_config.home_dir #=> '/proj/origens/<username>' Origen .site_config.user_install_dir #=> '/proj/origens/<username>' Origen .site_config.user_gem_dir #=> '/proj/origens/<username>/gems' Move the home_dir and change append_dot_origen # origen_site_config.yml home_dir : /proj/origens/~ append_dot_origen : .my_origen # In interactive session Origen .site_config.home_dir #=> '/proj/origens/<username>/.my_origen' Origen .site_config.user_install_dir #=> '/proj/origens/<username>/.my_origen' Origen .site_config.user_gem_dir #=> '/proj/origens/<username>/.my_origen/gems' Closing Thoughts The purpose of having all these site configs variables is to allow full customization when desired, but be able to simplify\ncommon usages. For example, if you want to move your entire .origen from your home directory to some\nproject directory, you only need to move home_dir . Everything else will go with it. But, if you want to\nleave your custom user setup and be able to get all the logs and global session in your home directory but just move\nwhere all your gems are stored, you can do that too. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/plugins/": {
    "title": null,
    "subtitle": null,
    "body": ""
  },
  "/publications/": {
    "title": null,
    "subtitle": null,
    "body": ""
  },
  "/release_notes/": {
    "title": null,
    "subtitle": null,
    "body": ""
  },
  "/videos/1-pattern-in-20-minutes/": {
    "title": "Create a Semiconductor ATE Pattern in 20 Minutes",
    "subtitle": "Videos",
    "body": "Videos Create a Semiconductor ATE Pattern in 20 Minutes Learn how to build a basic IP model and then use this to create a single-source pattern to target multiple ATEs and devices. Code Comments References Full source code on Github Defining registers Controllers Common tester API Code IP Model and Controller # lib/atd_test/atd.rb module ATDTest class ATD include Origen :: Model def initialize (options = {})\n instantiate_registers(options) end def instantiate_registers (options = {})\n reg :sc1 , 0x0 , size : 32 do |reg|\n reg.bit 7 , :coco , access : :ro reg.bit 6 , :aien reg.bit 5 , :diff reg.bit 4 .. 0 , :adch end reg :r , 0x10 , size : 32 do |reg|\n reg.bit 15 .. 0 , :d end end end end # lib/atd_test/atd_controller.rb module ATDTest class ATDController include Origen :: Controller def convert (channel)\n ss \" Performing an ATD conversion on channel #{ channel } \" sc1.adch.write!(channel)\n tester.wait time_in_us : 100 sc1.coco.assert!( 1 )\n r.d # Return the result bits end end end Test Pattern # pattern/atd_convert_ch10.rb Pattern .create do result = dut.atd0.convert( 10 )\n result.store! end Device Models and Controllers # lib/atd_test/falcon.rb module ATDTest class Falcon include Origen :: TopLevel def initialize (options = {})\n instantiate_pins(options)\n instantiate_registers(options)\n instantiate_sub_blocks(options) end def instantiate_pins (options = {})\n add_pin :tclk add_pin :tdi add_pin :tdo add_pin :tms add_pin :resetb add_pins :port_a , size : 8 end def instantiate_registers (options = {}) end def instantiate_sub_blocks (options = {})\n sub_block :atd , instances : 2 , class_name : ' ATD ' , base_address : [ 0x1000_0000 , 0x1000_1000 ] end end end # lib/atd_test/falcon_controller.rb module ATDTest class FalconController include Origen :: Controller include OrigenNexus # Hook the Nexus module into the register API, any register read # requests will use the Nexus by default def read_register (reg, options = {})\n nexus.read_register(reg, options) end # As above for write requests def write_register (reg, options = {})\n nexus.write_register(reg, options) end def startup (options)\n pp ' Enter test mode ' do tester.set_timeset( ' func_25mhz ' , 40 ) # Where 40 is the period in ns pin( :tclk ).drive!( 1 )\n pin( :resetb ).drive!( 1 )\n nexus.jtag.write_ir( 0x5 , size : 8 )\n nexus.jtag.write_dr( 0x25 , size : 16 )\n tester.wait time_in_us : 100 end end def shutdown (options)\n pp ' Reset the device ' do pin( :resetb ).drive!( 0 )\n pin( :tclk ).drive!( 0 ) end end end end # lib/atd_test/eagle.rb module ATDTest class Eagle include Origen :: TopLevel def initialize (options = {})\n instantiate_pins(options)\n instantiate_registers(options)\n instantiate_sub_blocks(options) end def instantiate_pins (options = {})\n add_pin :swd_clk add_pin :swd_dio add_pin :tclk add_pin :resetb add_pins :port_a , size : 8 end def instantiate_registers (options = {}) end def instantiate_sub_blocks (options = {})\n sub_block :atd , instances : 2 , class_name : ' ATD ' end end end # lib/atd_test/eagle_controller.rb module ATDTest class EagleController include Origen :: Controller include OrigenARMDebug include OrigenSWD def read_register (reg, options = {})\n arm_debug.read_register(reg, options) end # As above for write requests def write_register (reg, options = {})\n arm_debug.write_register(reg, options) end def startup (options)\n pp ' Enter test mode ' do tester.set_timeset( ' func_25mhz ' , 40 ) # Where 40 is the period in ns pin( :tclk ).drive!( 1 )\n pin( :resetb ).drive!( 1 )\n tester.wait time_in_us : 100 end end def shutdown (options)\n pp ' Reset the device ' do pin( :resetb ).drive!( 0 )\n pin( :tclk ).drive!( 0 ) end end end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/videos/2-model-data-import/": {
    "title": "Model Data Import and Documentation",
    "subtitle": "Videos",
    "body": "Videos Model Data Import and Documentation Learn how to import register data in IP-XACT format into a model and then generate a documentation view of it. Code Comments References Full source code on Github Cross Origen plugin Documentation Helpers plugin Example Model Documentation Callbacks Code Application Integration # lib/atd_test/atd.rb module ATDTest class ATD include Origen :: Model include CrossOrigen def initialize (options = {})\n cr_import( path : \" #{ Origen .root } /ipxact/atd.xml \" ) end end end # config/application.rb def after_web_site_compile (options) # Build the model documentation OrigenDocHelpers .generate_model_docs layout : \" #{ Origen .root } /templates/web/layouts/_basic.html.erb \" , tab : :model do |d|\n d.page model : $dut end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/videos/3-the-compiler/": {
    "title": "The Compiler",
    "subtitle": "Videos",
    "body": "Videos The Compiler Introduction to some basic features of the Origen compiler. Code Comments References Full source code on Github Compiler Guide Code Templates # templates/demo/_layout.txt.erb\nThis is the header <%= yield %> This is the footer # templates/demo/_sub_example.txt.erb\nHello from the sub template!\n\nThe value of argx is: <%= options[ :argx ] %> # templates/demo/example1.txt.erb\n% render \"layout.txt\" do\n\nHello from template example 1\n\n10 + 10 = 20\n\n% # This is a Ruby comment, it will not appear in the output\n\n% 10.times do |i|\nThis is loop <%= i %> % end\n\n% if 10 == 20\nThis is the true case\n% else \nThis is the false case\n% end <%= render \" templates/demo/sub_example.txt \" , argx : 100 %> % dut.atd0.regs.each do |name, reg| <%= name %> % end\n\n% end # templates/demo/example2.txt.erb <%= render \" templates/demo/sub_example.txt \" , argx : 200 %> Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/videos/4-create-header/": {
    "title": "Using the Compiler to Create a C Header",
    "subtitle": "Videos",
    "body": "Videos Using the Compiler to Create a C Header Shows a real world example of using the Origen compiler to create a C header file view of a model. Code Comments References Full source code on Github Compiler Guide Code Templates # templates/demo/atd.h.erb\n\n/* ============================================================================\n =============================== Module: ATD ================================\n ============================================================================ */\n\n% dut.atd0.regs.each do |name, reg| \ntypedef union ATD_ <%= name.to_s.upcase %> _union_tag { /* <%= reg.description.first %> */\n vuint32_t R;\n struct {\n% reg.named_bits(include_spacers: true).each do |bit_name, bits|\n% if bit_name\n vuint32_t <%= \" #{ bit_name.to_s.upcase } : #{ bits.size } ; \" .ljust( 30 ) %> /* <%= bits.description.first %> */\n% else \n vuint32_t <%= \" #{ bit_name.to_s.upcase } : #{ bits.size } ; \" .ljust( 30 ) %> % end \n% end \n } B;\n} ATD_ <%= name.to_s.upcase %> _tag;\n\n% end\n\nstruct ATD_tag {\n% dut.atd0.regs.each do |name, reg| <%= \" ATD_ #{ name.to_s.upcase } _tag #{ name.to_s.upcase } ; \" .ljust( 30 ) %> /* <%= reg.description.first %> */\n% end \n};\n\n% dut.atds.each_with_index do |atd, i|\n#define ATD_ <%= i %> (*(volatile struct ATD_tag *) <%= atd.base_address.to_hex %> UL)\n% end\n\n/* ATD */\n% dut.atds.each_with_index do |atd, i|\n% dut.atd0.regs.each do |name, reg| \n#define <%= \" ATD_ #{ i } _ #{ name.to_s.upcase } \" .ljust( 20 ) + \" ATD_ #{ i } . #{ name.to_s.upcase } .R \" .ljust( 20 ) %> /* <%= reg.description.first %> */\n% end\n\n% end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/videos/5-create-program-flow/": {
    "title": "Create a Test Program Flow for Multiple ATEs",
    "subtitle": "Videos",
    "body": "Videos Create a Test Program Flow for Multiple ATEs How to use the Origen Testers flow API to create complex test flow logic that can re-target to any platform. Code Comments References Full source code on Github Test Program Generator Guide Code # program/sort1.rb Flow .create do # This test will do something # # * Some bullets # * About this test test :test_a , bin : 3 , softbin : 100 , number : 1000 test :test_b , bin : 3 , softbin : 101 , number : 1010 , id : :test1 test :test_c , if_failed : :test1 if_job :p1 do test :p1_test1 , id : :p11 test :p1_test2 , id : :p12 test :p1_test3 , if_all_failed : [ :p11 , :p12 ]\n if_enable :bitmap do test :bitmap_test end end if_job :p2 do test :p2_test1 , id : :p21 test :p2_test2 , id : :p22 test :p2_test3 , if_any_passed : [ :p21 , :p22 ] end group \" 200Mhz Tests \" , id : :g200 do test :test200_1 test :test200_2 test :test200_3 end group \" 100Mhz Tests \" , if_failed : :g200 , id : :g100 do test :test100_1 , bin : 5 test :test100_2 , bin : 5 test :test100_3 , bin : 5 end if_job :p2 do import \" atd_tests \" , instances : 4 end pass 2 , if_ran : :g100 pass 1 end # program/_atd_tests.rb Flow .create do |options|\n\n options[ :instances ].times do |i|\n test \" atd_ramp_ #{ i } \" end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/videos/6-create-program-tests/": {
    "title": "Creating the Tests for a Test Program",
    "subtitle": "Videos",
    "body": "Videos Creating the Tests for a Test Program How to use the Origen Testers APIs to create tests for Teradyne and Advantest platforms Code Comments References Full source code on Github Test Program Generator Guide Origen Testers Release Notes Test Suite API ACTml API DCTml API Code # lib/atd_test/test_program/interface.rb module ATDTest module TestProgram class Interface include OrigenTesters :: ProgramGenerators def func (name, options={})\n name = test_name(name, options) # Create the test if tester.j750?\n ins = test_instances.functional(name) else ins = test_suites.add(name, options)\n ins.test_method = test_methods.ac_tml.functional_test(options) end apply_conditions(ins, options) # Create the pattern set entry pname = pattern_name(name, options) if tester.j750?\n patset_name = \" #{ name } _pset \" pat = patsets.add(patset_name, pattern : \" patterns/ATD/ #{ pname } .PAT \" )\n ins.pattern = patset_name else ins.pattern = pname end # Insert the test into the flow test(ins, options) end def para (name, options={})\n name = test_name(name, options) # Create the test if tester.j750?\n ins = test_instances.ppmu(name, options) else ins = test_suites.add(name, options)\n ins.test_method = test_methods.dc_tml.general_pmu(options) end apply_conditions(ins, options) # Create the pattern set entry if tester.j750?\n patset_name = \" #{ name } _pset \" pat = patsets.add(patset_name, pattern : \" patterns/ATD/ #{ pattern_name(name, options) } .PAT \" )\n ins.pattern = patset_name else end # Insert the test into the flow test(ins, options) end def apply_conditions (ins, options={}) if tester.j750?\n ins.ac_category = \" Spec \" ins.ac_selector = \" Default \" ins.dc_category = \" Spec \" if options[ :vdd ] if options[ :vdd ] == :max ins.dc_selector = \" Max \" elsif options[ :vdd ] == :min ins.dc_selector = \" Min \" elsif options[ :vdd ] == :nom ins.dc_selector = \" Default \" else fail \" Unknown vdd selector: #{ options[ :vdd ] } \" end else ins.dc_selector = \" Default \" end ins.time_sets = \" Tim \" ins.pin_levels = \" Lvl \" else ins.level_equation = 14 ins.level_spec = 1 ins.level_set = 1 end end def test_name (name, options={}) \" atd_ #{ name } \" end def pattern_name (name, options={}) \" #{ name } _pattern \" end end end end # program/sort1.rb Flow .create interface : \" ATDTest::TestProgram::Interface \" do # This func will do something # # * Some bullets # * About this test func :test_a , bin : 3 , softbin : 100 , number : 1000 , vdd : :max func :test_b , bin : 3 , softbin : 101 , number : 1010 , id : :test1 func :test_c , if_failed : :test1 func :test_d if_job :p1 do para :p1_test1 , id : :p11 , lo_limit : 10 .mV, hi_limit : 20 .mV\n func :p1_test2 , id : :p12 func :p1_test3 , if_all_failed : [ :p11 , :p12 ]\n if_enable :bitmap do func :bitmap_test end end if_job :p2 do func :p2_test1 , id : :p21 , vdd : :min func :p2_test2 , id : :p22 func :p2_test3 , if_any_passed : [ :p21 , :p22 ] end group \" 200Mhz Tests \" , id : :g200 do func :test200_1 func :test200_2 func :test200_3 end group \" 100Mhz Tests \" , if_failed : :g200 , id : :g100 do func :test100_1 , bin : 5 func :test100_2 , bin : 5 func :test100_3 , bin : 5 end if_job :p2 do import \" atd_tests \" , instances : 4 end pass 2 , if_ran : :g100 pass 1 end # program/_atd_tests.rb Flow .create do |options|\n\n options[ :instances ].times do |i|\n func \" atd_ramp_ #{ i } \" end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'https://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  }
}