{
  "/community/": {
    "title": null,
    "subtitle": null,
    "body": ""
  },
  "/guides/models/attributes/": {
    "title": "Adding Attributes",
    "subtitle": "Models",
    "body": "Models Adding Attributes Origen is an object-oriented environment and we have already seen that the application\ndomain will be modelled by creating object instances which represent the physical silicon.\nHowever the real power of object-oriented programming comes when we start assigning attributes\nto our objects. Static Attributes Continuing our example of modelling a fictional NVM module, an obvious attribute to start with is the\nsize of our NVM memory blocks, we can add this attribute like this: # lib/nvm/memory_128_b954.rb module class :: NVM MEMORY_128_B954 include Origen Model def (options={}) initialize @size_in_kb = 128 end end end is an example of an instance variable in Ruby. An instance variable\nis one where the value it contains is unique to each object instance, so for example if we have multiple\ninstances of the same class then we can update the value held by an instance variable in one of them without\naffecting the value held by the same variable in the other instances. @size_in_kb Instances variables are globally available within a class definition, in other words you can make\na reference to @size_in_kb from any methods that are defined within that class. However to\naccess them externally we need to create a getter method: # lib/nvm/memory_128_b954.rb module NVM class MEMORY_128_B954 include :: Origen Model def (options={}) initialize = @size_in_kb 128 end def size_in_kb @size_in_kb end end end In Ruby a method implicitly returns the value of the last piece of code it executed, so the method we\njust added will return the value held by .\nWe can now ask a memory block it’s size: @size_in_kb = :: $dut SOC EAGLE_M352 .new .nvm.memories.first.size_in_kb $dut # => 128 Note that we have used a method named above but we have not defined that anywhere.\nThe first memorys method created by Origen (which we aliased as memories returns the associated sub-blocks within a Ruby array. In Ruby everything\nis an object, so an array is a built-in object that comes complete with it’s own set of useful methods\nthat we can leverage.\nRuby is very well documented, here is the page describing all of the methods available to an Array: . Ruby Array Because the above example of creating a getter method is so common, Ruby provides a shorthand. We can re-write\nthe above example as: # lib/nvm/memory_128_b954.rb module NVM class include MEMORY_128_B954 :: Origen Model attr_reader :size_in_kb def (options={}) initialize @size_in_kb = 128 end end end This creates a reader (or getter) method which will look for an instance variable of the same name and\nreturn it. If the variable of the same name doesn’t exist then it will return nil . Calculated Attributes Attributes can also be derived from functions. For example within our application it may be useful to consume the size attribute in various formats,\nlet’s create a method to return the size in bytes: # lib/nvm/memory_128_b954.rb module NVM class include MEMORY_128_B954 :: Origen Model attr_reader :size_in_kb def initialize (options={}) @size_in_kb = 128 end def size_in_bytes * @size_in_kb 1024 end end end Of course such functions can also incorporate multiple attributes, here we create a method to return\nthe size in longwords: # lib/nvm/memory_128_b954.rb module NVM class MEMORY_128_B954 :: include Origen Model attr_reader , :size_in_kb :longword_size_in_bytes def initialize (options={}) @size_in_kb = 128 = @longword_size_in_bytes 8 end def size_in_bytes @size_in_kb * 1024 end def size_in_longwords size_in_bytes / longword_size_in_bytes end end end Note that sometimes you will see attribute or method references using the keyword self which means “the current instance”. Our size_in_longwords method could be re-written as: def size_in_longwords .longword_size_in_bytes .size_in_bytes / self self end Whether or not to use the self notation is really a matter of personal preference but be aware\nof it as you may see it used in other code whether or not you use it yourself. Another point to note is that the method was not written like this: def size_in_longwords @size_in_bytes / @longword_size_in_bytes end While this would have worked equally well, it is generally bad practice to reference instance variables\ndirectly and instead it is preferable to access them through a reader method, even when referencing\nthem internally. The reason for this is that if you ever need to transform or filter the value of an attribute, it can\nbe done easily in a single place if all references to the variable are made through a reader method. Dynamic Attributes Some attributes will change value during the course of executing your application, therefore in such\ncases we need a way of setting the value of the attribute in addition to reading it. Sticking with our NVM memory model such an attribute might be the value held by certain addresses in\nthe flash memory. Let’s create a new attribute to represent the data held by a location which we\nwill call . config # lib/nvm/memory_128_b954.rb module NVM class MEMORY_128_B954 include :: Origen Model def (options={}) initialize = @config_data 0xFF end def config_data @config_data end def (value) config_data= = value @config_data end end end With our new getter and setter methods for the config_data attribute we can now change\nthe value of it dynamically: $dut = :: SOC .new\n\nmem = $dut .nvm.memories.first\n\nmem.config_data mem.config_data = # => 0xFF EAGLE_M352 mem.config_data 5 # => 5 Again this is such a common pattern that a shorthand exists, to create getter and setter methods equivalent to\nthose above we can do: # lib/nvm/memory_128_b954.rb module NVM class Model MEMORY_128_B954 include Origen attr_reader attr_writer :: :config_data :config_data end end Or to create both, a further shorthand exists: # lib/nvm/memory_128_b954.rb module NVM class include MEMORY_128_B954 Origen attr_accessor :: Model :config_data end end Anonymous Sub-blocks with Attributes Sub-blocks without a specific class definition also support attributes, any attributes can either be\ndirectly written to the sub-block or supplied in the sub-block definition: class include MySoC Origen :: TopLevel def (options={})\n sub_block initialize , :ram size_in_kb : 128 ram.clk_domain = # Once defined any additional attributes can be declared on the fly :ipg end end = $dut MySoC .new $dut .ram.size_in_kb # => 128 $dut .ram.clk_domain # => :ipg $dut .ram.vendor = \" Mentor \" .ram.vendor $dut # \"Mentor\" Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/bugs/": {
    "title": "Bugs & Features",
    "subtitle": "Models",
    "body": "Models Bugs & Features The for tracking versions may seem like a\nlot of effort but it is very quick to implement additional\nconfigurations by copying and pasting the previous one, and remember that this only\nneeds to be done for revisions that make it to silicon. example code While it may seem like overkill initially, the benefit will become apparent as the\nnumber of silicon derivatives that your application must support begins to grow. By following\nthis architecture you will find that your application can scale to any number of derivatives easily and\nmost importantly you will continue to feel in control of it - especially when it comes to tracking which\nbugs and features exist on each device. Assigning Bugs to the Responsible Module A primary goal of Origen is to help with the creation of complex applications that remain easy to manage and a key\ncomponent of this is the creation of high level code flows that are both easy to follow and to understand. Therefore we do\nnot want our application to be littered with things like , but rather to use the\nmore descriptive “if the device version is 50 then do this…“ “if the device has the low reference voltage bug then do this…“ . Furthermore bugs should be assigned to the sub-block that is actually responsible for them - they should not\nbe assigned at SoC level . Adding bugs at SoC-level is equivalent to adding branches to your code like which may seem reasonable but that has proven to be the path to a maintenance\nnightmare. “if the device is an Eagle then do this…” The problem with that approach is that you have now set yourself up to have to answer the question “does this\ndevice have this bug?” for every new device that you ever add support for in the future. As the number of\ndevices and bugs (and features) grows, the number of such cases to manually track will grow exponentially. The solution to this problem is to track the bug or feature at component level and change your branch to “if the analog module in the NVM module of the current device has the low reference voltage bug then do this…“ . \nThen in the future simply add new device configurations\nby declaring the BOM as we have seen in the . versioning guide Your job is then done. This is because the bug workaround has been implemented in a way that requires no further human interaction\never again - if we create a new device that instantiates a version of the NVM analog that has the bug then\nour workaround will kick in automatically. Similarly if we add a new device which instantiates a version \nof the analog that doesn’t have the bug then the workaround will be bypassed automatically. Recording a Bug Here are some examples of adding bugs to the analog module within our example NVM module, note that bug\nmethod is a class method that must be called outside of the initialize (or any other) instance method: # file: lib/nvm/analog_t921.rb module NVM class include ANALOG_T921 Origen :: Model bug :low_vref , => :affected_version 11 bug , :low_iref :affected_versions => [ 11 , ]\n bug 12 :dac_code , :fixed_on_version => 12 bug :unfixable def (options={}) initialize end end end We have defined these bugs in terms of the affected versions and since our models already contain\nversion information the presence of bugs will be modelled accurately. We can test this in the console: # This will instantiate version 11 of the analog block $dut = SOC :: EAGLE_M352 .new( version 0 ) $dut :low_vref : .nvm.analog.has_bug?( ) # => true .nvm.analog.has_bug?( $dut :low_iref ) # => true .nvm.analog.has_bug?( $dut ) :dac_code # => true .nvm.analog.has_bug?( $dut ) :unfixable # => true # This will instantiate version 12 of the analog block = $dut SOC :: .new( EAGLE_M352 : version 1 ) .nvm.analog.has_bug?( $dut ) :low_vref # => false $dut .nvm.analog.has_bug?( ) :low_iref # => true .nvm.analog.has_bug?( $dut ) :dac_code # => false .nvm.analog.has_bug?( $dut ) :unfixable # => true When we get to the point of implementing a template or source file we will then be able to deal with these\nbugs via logic like: .nvm.analog.has_bug?( if $dut ) :low_vref # Workaround the bug else # Proceed as normal end Recording a Feature Feature identification can be added in a similar way, this API also supports optionally adding descriptions: # file: lib/nvm/analog_t921.rb module ANALOG_T921 NVM class include Origen :: feature Model :feature1 feature , :feature2 => :description \" feature2 description, this API for tools \" # This is feature 3 description, this API is for humans feature # and markdown should be used for formatting :feature3 def (options={}) initialize end end end = $dut :: SOC .new( EAGLE_M352 : version 0 ) $dut .nvm.analog.has_feature?( ) :feature1 # => true .nvm.analog.has_feature?( $dut ) :feature2 # => true .nvm.analog.has_feature?( $dut ) :feature3 # => true $dut .nvm.analog.has_feature?( ) :feature4 # => false .nvm.analog.feature( $dut ).description :feature1 # => [] .nvm.analog.feature( $dut ).description :feature2 # => [\"feature2 description, this API for tools\"] $dut .nvm.analog.feature( ).description :feature3 # => [\"This is feature 3...\", \"and markdown should be..\"] Note that it is not currently possible to track features by version like it is for bugs, however it would not\nbe very difficult to add this should the need arise. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/datasheets/": {
    "title": null,
    "subtitle": "Creating Datasheets",
    "body": "Origen provides an API for creating and manipulating datasheets within an Origen application. Datasheets are intended to provide all of the specific spec-tables, revision-history, \nand notes that are associated with a particular device. Including a datasheet in your \napplication will allow you to quickly call up any relevant information about a device\ndirectly to your console. The API is made available by including the Origen::Datasheet module. module MyApplication class TopLevel include :: Origen Datasheet # => makes the Datasheet available to application attr_accessor :datasheet end end Creating Datasheets Creating a datasheet is very simple and is demonstrated in the following code sample: module MyApplication class include TopLevel Origen :: Datasheet # => makes the Datasheet available to application attr_accessor :datasheet @datasheet = .new.ds TopLevel #=> Creates instance of a Datasheet in your application. end end Note: Creating a Datasheet in your Origen application does not physically instantiate an \nXML Datasheet, but rather an Origen model of one that is visible to your application. Importing an Existing Datasheet Through the RosettaStone plug-in, Origen is able to consume existing XML datasheets provided\nthey conform to the XML standards that the program expects. Importation is done via\nthe rs_import method like in the code sample below. The importation process is very fast in will complete in just a few seconds, even for very large XML\nfiles. module MyApplication TopLevel class include Origen :: Datasheet attr_accessor # => makes the Datasheet available to application :datasheet @datasheet = TopLevel .new.ds #=> Creates instance of a Datasheet in your application. = rs_import( @datasheet :path => \" path_to_your_datasheet.xml ) \" end end Spec Tables Spec Tables contain all of the relevant spec information for a particular device. \nAny given Spec contains information such as the Min and Max values, Note references, \nUnits, and Spec symbol, along with dozens of other possible attributes specified in the \nSpec API. Calling up Spec Tables from a datasheet to the console is very simple. All you will need is \nthe unique Spec Table ID. In the case that the specific Spec Table ID is not known, you will \nneed to follow the command examples below. .ds.spec_tables $dut # => This command lists every Spec Table in a datasheet, along with information including the ID. Once the correct ID is provided the Spec Table will be displayed on the console in a very friendly\ntable-view format. $dut .ds.spec_tables[ ] :unique_id # => Displays the Spec Table to the console You can also add a Spec Table to your datasheet and provide your own values if necessary. This\nis shown below. Information you want to specify is done like this! @datasheet .spec_table :unique_id |t|\n t.full_name = do \" \" end Revision History Often it is useful to know a datasheet has changed over time, and the revision history contains \nexactly that information. A Revision History is organized into a list of different Versions, \nwhere each Version lists every change that was made to the datasheet. Calling up information from the Revision History is very simple. If you are unsure of exactly\nwhich version you will need to look at, the below command will display a list of different Versions\nfor a datasheet’s Revision History, along with some information about each Version including the \naccess-key for each one. $dut .ds.revision_history # => diplays a list of each Version in a Revision History To view a specific Version use the following command .ds.revision_history.versions[ $dut ] :access_key # => displays the version to the console! Each Version will display a small table with the specific information concerning that version, \nas well as the list of changes displayed as text. Notes Notes provide engineers a way to include extra information about a Spec that may not\nfit into a specific attribute. Each note contains information like the item_area, the note text,\nand a unique ID for easy referencing and retrieval. Typing the following command into the Origen console will display a list of all notes and their IDs \nassociated with the datasheet. .ds.notes $dut If you would like to get a specific note use the following command .ds.notes[ ] $dut :note_id Searching Sometimes when a datasheet is very large it’s not always convenient to spend time looking up\ndifferent IDs to get the information you want. Currently, searching can be performed on Spec Tables\nand Notes. The way to perform a search is outlined in the following command examples. ) => this will display every .ds.spec_tables.search( $dut \" search_string \" Spec that matches Table \" search_string. \" $dut .ds.notes.search( ) => displays every note corresponding to \" search_string \" search_string. \" \" Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/defining/": {
    "title": "Definition & Hierarchy",
    "subtitle": "Models",
    "body": "Models Definition & Hierarchy Creating A Model A model can be any class that includes the Origen::Model module, this will give you access to\nall Origen APIs for defining registers, pins, etc. and generally makes Origen aware of any instances of the\nmodel when you instantiate them. class MyModel include :: Origen Model end As a general rule ,\neven if the model is\nnot of an SoC or an IP block and the concept of registers and pins does not apply.\nThere is not really any downside to including these APIs if you are not going to use them and this\nmodule is the main mechanism to hook your class into the Origen ecosystem. include the Origen::Model module every time you create a new class in Origen Creating A Top Level Model If a given model represents the top-level of an device then you should also include the module, this specifically lets Origen know that it is a top-level model and as such it holds a special\nplace in the Origen runtime environment - for example any register write requests will be sent to this\nobject for dispatch. Origen::TopLevel Internally the Origen::TopLevel module includes the module and\ntherefore it does not need to be specifically included in top-level model classes (although there is\nno harm from doing so). Origen::Model TopLevel class MySoCModel :: Origen include end While you can define multiple top-level models only one of them can be instantiated\n per target or Origen thread of execution. Attempts to instantiate a 2nd top-level object will raise an error. Warning! Regardless of what name is given to an instance of a top-level class it can always be looked up via Origen.top_level or more simply . All Origen developers can rely on this\nconvention to access the current top-level object: $dut soc = .new MySoCModel Origen .top_level == soc # => true $dut == soc # => true Modelling Hierarchy by Example As your experience with your application grows, the way to partition your models for easiest maintenance\nand development will start to become clear. At that point you may feel decide to start introducing\nabstract classes to handle the concepts that exist within your domain and which don’t necessarily have\na direct counterpart in the physical domain. However to get started we recommend that you closely follow the physical architecture of your target device, where\neach of the main IP blocks that you care about has an associated model. In this example we are going to set up an Origen model structure that will allow us to write some \ntest code for a fictional NVM module contained within an SoC. The Top Level We are going to call our application ‘NVM’ and all of our code will reside in the NVM namespace. However\nthe top-level SoC model is something of a special case because potentially it could be shared by many\napplications - e.g. an application concerned with testing the SRAM could re-use our SoC model. So to set us up to handle that eventuality in the future let’s put all of our top-level definitions into\ntheir own namespace which\nwe will call . Here is how to define the top level model: SOC # lib/soc/eagle_m352.rb module SOC class include Origen :: EAGLE_M352 TopLevel def (options={}) initialize end end end The initialize method will automatically be called by Ruby whenever a new instance of this class is\ninstantiated - so this is a place to do any setup or initialization that is required whenever a new\nEagle model comes into being. At this point we have also chosen to have this method optionally accept a hash of options, we will do this\nalmost every time we define a method since it builds in great flexibility and the ability to handle\nadditional arguments in future that we may not have thought about when first defining a new method. Interacting with Our New Model Our first model is now defined and we can now go and talk to it for the first time, to do so start\nan interactive Origen session from your terminal: origen i This command loads up an interactive Ruby terminal and automatically loads Origen and your application, so we can\nnow experiment with our models: $dut = SOC :: .new .is_a?( $dut SOC :: EAGLE_M352 EAGLE_M352 ) # => true Above we simply instantiated a new instance of our class, and then asked it if it was an instance of SOC::EAGLE_M352 , to which it replied: ‘yes’. Adding Sub Blocks Sub-blocks should be used to model IP blocks or indeed any sub-components within that IP, a generic sub-block\ncan be declared very simply within the top-level’s initialize method: # lib/soc/eagle_m352.rb def (options={})\n sub_block initialize :nvm end By default this will instantiate an object that includes all of the usual Origen APIs (regs, pins, etc.) and \nthis can then be decorated as required by the application (see example below). Most importantly this wires up\neverything internally such that the relationship between the child and the parent are known to Origen and it\nwill automatically build an accessor to get the child module: = $dut :: SOC .new EAGLE_M352 $dut .nvm # => Generic Origen object .nvm.parent $dut # => $dut $dut .children # => {:nvm => <object>} .nvm.reg # Decorate as required by calling Origen APIs on the object $dut :reg1 , 0x30 |reg|\n reg.bits do .. 31 0 , :data end # The NVM now has a register available... $dut .nvm.reg1.write( 0x1234 ) The above approach is ideal where the models are being built from a 3rd party data source (e.g. standard XML)\nand all that is required is to get an Origen object representation of the same data. However in cases where more native richness is required you can supply a class for the object,\nlet’s create a dedicated model for our NVM IP: # lib/nvm/nvm_m682.rb module NVM class include NVM_M682 :: Origen Model def initialize (options={}) reg # Add an example register :reg1 , 0x30 do |reg|\n reg.bits 31 .. , 0 , :data reset : 0xFFFF_FFFF end end end end This follows the same pattern as our first model, note the use of the NVM namespace and the\nsubsequent storage of the file in the directory rather than lib/nvm lib/soc . We can now refer to this class in our sub-block definition and verify that the register we added is available: initialize # lib/soc/eagle_m352.rb def (options={})\n sub_block , :nvm class_name : \" NVM_M682 \" end = :: SOC # => 0x30 $dut .new EAGLE_M352 $dut .nvm.reg1.address $dut .nvm.reg1.data # => 0xFFFF_FFFF Wash, Rinse, Repeat This process can now be repeated to model the complete design hierarchy, the sub_block method\ncan be used within sub-blocks themselves with no limit on depth. Here are the complete set of initial stub models for the Eagle and it’s NVM module: module SOC class include Origen TopLevel # lib/soc/eagle_m352.rb EAGLE_M352 :: def (options={})\n sub_block initialize :nvm , class_name : \" NVM_M682 \" end end end # lib/nvm/nvm_m682.rb module NVM class include NVM_M682 :: Origen Model def initialize (options={})\n sub_block , :analog class_name : sub_blocks \" ANALOG_T921 \" :memory , class_name : MEMORY_128_B954 , \" \" instances : sub_block 4 :state_machine , : class_name \" \" CONTROL_D345 end # Origen is not yet smart enough to correctly pluralize 'memory', but we # can manually add this method to create a better experience for our users def memories memorys end end end # lib/nvm/analog_t921.rb module NVM class include ANALOG_T921 :: Origen Model def initialize (options={}) end end end # lib/nvm/memory_128_b954.rb module NVM class include MEMORY_128_B954 :: Origen Model def (options={}) initialize end end end # file: lib/nvm/control_d345.rb module NVM class include CONTROL_D345 :: Origen Model def initialize (options={}) end end end A couple of points are worth noting from the above code: The namespace reference is not required when making references to other models/classes within the\nsame namespace. Multiple instances have been specified for the memory sub-block. By convention use the\nsingular for the name, i.e. , and then Origen will automatically create\naccessors called :memory memory0 , , etc., and a method to get an\narray of all sub-blocks called memory1 memorys . Origen is not yet smart enough to generate\nthe correct English pluralization in this case, , but hopefully in future it will.\nIn the meantime we have manually created a memories memories method which will simply call\nthe method that Origen created. memorys The classes for the various NVM sub-blocks are all empty right now and as such they did\nnot really need to be defined, however these are placeholders for us to go on and add more\nlogic in the future. Even though we have not yet added any logic to our models they are starting to become useful,\nfor example we can now ask the Eagle how many NVM memory blocks that it has: $dut = SOC .new :: EAGLE_M352 .nvm.memories.size $dut # => 4 Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/hw/": {
    "title": "Hardware Attributes",
    "subtitle": "Models",
    "body": "Models Hardware Attributes The need to model abstract hardware properties can sometimes arise, most\ncommonly when generating a view of the models which needs to contain some detailed\ninformation about the RTL architecture - generating an IP-XACT view of the IP for use\nin verification would be a good example of this. HDL Paths For designers using Origen as the master definition of their registers and other metadata, it\nis always preferable to setup the Origen models to mirror the eventual hierarchy of\nthe RTL.\nIn that case nothing special is required to extract HDL path information and the path method available on all sub-blocks, registers and bits should do a\ngood job: .atd.path $dut # => \"mydut.atd\" (Where 'mydut' is the lowercased class name) $dut .atd.reg1.path # => \"mydut.atd.reg1\" .atd.reg1.data.path $dut # => \"mydut.atd.reg1[15:0]\" (Where 'data' are some named bits in reg1) However in cases where that is not possible the following API exists to reconcile\nany differences. For any point in the tree the default can be overridden by setting the @path instance variable within the\ngiven object, this can also be supplied at sub-block declaration time. e.g. class MyDut include :: Origen TopLevel def sub_block initialize :atd class_name : , ATD , \" : base 0x1000_0000 , : \" \" \" path atds.atd0 end end .atd.reg1.data.path $dut # => \"mydut.atds.atd0.reg1[15:0]\" .atd.path = $dut \" atds.atd1 \" $dut .atd.reg1.data.path # => \"mydut.atds.atd1.reg1[15:0]\" Layers can be taken out of the hierarchy altogether by setting the path attribute to : :hidden sub_block :atd class_name : \" , , \" ATD : 0x1000_0000 : .atd.reg1.data.path $dut base , path :hidden # => \"mydut.reg1[15:0]\" Register and bit definitions can also be given a path override: reg :reg1 , 0 |reg|\n reg.bits do .. 31 , 0 :data reg end :reg2 , , 0x4 : path \" reg2_reg \" do |reg|\n reg.bits .. 31 0 , :data end reg , :reg3 0xC , : path \" reg3_reg \" do |reg|\n reg.bits .. 31 0 , , :data path : \" data_reg \" end reg1.data.path reg2.data.path # => \"mydut.atd.reg1[15:0]\" # => \"mydut.atd.reg2_reg[15:0]\" reg3.data.path # => \"mydut.atd.data_reg\" Note that in the case of the path being given to the bits it bypasses the\nregister altogether, to include the register prefix the bit path name with\na . reg :reg3 , 0xC , : path \" reg3_reg \" do |reg|\n reg.bits .. 31 0 , , :data path : \" \" .data_reg end reg3.data.path # => \"mydut.atd.reg3_reg.data_reg\" Absolute Paths Sometimes for a given node that is handled ‘unusually’ in RTL it is easier just\nto give an absolute path, the abs_path attribute can be set in\nplace of the attribute for any of the examples above. path When resolving paths from a child object the final path will be returned\nimmediately when an absolute path is encountered, this is best shown by example: sub_block sub_block :sub1 , sub_block :sub2 : path \" memory_block.ram \" :sub3 , : abs_path \" \" sub1.reg1.path p2.flash # => \"p1.sub1.reg1\" (where p1 is the path of the parent) sub2.reg1.path # => \"p1.memory_block.ram.reg1\" sub3.reg1.path # => \"p2.flash.reg1\" Registers and bits will also accept in place of abs_path path . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/introduction/": {
    "title": "Introduction",
    "subtitle": "Models",
    "body": "Models Introduction Models are at the heart of an Origen application and can be thought of as\nobject representations of the silicon in the application domain.\nModels can instantiate other models and they can be nested arbitrarily deep\ndepending on the needs of your application. For example, if your application is only concerned with generating dynamic \ndocumentation for a small number of devices, then it may be sufficient\nto have a single model representing each device. If on the other hand, your application is concerned with generating complex\ndesign or test code, then a lot more information will be encapsulated within your\nmodels. In these cases your application will be much easier to manage\nusing multiple models\nto represent the sub-blocks that make up the device or module in\nquestion. Model responsibilities include but are not limited to: Defining the architecture of the target device Defining what bugs or features are present in the target device Defining register and bit maps Defining any other attributes of the target device, e.g. memory size Within the Origen ecosystem, the model is intended to be the master of\nthe universe and everything from documents, to test patterns, even to\nthe design IP itself, can be considered different ways of viewing or consuming the\nmodel. It is important to spend\nthe time to architect the models in an organized manner and one which closely\nresembles the silicon that you are trying to represent.\nOnce the solid model foundation is in place, it then becomes very easy to decide\nwhere to add additional data in the future. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/modes/": {
    "title": "Package, Mode & Configuration",
    "subtitle": "Models",
    "body": "Models Package, Mode & Configuration A given SoC or IP block can typically operate in various modes or configurations\nand may have its feature set modulated by the package that it is in. The following APIs allow such concepts to be modelled so that they can then be used\nto scope things like pin availability. Package This represents the package that the device is in, however this could be a real physical\npackage or a pseudo package such as the subset of pins available to a given probecard.\nThe package is an a SoC attribute and therefore this API is only available to models\nthat include the module. Origen::TopLevel A simple package definition requires simply supplying a name for it, here are\nsome examples but the names are completely arbitrary and you can use whatever you\nlike: class MyDut include :: Origen TopLevel def initialize add_package add_package :probe :mapbga add_package :qfp end end By default the model will boot with no package set, this state would be used\nto represent the die with all pins exposed. The package state can then be changed as shown: .package $dut # => nil .package = $dut :mapbga .package $dut # => <mapbga package object> $dut .with_package :qfp do .package $dut # => <qfp package object> end .package $dut # => <mapbga package object> Packages are objects (an instance of the Origen::ChipPackage class)\nand additional attributes can be set at definition time like this: def add_package initialize :t2080 |package|\n package.number_of_rows = do 16 package.number_of_columns = 16 end add_package :t4080 do |package|\n package.number_of_rows = package.number_of_columns = 32 32 end end $dut .package = :t2080 $dut .package.number_of_columns # => 16 .package = $dut :t4080 $dut .package.number_of_columns # => 32 See the ChipPackage API for the up to\ndate list of available attributes. Mode This represents which mode the device is in, again this can represent a real operating mode\nsuch as user, functional test, RAMBIST, etc. or some abstract concept that is specific to the\ngiven domain. The mode API is available to any object that includes and therefore\nsub-blocks can also define their own modes and have a mode context independent of the top-level\nobject. Origen::Model Modes are defined and set in the same way as packages, here are some examples: Origen class MyDut include :: TopLevel def initialize add_mode add_mode :user :rambist end end .mode .mode = $dut # => nil $dut :user $dut .mode # => <user mode object> .with_mode $dut :rambist do .mode $dut # => <rambist mode object> end $dut .mode # => <user mode object> Note that like packages the modes are represented by objects which can be assigned attributes,\nsee the ChipMode API for the up to\ndate list of available attributes. Mode objects do support a convenience API for checking the current mode: .mode.user? $dut # => false .mode.rambist? $dut # => true Configuration This is another layer which supports the concept that different configurations may exist within\nthe one mode. More generally it is simply another scope that the application can use to describe\ndifferent states/configurations. Like modes, the configuration API is available to any object that includes and therefore\nsub-blocks can also define their own configurations and have a configuration context independent of the top-level\nobject. Origen::Model Here are some examples: class include :: Origen MyDut TopLevel def initialize add_mode add_mode :user :bist add_configuration :nvm add_configuration :ram end def enter_rambist_mode .mode = self :bist .configuration = self :ram # In a test application you would generate the necessary vectors to actually do this here # Upon exit from this method 3rd parties will now be able to tell that the DUT is in RAMBIST mode/configuration end end .enter_rambist_mode $dut # => nil .mode.bist? $dut # => true .configuration $dut # => :ram Note that currently the configuration is not represented as an object and therefore cannot\nstore additional attributes associated with the given configuration. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/naming/": {
    "title": "Naming",
    "subtitle": "Models",
    "body": "Models Naming One of the hardest things in computer science is said to be naming things. Model naming convention may vary from company to company, but we recommend aligning to whatever\nsystem is used by the hardware design teams. In other words the Origen model name for a given\nIP should be the same as whatever the RTL or macro is called for the corresponding object in the\ndesign world. The overall goal is to eliminate ambiguity and end up with a system where it straightforward to\nidentify what silicon IP is represented by a given Origen model. Class Naming Each of your model definitions will be a Ruby class and it is required by Ruby that the class\nname starts with a capital letter. It is also Ruby convention to use CamelCase for class names,\nhowever in our experience this is not necessarily easy to stick to if you are also trying to\nkeep your class names in sync with a 3rd party naming system as recommended above. If not following CamelCasedNaming, then we recommend that you uppercase and underscore\nTHE_CLASS_NAME for consistency. It is Ruby (and Origen) conventions that each class is contained within it’s own file that\nhas been assigned the lower_cased_and_underscored version of the class name. So for example the model for EAGLE_M352 would look like this: # lib/eagle_m352.rb class EAGLE_M352 # Model definition and logic goes here end Namespacing Namespacing your code is good practice and is also recommended, in Ruby a namespace involves wrapping\nall of your code in a uniquely named module. For example all of the Origen code is contained within the namespace and this\n(as we will see shortly) is why the Origen register API is accessible via Origen Origen::Registers instead of just Registers . The name used for the namespace should uniquely identify your application within your ecosystem,\nif you were writing an application to test a RAM module at a 28nm node for example, then you might go\nwith simply . C28RAM The namespacing is also mirrored in the file system hierarchy, so all of the files for C28RAM should live in . lib/c28ram Wrapping the above example in the namespace would change it to: # lib/c28ram/eagle_m352.rb module C28RAM class EAGLE_M352 # Model definition and logic goes here end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/parameters/": {
    "title": "Parameters",
    "subtitle": "Models",
    "body": "Models Parameters A given model, or indeed an application, will often have some parameters associated with\nit.\nWhile any standard Ruby accessors and instance variables can be used to define such\nparameters the following API is provided to define them in a standardized way. The \nadvantages to using this API vs. a roll-your-own solution are as follows: The API provides a number of features that go above and beyond what basic Ruby\nattribute accessors provide, this would require significant application-side code to\nreplicate Using standard APIs gives your code a familiar look and feel to any new developers who\nmay work on it in future You will be able to benefit from future additions to the Origen ecosystem that hook into\nthis API, e.g. a documentation helper to automatically generate a parameter summary\nwill almost certainly emerge Basic Idea Parameters are defined as a group of named values that will apply in a given context, many\ndifferent sets of values to apply in different contexts can be defined.\nA context can be used to represent any abstract concept that you like, but a good example \nwould be to have a set of parameter values that will apply at probe, a different set for final test and a\ndifferent set for spec operation. The current parameter context can be set and changed dynamically at runtime as required\nby your application, typically this would be set on a per-target/environment basis or for pattern\ngeneration on a per-pattern basis.\nA common approach for pattern generation is to leverage and employ the convention that the first field in the pattern name refers to the spec\ncontext - e.g. probe_mypat, ft_mypat, spec_mypat.\nIt is then trivial to set the parameter context based on the pattern name, thereby providing a bulletproof way to update any\ngiven parameter for every probe pattern by simply updating its value in the probe parameter\nset definition. sourceless pattern generation Including the Parameters API To use the parameters API in an abstract class the following module can be included: include Origen :: Parameters However this is already included the and Origen::Model modules and any class which includes those will already have access to this API. Origen::TopLevel Defining a Set of Parameters Parameters are defined as shown below, it is always a good idea to create a parameter\ncontext called , these are the values that will be enabled when\na parameter context has not explicitly been set: :default define_params :default |params|\n params.tprog = do .uS\n params.terase = .mS 20 100 end Parameters can be organized into namespaces by simply writing them, no upfront definition\nis required and there is no limit to how deeply nested they can be: |params|\n params.program.time = define_params params.test.dc.vdd.max = :default do .uS\n params.erase.time = 20 .mS\n params.erase.pulse_count = 100 params.test.dc.vdd.min = 10 1.5 2.5 end Parameters are read back in application code via the params method: params.test.dc.vdd.min # => 1.5 Each namespace in the chain returns an object that can be used like a hash: params.erase.each def print_erase_parameters |name, value|\n puts do #{ value #{ \" \" name } : } end end print_erase_parameters # => time: 0.1 # => pulse_count: 10 The current parameter context is set as follows: params.context params = # => :default params.context :probe # => :probe with_params :ft do params.context # => :ft params.context end # => :probe Tracking the Context of Another Object The parameter context for a given object can be configured to automatically track that of another object by\nspecifying a Ruby path to the object to be tracked as shown below: # A short hand is available to track the parameter context from the top level ($dut) class include MyObject Origen :: parameters_context Model :top end # Or you can supply a path to the object in the form of a string, here the path reference is local to the MyObject # instance class MyObject include :: Origen parameters_context Model ' parent.mbist ' end # Or another example where the target object is found via the global scope class MyObject include Origen :: Model parameters_context ' $dut.pll ' end Then whenever the parameter context is set on the tracked object the same context name will be applied\nwhen referencing a parameter within the tracking object, for example: $dut .params.context my_object.params.context # => :default # => :default $dut .params.context = :probe $dut .params.context my_object.params.context # => :probe # => :probe Late Defined Parameters Occasionally the need may arise to base a parameter value on a property of the model\nor the wider environment that is not yet finalized or known at the time when the parameter\ndefinition code is being executed.\nIn that case the parameter can be defined as a function and Origen will hold off evaluating\nit until the last possible moment when it is first referenced: define_params do |params|\n params.test.dc.vdd.min = -> { :default $dut .vdd * 0.9 } end Such parameters will behave identically to standard parameters in all respects and consumers\nwill not be able to tell if a given parameter originated from a function. Defining Child Sets Complete parameter sets can be defined for different named contexts, however in many cases\nonly a subset of the parameters will have different values vs. another context.\nTo make maintenance of such cases efficient the API allows parameter sets to be defined in a\nhierarchy such that a given set can be defined with a parent and if it does not define\na value for a given parameter then the value from the parent will be returned instead. define_params , :ate : inherit :default do |params|\n params.erase.time = .mS 40 define_params end :probe , : inherit :ate do 20 5 end |params|\n params.erase.time = .mS\n params.erase.pulse_count = define_params , :ft : inherit :ate |params|\n params.erase.pulse_count = do 7 end with_params :probe params.program.time do params.erase.time # => 20uS (inherited from :default) # => 20ms params.erase.pulse_count # => 5 end with_params :ft do params.program.time params.erase.time # => 20uS (inherited from :default) params.erase.pulse_count # => 40ms (inherited from :ate) # => 7 end Sometimes the parameter definition for a child context should be a function of the\nvalue from the parent, when defining a child context the parent can be accessed\nlike this: define_params :ate , : inherit :default do params.test.dc.vdd.min |params, parent|\n params.test.dc.vdd.min = parent.test.dc.vdd.min * params.test.dc.vdd.max = parent.test.dc.vdd.max * 0.9 1.1 params.context end # => :default # => 1.5 params.test.dc.vdd.max # => 2.5 params = params.test.dc.vdd.min :ate params.test.dc.vdd.max # => 1.35 # => 2.75 Live Updating Parameters When a parameter is referenced a static value is returned which thereafter has no\nrelationship to the current parameter context, for example: terase = params.erase.time\nparams.erase.time terase params = # => 100ms params.erase.time terase # => 100ms :probe # => 20ms # => 100ms The above should not be surprising and is what would normally be expected, however\nthrough the magic of Ruby a live updating parameter can be returned by referring\nto it via : params.live terase = params.live.erase.time\nterase params = # => 100ms terase :probe # => 20ms This is an experimental feature and developers are encouraged to play around with it and\nreport back on any useful applications that they may find for it.\nPotentially this is a good way to expose parameters via an interface to 3rd parties without coupling\nthem tightly to the namespacing and organization of the parameters within the owning class. It is certainly only really useful when applied in conjunction with parameter contexts that can\nchange within the scope of a pattern or other Origen thread of execution. While the examples\nso far have focussed on parameter contexts that will be permanent for a given thread,\nlike probe or ft, contexts can be used to represent more dynamic concepts. For example a given\nNVM pattern may read the flash under different read conditions where the configuration for\neach one is modelled by parameter contexts defined within the read controller. Another possible use case is to bind register bit values to parameters, due to the way\nthat Origen stores register data at bit level a register cannot simply be written to a live\nparameter, however a dedicated API is provided for this case: reg , :erase 0x0 bits do .. 3 , 0 :pulses end erase.pulses.data erase.pulses.bind params.live.erase.pulse_count\nerase.pulses.data # => 0 # => 10 params = :probe erase.pulses.data # => 5 In other words anytime that register gets written in the course of a pattern generation\nrun its value will automatically track the current parameter context. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/pins/": {
    "title": "Pins",
    "subtitle": "Models",
    "body": "Models Pins Origen provides a pin (and pin group) API that should be used to define and manipulate the\nphysical pins of the device. Pins are mainly intended to be defined on models that will be used for pattern generation\nand where the pins represent the physical device pins that the tester can interact with.\nHowever in its basic form a pin is just an object that can hold a data state and there\nare probably some creative uses of the pin models outside of pattern generation. The pin API is made available to your model by including the or Origen::TopLevel modules. Origen::Model While pins can be added\nfrom any sub-module the ownership of all pins is always assigned to the top-level object,\nthis is reflecting real life where the pin is a physical property of the top-level SoC.\nTherefore it is recommended that pin definitions are always made on the top-level object\nand most modern Origen applications now take this approach. Defining Pins Pins should be defined as part of the object initialization process, but to avoid the\ninitialize method growing out of hand it is recommended that pins are instantiated in a\ndedicated method that is called upon initialization. Here is an example of how to define some JTAG interface pins in an SoC model: include :: class MySoC Origen TopLevel def (options={})\n instantiate_pins(options) initialize end def (options={})\n add_pin instantiate_pins , :tclk : reset :drive_hi add_pin :tdi , : direction add_pin :input , :tdo direction : :output add_pin :tms end end Some points to note in the above code: will instantiate an instance of add_pin Origen::Pins::Pin Each pin must be given a name, or handle, similar to how registers are named. However unlike\nregisters . The easiest way to comply with this requirement\nis to follow the advice of handling all pin definitions at the top level. the name must not only be unique within the parent object but it must also be unique\nwithin the scope of all objects instantiated by a target Pins are initialized in the don’t care state by default, an alternative default state can be specified via\nthe :reset option. Pins are I/Os by default, however they can be defined as input or output only by using the option. :direction Pins are accessed via the method: pin .pin( ) $dut :tdi # => <pin object> Note that pins can be accessed locally from any object that includes the module: Origen::Model .pin( $dut :tdi ) == $dut .memories.rambist.pin( ) :tdi # => true However references to pins within a sub-block would typically use an alias that reflected the pin function related to\nthat sub-block. Pin aliases are added like this: has_pin?( ) :tdi has_pin?( # => true ) # => false add_pin_alias :bisti has_pin?( :bisti , :tdi ) :bisti # => true pin( :bisti ) == pin( ) :tdi # => true Or called directly on the pin: pin( ).add_alias( :tdi :bisti ) Defining Pin Groups Pin groups are modelled by an object called a which is very similar in principle to the BitCollection used for modelling registers.\nA PinCollection is essentially an extension of a regular Ruby\narray object which has some of its own attributes (such as an id for example) and everything else is proxied to\nthe contained pin objects. PinCollection For pattern generation pins and pin groups will support the same API so that application code does not have to\ngive much concern as to whether it is dealing with one or the other. Pin groups are defined in a similar manner to single pins: add_pins :porta , size : add_pins , 32 :portb size : 16 , endian : :little Some points to note in the above code: will generate a new pin group, e.g. named add_pins :porta .\nSee below for how to define pin groups based on existing pins. and individual pin\nobjects named through :porta0 :porta31 Pin groups can be any size, define via the :size option. Pin groups are big endian by default, however little endian can be specified via the option. Changing this attribute will have the effect of reversing the\norder that data is applied in a test pattern. :endian Pin groups can be looked up like regular pins, or via a dedicated method if it makes application code clearer: pins( ) :porta pin_group( # => <pin collection> ) :porta # => <pin collection> A pin group is a regular Ruby array and can be iterated on and so on: ).size pins( :porta # => 32 pins( ).each :porta do |pin| # Do this for pin :porta0, :porta1, etc. end Within a pin group individual pins can be addressed via a local index: pins( )[ :porta ] == pins( 0 :porta0 ) # => true Anonymous pin groups can be composed from a range of indexes at runtime: pins( ).data :porta # => 0x0000_0000 pins( )[ :porta , 0 1 , 2 , 3 ].drive( )\npins( 0xF :porta ).data # => 0x0000_000F pins( :porta )[ .. 8 15 ].drive( 0x55 )\npins( ).data :porta # => 0x0000_550F Pin groups can be composed from any arbitrary group of existing pins using the method: add_pin_group add_pin_group # The first argument is the ID for the new pin group, followed by the IDs of the pins it should contain , :jtag , :tdi , :tdo pins( , :tclk ).size :tms :jtag # => 4 Pin groups can be aliased in the same way as pins, for readability the method add_pin_group_alias can be used, although internally it is the same as add_pin_alias : :porta , add_pin_group_alias pin_group( :data :data ).dont_care # Can now be used as if it were a regular first class pin group It is possible to alias a single pin within a pin group, in that case a pin number argument\nmust be supplied to : add_pin_alias , add_pin_alias :moda , :porta pin : 4 It is also possible to create a pin group from a subset of pins of a regular pin group, simply\npass in a range or an array of pin indexes to add_pin_group_alias : add_pin_group_alias :data_byte_0 , , :porta : [ pins 7 .. ]\nadd_pin_group_alias , pins 0 :data_byte_1 :porta , : [ , 8 , 9 , 10 11 , 12 , 13 , 14 , 15 ]\n\nport( :data_byte_0 ).dont_care # Can now be used as if it were a regular first class pin group Power and Ground Pin Modelling The API supports modelling power and ground pins as follows: add_pin add_power_pin add_power_pin :vdd2 :gnd3 add_ground_pin :pinx :vdd1 :gnd1 add_ground_pin :gnd2 add_ground_pin add_power_pin_group :vdd , :vdd1 , :vdd2 add_ground_pin_group , :gnd :gnd1 , , :gnd2 :gnd3 This will cause these pins to be stored in separate collections to make pattern and other content generation easier: pins.size # Based on the above example power_pins.size # => 1 # => 2 ground_pins.size # => 3 Power and ground pin lookup should be done via dedicated methods: power_pin( )\nground_pins( :vdd1 )\n\nground_pin_groups.each :gnd do |id, group| # Do this for each ground pin group end Changing Data State See the Pin API for full details of what methods are available. Here are a few examples of working with pins: pin( # Make the tester drive a value on a pin ).drive_hi :tdi pin( # Equivalent to above, this form is better when serially applying data in a loop... :tdi ).drive( ) 1 reg( # ...like this... :data ).shift_out_left |bit|\n pin( do ).drive(bit.data) :porta end pin( # Asserting that a pin drives a certain value has various aliases, these are all equivalent :tdo ).assert( 1 )\npin( :tdo ).compare( )\npin( 1 ).expect( :tdo ) 1 # Current state can be queried pin( ).driving? :tdo pin( # false ).comparing? :tdo pin( # true ).dont_care\npin( :tdo ).comparing? :tdo # false pin( :tms ).drive_lo\npin( :tms ).toggle # Pin groups support the same methods as pins port( :porta ).drive( 0x55 ) port( # 01010101 :porta ).assert( 0x55 ) port( # LHLHLHLH :porta ).dont_care # XXXXXXXX port( # Individual pins within a pin group can be accessed by index )[ :porta 1 ].drive( ) 0 # XXXXXX0X Bang (!) Methods Almost all pin methods have a bang form, for example: pin( ).drive!( :tdi ) 1 The bang methods will set the state on the pin in the same way as the regular method but\nwill then automatically fire off a tester cycle to generate a vector. In other words the above is the shorthand equivalent of: pin( ).drive( ) :tdi 1 $tester .cycle Pin Availability by Package Pins can be defined based on a specific package context which can be used to gate their availability. Here is an example: # Initially define the available packages at the top level before adding any pins class MySoC Origen include :: TopLevel def add_package initialize :pkg1 add_package :pkg2 end end Pins can then be defined by package: add_pin , :pin1 : packages :all add_pin :pin2 # No constraint is equivalent to :all add_pin , :pin3 package : :pkg2 add_pin , packages :pin4 : [ :pkg1 , :pkg2 ] with_package # Pins can also be added within a package scope, these will add to :pkg1 only :pkg1 do add_pin add_pin :pin5 :pin6 end # All pins are available when the package is set to nil, no package represents the die package # => nil pins.size # => 6 package = pins.size :pkg1 # => 5 (no pin3) has_pin?( ) :pin3 package = # => false :pkg2 pins.size has_pin?( # => 4 (no pin5 or pin6) :pin3 ) # => true Pin groups can contain different sets of pins in different packages: add_pin( )\nadd_pin( :pin1 :pin2 )\nadd_pin( :pin3 )\n\nadd_pin_group :g1 , :pin1 , , :pin2 : package :pkg1 add_pin_group :g1 , :pin1 :pin3 , :pin2 , , : package has_pins?( :pkg2 :g1 ) pin_groups.size # => false # => 0 package = :pkg1 has_pins?( :g1 ) # => true pins( :g1 ).size pin_groups.size # => 2 package = # => 1 :pkg2 has_pins?( :g1 ) pins( # => true ).size :g1 pin_groups.size # => 3 # => 1 Package Attributes The attributes listed in the constant PACKAGE_SCOPED_ATTRIBUTES in the can be set to specific values per package. Pin API Here is an example of how to set the pin location by package: add_pin # At definition time , :pin1 : { packages pkg1 : { location : A2 }, \" \" : { pkg2 : \" }}\nadd_pin A3 location \" :pin2 pins( # Or later :pin2 ).add_location , \" A5 \" : package pins( :pkg1 ).add_location :pin2 , \" B2 \" : package package = :pkg2 :pkg1 pins( :pin1 ).location # => \"A2\" pins( ).location :pin2 # => \"A5\" package = pins( :pkg2 ).location :pin1 pins( # => \"A3\" ).location :pin2 # => \"B2\" A context can also be supplied when reading such attributes to override the current context: package = pins( :pkg1 :pin1 ).location # => \"A2\" pins( ).location( :pin1 : package :pkg2 ) # => \"A3\" Origen will automatically create an alias for the given location (a lower cased symbol) that is scoped to the package. package = has_pin?( :pkg1 ) :a2 # => true has_pin?( :a3 ) # => false package = has_pin?( :pkg2 ) :a2 # => false has_pin?( ) :a3 # => true Pin Functions Pin aliases are an example of modelling different pin functions that can be mux’d onto the same pin, in this case\nthe pin attributes are the same regardless of the function name being used. However sometimes it is necessary to model different attributes depending on the pin function - for example under\none function the pin may be an input, but when used as another function it is an output. The attributes listed in the constant FUNCTION_SCOPED_ATTRIBUTES in the Pin API can be set to specific values per context (mode and/or configuration). Here is an example of adding a function: class :: include MySoC Origen TopLevel def add_pin initialize :pin1 add_pin :pin2 # Define some pin functions pin( :pin1 ).add_function :nvm_fail , : direction :output pin( :pin2 ).add_function , :nvm_done : direction pin( :output ).add_function :pin1 , :tdi direction : pin( :input :pin2 ).add_function , :tdo direction : :output # Add some groupings that are associated with specific pin functions add_pin_group :jtag , , :tdi :tdo add_pin_group :nvm , :nvm_fail , :nvm_done end end $dut = .new MySoC # The name used to look up a pin now returns the pin with a thin wrapper around it # which defines its current function: $dut .pin( ).direction :nvm_fail # => :output $dut .pin( :nvm_done ).direction # => :output $dut .pin( ).direction :tdi # => :input .pin( $dut ).direction :tdo # => :output # If a function name is given when defining a pin group, the pin will always have # that function when it is accessed through the resultant group .pins( $dut :jtag )[ ].direction 0 # => :output $dut .pins( :jtag )[ ].direction 1 # => :input .pins( $dut :nvm )[ 0 ].direction # => :output $dut .pins( :nvm )[ 1 ].direction # => :output Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/registers/": {
    "title": "Registers",
    "subtitle": "Models",
    "body": "Models Registers When modelling semiconductor IP, there will almost always be a need to define register\nand bit maps and Origen provides an API specifically for this purpose. When modelling silicon with Origen, the hardware should be the guide as to\nwhere logic or attributes should go and if you have followed the advice so far\nthen you will already have a model framework that closely resembles the physical hardware.\nThe registers then, are simply instantiated within the model of the corresponding hardware\nthat owns them. Defining Registers Registers should be defined as part of the object initialization process, but to avoid the\ninitialize method growing out of hand it is recommended that you instantiate registers in a\ndedicated method that is called upon initialization. When defining registers you can either take the approach of defining them all up front\nor defining them individually on an as-needed basis - the latter is recommended as it is the most\nefficient in terms of effort. Here is an example of how to define this register in our memory map: # file: lib/nvm/analog_t921.rb module NVM class ANALOG_T921 include Origen Model def :: (options={})\n instantiate_registers(options) initialize end def (options={})\n reg instantiate_registers :ctrl , 0x0024 , size : 16 |reg|\n reg.bit do , 7 , :coco : access :ro reg.bit 6 , reg.bit :aien , 5 reg.bit :diff 4 .. , 0 , :adch reset : 0x1F end end end end Some points to note in the above code: Even though we have not used it we have continued the practice of setting up every method with\nan optional option argument and we have passed this between method calls - i.e. we passed the\ninitialize options when calling instantiate_registers. This keeps things extremely flexible for\nthe future and means that it is easy to influence the register instantiation externally, for\nexample: NVM::ANALOG_T921.new(include_test_registers: true) The reg method takes a name, address and size as arguments. The size is optional\nand is 32 by default. Bit definitions are contained within the block passed to the do..end reg method. By default bits are writable and will reset to 0, but this can be overridden as shown\nin the example. When defining bits the size is 1 by default and the reset state is 0 by default, these can be\noverridden on an as needed basis as shown above. Accessing Registers Origen will automatically create accessor methods for the register and its bits, the above register\nwould be accessed like this: .nvm.analog.ctrl $dut # => <register object> $dut .nvm.analog.ctrl.adch # => <subset of bits> The Origen console will show a nice graphical representation of the register which reflects its\ncurrent state, this can be very useful when debugging or more generally as an interactive\nversion of the block guide: > origen i\n\n>> $dut.nvm.analog.ctrl\n=>\n0x24 - :ctrl\n ================================================================================================================\n | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 |\n | | | | | | | | |\n | | | | | | | | |\n ----------------------------------------------------------------------------------------------------------------\n | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\n | :coco | :aien | :diff | :adch[4:0] |\n | 0(RO) | 0 | 0 | 0x1F |\n ---------------------------------------------------------------------------------------------------------------- Origen supports some more verbose APIs that you may see used in some codebases or documentation,\nthese are now considered legacy APIs but are equivalent to the above: $dut .nvm.analog.reg( :ctrl $dut ) .nvm.analog.reg( :ctrl ).bits( ) :adch $dut .nvm.analog.reg( :ctrl )[ :adch ] Origen supports Verilog style part selects to access an ad-hov subset of bits, although unfortunately is not valid Ruby and [3:0] is used instead. [3..0] .nvm.analog.ctrl[ $dut ] 1 # => bit 1 of the register $dut .nvm.analog.ctrl.adch[ ] 1 # => bit 1 of the adch bits .nvm.analog.ctrl[ $dut .. 3 0 ] $dut .nvm.analog.ctrl.adch[ ] .. 1 0 Base Addresses When defining registers the address specified should be the local address within the owning\nIP block. Base addresses can be passed in within the sub block definition, base_address is an official\noption that Origen will recognize and automatically deal with. sub_block # lib/nvm/nvm_m682.rb :analog , : class_name \" ANALOG_T921 \" , : base_address 0x4000_0000 Registers will automatically pick up the base address of their parent, the local address can\nbe accessed via the offset method: $dut .nvm.analog.ctrl.address # => 0x4000_0024 .nvm.analog.ctrl.offset $dut # => 0x24 Note that when resolving a base address Origen will look right up the hierarchy until it reaches the top\nlevel object and all base addresses in that branch of the tree will be added together. Register Domains An API is available to model register domains, where domain could mean what bus or clk domain that the\nregister is on, or any similar concept. Domains must first be declared in the object that owns them and then they can be passed to sub block\ndefinitions: : domain :ips : domain , :ahb : endian sub_block :little :analog , : class_name \" ANALOG_T921 , \" : base_address , 0x4000_0000 : domain :ips The domain attribute will also accept an array of multiple domain names as required. The child block and any of its registers will then be associated with the given domains: .nvm.analog.domains $dut # => {ips: <object>} $dut .nvm.analog.ctrl.domains # => {ips: <object>} Note that the method returns a hash pointing to objects that represent the domains,\nthis can therefore be associated with attributes such as the domains :endian attribute in the\nexample above. See the for an up to date list of\nsupported attributes. Domain Class API Per-Domain Base Addresses Domain specific base addresses can be assigned to a sub-block by passing a hash to the :base_address option as shown in the example below: class include Top :: Origen def domain domain :ips sub_block :ahb , , TopLevel initialize :subx1 : class_name , \" SubX \" : base_address sub_block 0x1000_0000 , :subx2 class_name : \" SubX \" : { base_address : ips , 0x2000_0000 ahb : 0x3000_0000 } end end class include SubX :: Origen Model def initialize reg :reg1 , 0x200 do bits .. 31 , 0 :data sub_block end , :suby1 class_name : \" , SubY \" domain : sub_block :ips , :suby2 : class_name \" , \" SubY domain : :ahb end end class SubY include Origen :: Model def reg initialize , :reg1 0x300 do bits .. 31 , 0 :data end end end $dut = .new Top .subx1.reg1.address $dut # => 0x1000_0200 .subx1.suby1.reg1.address $dut # => 0x1000_0300 $dut .subx1.suby2.reg1.address # => 0x1000_0300 # Where a register falls into the case where multiple domains are specified for it, you must # indicate the one you want .subx1.reg1.address( $dut : domain :ips ) # => 0x2000_0200 .subx1.reg1.address( $dut domain : ) :ahb # => 0x3000_0200 .subx2.suby1.reg1.address $dut # => 0x2000_0300 .subx2.suby2.reg1.address $dut # => 0x3000_0300 In the case where a register owned by a child sub-block is not in any of the domains listed in the base address\nhash then it will pick up a base address of 0. An alternative default can be set by adding a key to the hash: :default sub_block :subx2 , class_name : \" SubX , : \" base_address : { default , 0x1000_0000 ips : , 0x2000_0000 ahb : 0x3000_0000 } Documenting Registers Registers can be documented by Ruby comments like this: # The MCLKDIV register is used to divide down the frequency of the HBOSCCLK input. If the MCLKDIV # ** MGATE Clock Divider Register ** # register is set to value \"N\", then the output (beat) frequency of the clock divider is OSCCLK / (N+1). The # resulting beats are, in turn, counted by the PTIMER module to control the duration of Flash high-voltage # operations. reg , :mclkdiv 0x0003 , : size 16 |reg| do # **Oscillator (Hi)** - Firmware FMU clk source selection. (Note that in addition to this firmware-controlled bit, the # FMU clock source is also dependent on test and power control discretes). # # 0 | FMU clock is the externally supplied bus clock ipg_clk reg.bit # 1 | FMU clock is the internal oscillator from the TFS hardblock , 15 , :osch : reset 1 end The descriptions are then programmatically accessible via the following methods: mclkdiv.full_name mclkdiv.description( # => \"MGATE Clock Divider Register\" include_name : false ) bit = mclkdiv.osch\nbit.full_name # => [\"The MCLKDIV register is...\", \"register is set...\", ...] # => \"Oscillator (Hi)\" bit.description( include_name : , false : include_bit_values false ) # => [\"Firmware FMU clk...\", \"FMU clock...\", ...] bit.bit_value_descriptions[ ] 0 # => \"FMU clock is the externally supplied bus block ipg_clk\" bit.bit_value_descriptions[ 1 ] # => \"FMU clock is the internal oscillator from the TFS hardblock\" Most commonly these descriptions will be used for documentation, for example the Documentation Helpers plugin provides\nhelpers to easily present registers in Origen documentation as shown here - . Register Helpers The descriptions can also be supplied as in-line arguments, but doing so overrides any comment-based\ndocumentation. Thus, it is intended to be used\nonly when the register is being declared programmatically by an importer and humans\nshould stick to the above API for clarity: reg , :mclkdiv , 0x0003 : size 16 , description : \" ** MGATE Clock Divider Register ** The MCLKDIV reg... \" |reg|\n reg.bit do , 15 , : :osch : , description reset 1 \" ** Oscillator (Hi) ** - Firmware FMU clk source selection... \" end Defining Application-Specific Metadata Within a given application it may be desired to attach some meta-data to a register or bits to\ntrack application-specific properties, for example whether a register is only readable in test\nmode or not. The object owning the register can define a default set of custom attributes and then override\nthese for specific registers and bits.\nHere is an example: def (options={})\n\n default_reg_metadata instantiate_registers do |reg|\n reg.user_reg = false default_bit_metadata end |bit|\n bit.time_to_respond = do 0 end reg :fstat , , 0x0001 : size , 8 : user_reg true do |reg|\n reg.bit 8 , :ccif , : time_to_respond .us\n reg.bit 10 , 7 :rdcolerr reg.bit 6 , reg.bit , :accerr access : :w1c , 5 , :fpviol access : reg.bit :w1c 0 , , :mgstat : access :ro reg end :mclkdiv , , 0x0002 : size 16 |reg|\n reg.bit do , 15 , :osch reset : reg.bit 1 .. 13 12 , , :mode_rdy : writable reg.bit false 10 , :eccen , : reset reg.bit 1 .. 9 , 8 reg.bit :cmdloc .. 7 0 , :div end end fstat.user_reg? mclkdiv.user_reg? # => true # => false fstat.ccif.time_to_respond # => 10us fstat.accerr.time_to_respond # => 0 Global attributes can also be added, when done in this way the meta data\nwill be applied to all registers within the scope of an application. If the same attribute is later declared within a class as above then the value\nfrom the class will take precedence. As with the above example the attribute values can be overridden when\ndefining registers and bits. :: Origen .default_reg_metadata Registers |reg|\n reg.attr_x reg.attr_y = 10 do # Adds the attribute with a default value of nil # Adds the attribute with a default value of 10 end :: Origen Registers .default_bit_metadata do |reg|\n reg.attr_z = 15 end Plugins may also use this approach to globally extend the attributes of\nregisters and bits. Importing Registers If the register data for the target device/module is already mastered somewhere else, for\nexample in IP-XACT format, then it can be imported directly to save having to manually duplicate the\nregister definitions in Origen.\nThis will generate the exact same models of the registers as if they had been declared directly\ninto Origen. This import (and export) functionality is provided via the plugin and this should be consulted directly for the latest information on the API and the supported formats. Cross Origen However here is a brief example of how it can be used to import from a local XML file: # lib/nvm/nvm_m682.rb module NVM class NVM_M682 include Origen :: include Model CrossOrigen def initialize (options={})\n cr_import( path : \" #{ Origen .root ) } /ipxact_files/nvm_m682.xml \" end end end Understanding the Origen Register Model By using the above API Origen has now built an accurate register model that will look and behave like the\nreal register on silicon.\nThis is extremely convenient and useful for pattern generation as we will see later, but it can also\nbe very useful for other applications such as generating documentation . Each register created by Origen is an instance of the class.\nThis does not by itself provide that much functionality and its main purpose is as a container for the\nindividual bits that make up the register. Origen::Registers::Reg Each bit is an instance of the class. The main function of the bit object is to store a single bit of data and to track the state of various\nattribute flags that monitor such things as whether the bit is writable, or readable, or whether a particular bit\nis required to be read during a test pattern operation. Origen::Registers::Bit Similar to the Reg the Bit API is mainly for internal use. Instead the public facing API is implemented by the Origen::Registers::BitCollection class.\nThis class provides a consistent API whether you are working with an entire register or a subset of bits in\nthe register. By calling a new ctrl BitCollection is generated on the fly and populated\nwith all of the bit objects contained in the register.\nSimilarly if you call then a ctrl.adch will be\nreturned that contains only the subset of requested bits. BitCollection Examples Here are a few examples of working with the register that we recently added: = $dut EAGLE_M352 :: : SOC .new( version )\n\nreg = 1 $dut .nvm.analog.ctrl\n\nreg.data reg.data.to_hex # => 31 # => \"0x1F\" reg.write( # Only bits that are writable can hold data, the same as real silicon 0xFFFF )\nreg.data.to_hex # => \"0x7F\" reg.adch.data # Individual bits can be manipulated reg.adch.write( # => 31 ) \nreg.adch.data 0 # => 0 reg.data.to_hex # => \"0x60\" reg.is_to_be_read? # Bits can be marked for read reg.coco.read\nreg.coco.is_to_be_read? # => false # => true reg.aien.is_to_be_read? # => false reg.is_to_be_read? # => true # The register can be reset reg.reset\nreg.is_to_be_read? reg.data.to_hex # => false # => \"0x1F\" Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/specs/": {
    "title": "Specifications",
    "subtitle": "Models",
    "body": "Models Specifications A specifications or spec is defined as: An act of describing or identifying something precisely or of stating a precise requirement In Origen, the definition is refined to mean a parametric measure that has the following basic\nattributes: Name Symbol Type Mode Audience Description Limits (min, max, typ) This is not the complete list of attributes but a well defined spec should define these\nattributes. Specification API The spec API is in the preliminary stages so please send feedback for enhancements Most engineers are probably familiar with a data sheet specification that looks something\nlike this: Parameter Symbol Min Typ Max Unit Notes ADDR/CMD Setup tddkhas 495     ps wrt MCK There are three attributes required to define a Spec: name, mode, and type. A fourth\nattribute (sub_type) can further delineate a Spec but it is not required. The basic\nspec API can take two syntactical forms. The first is a more traditional Ruby syntax\nand the second makes the API feel more like a custom DSL. spec , :soc_vdd do |spec|\n spec.symbol = spec.description = Vdd spec.min = Soc Core Power Supply \" :dc \" \" \" spec.max = \" 1.00.V - 50.mV \" spec.unit = 1.05 spec.audience = \" V \" :external end spec , :dc symbol do description \" \" :soc_vdd \" Vdd Soc Core Power Supply \" min \" 1.00.V - 50.mV \" max unit 1.05 \" V \" audience :external end While the user can be free to add various attributes over time, they must assign a valid\nname and have valid limits to complete instantiation. A valid name must not start with\nletters and cannot contain special characters forbidden by Ruby. Dashes and underscores\nare allowed but the preferred method is to make spec name Symbols in the .\nLimits can be of type Numeric or String so the API is flexible enough to handle\nspecs with a formula as the limit. Valid limits are defined as: snake-case format If Min && Max: Min < Max if limit is Numeric. If Target, Min < Target < Max A target can be thought of as an unofficial typical value. Targets are typically used when\nspecs are exported for use in data analysis and also help understand if a min anx max limit\nare not symetrical. During spec limit assignment the user just can either input a numeric value, a symbol or\na string. [ ] pry()> 1 .specs( @ip ).min\n=> :ip_setup_time [ #<struct Origen::Specs::Spec::Limit exp=\"250.ps + 25.ps\", maturity=nil, value=2.7e-10> ] pry()> 2 .specs( @ip ).min.exp\n=> :ip_setup_time [ \" 250.ps + 25.ps \" ] pry()> 3 @ip .specs( ).min.value\n=> :ip_setup_time 2.7e-10 The Spec model will save the original user input as an expression and will\nattempt to evaluate the string to a numeric value or lookup the symbol within the\nParameters and Specs database. Currently only the numeric and string expressions are working. Notice how the mode attribute is never specified. This is because the Spec API will\nalways use the mode of the current object as a default. If no mode is specified (nil)\nthe user intends for the Spec to be available to all modes of the defining object. The\nuser, of course, can specify a mode as shown below. The Spec API will only return\nspecs that match that specified mode instead of returning globally defined specs. spec , :soc_vdd , :dc symbol do Vdd description \" Soc Core Power Supply :mymode \" \" \" min \" max 1.00.V - 50.mV \" unit 1.05 \" audience V \" :external end Another thing to note about modes is that specs defined with no mode will be\ncatalogued as :global if the owning object is Origen.top_level and :local for\nany other owning IP. This allows certain specs to be used across the Origen\necosystem and other local specs to be contained inside the owning IP. The user can search for specs using filters for any of the following: Name Mode Type Sub-Type If any of the options are nil it will not filter by that option when interrogating the\nspec database. The API is: , options) specs( :myspecname In the example above a symbol is passed for the spec name but all four filter options\ncan be a String, Number or a Regexp. If an object defined three specs named :soc_vdd,\n:io_vdd, :pll_vdd the following call would occur. specs( / vdd / , : true verbose ) ================================================================================================\n| IP: soc |\n================================================================================================\n| Name | Symbol | Mode | Type | Parameter | Min | Max | Unit | Audience |\n------------------------------------------------------------------------------------------------\n| soc_vdd | Vdd | :global | dc | Soc Core Power Supply | 0.95 | 1.05 | V | external |\n| io_vdd | OVdd | :global | dc | Soc IO Power Supply | 1.45 | 1.55 | V | external |\n| pll_vdd | AVdd | :global | dc | Soc PLL Power Supply | 1.15 | 1.25 | V | external |\n------------------------------------------------------------------------------------------------ If the ‘verbose’ argument is not included, only an array of spec objects is returned. If only a\nsingle spec is found a Spec object is returned instead of an array of a single spec. The console\nprinting method only displays attributes which have content for at least one of the specs\nfound. It also auto-adjusts the attribute column padding so no space is wasted. Specs and Modes in Detail Specs can be defined globally or within nested sub_blocks or controllers . A spec\nis defined in the context of a mode, even if it only has a single mode. A mode is defined as\na known device state with a unique name or id. An simple example could be a basic PORESET\nthat defines the clocking and register space state after turning a chip on. The spec\nAPI does not require a mode to be defined but it will assign some reserved modes if none is\nprovided. If the owner of the block is equal to Origen.top_level a mode named :global is assigned,\notherwise a mode named :local is assigned. Specs with a local mode are not accessible\noutside the model in which they are defined. A spec with a global mode is accessible\neverywhere but will be overwritten is defined both globally and locally. Here is an\nexample where a spec is defined within three modes. class SoC_With_Specs include :: Origen TopLevel def initialize sub_block :ip_with_specs , class_name : \" IP_With_Specs \" , : base_address 0x1000_0000 add_mode :default add_mode add_mode :low_power :high_performance modes.each |mode| do mode case when vdd_nom = :default .V 1.0 when vdd_nom = :low_power 0.95 .V when vdd_nom = :high_performance .V 1.05 end spec , :soc_vdd , mode :dc symbol do description \" Vdd \" \" min \" Soc Core Power Supply #{ max \" vdd_nom } - 50.mV \" \" vdd_nom #{ } + 50.mV \" audience :external end end end end Notice below how both the limit expression and value get changed based on the mode\nselection of the owning IP. [8] pry()> @dut.mode\n=> high_performance\n[9] pry()> @dut.specs(:soc_vdd).min.exp\n=> \"1.05 - 50.mV\"\n[10] pry()> @dut.specs(:soc_vdd).min.value\n=> 1.0\n[11] pry()> @dut.mode = :low_power\n=> :low_power\n[12] pry()> @dut.specs(:soc_vdd).min.value\n=> 0.9\n[13] pry()> @dut.specs(:soc_vdd).min.exp\n=> \"0.95 - 50.mV\" Specs have an audience attribute that can be set to :internal or :external. They\nalso have a read-only attribute called ‘limit_type’ which is either :single_sided\nor :double_sided. Here are some attribute access examples: [7] pry()> @ip.specs(:ip_setup_time).mode\n=> :new_mode_with_altered_specs\n[8] pry()> @ip.specs(:ip_setup_time).limit_type\n=> :double_sided\n[10] pry()> @ip.specs(:ip_setup_time).notes = \"my note\"\n=> \"my note\"\n[11] pry()> @ip.specs(:ip_setup_time).notes\n=> \"my note\"\n[12] pry()> @ip.specs(:ip_setup_time).symbol # Defaults to name if no value supplied\n=> :ip_setup_time\n[13] pry()> @ip.specs(:ip_setup_time).testable\n=> true\n[14] pry()> @ip.specs(:ip_setup_time).audience\n=> :internal\n[15] pry()> @ip.specs(:ip_setup_time).description\n=> \"IP Setup Time with Double-Sided Limits\" The Origen::Specs::Spec class is available to all models and as such has a method ot find all specs\nthat exist in the model itself or any child models. This method is useful when trying to\nexport the spec information of a model to other API. [ ] pry( 2 => #<RSpec::ExampleGroups::OrigenSpecsModule>)> @dut.find_specs.size 8 Remaining Issues and Documentation Add in support for spec ‘notes’ being more than just a text string.\nWill require adding in a Note class to Origen. Add in support for Specs and Parameters lookup for formula evaluation. Enable more attributes required for traceability and test plan creation Formalize a spec guardband definition and methodology Enable Spec name lookup for symbols used in limit formulas Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/versioning/": {
    "title": "Versioning",
    "subtitle": "Models",
    "body": "Models Versioning Adding a version attribute is since this will be how bugs and\nfeatures will be tracked in the future. strongly encouraged Since this is such a common attribute all Origen models already have a version attribute and if\nthis key is passed to a sub_block definition it will automatically be attached to the sub-block,\neven in the case where a custom class is used. When instantiating an SoC model we can supply a version and this should then cascade down\nthe hierarchy affecting what versions of the sub-modules get instantiated. Let’s say that two different versions of our Eagle device exist, and in turn each one instantiated\na different version of the NVM IP.\nWe can model that like this: # lib/soc/eagle_m352.rb SOC class include EAGLE_M352 Origen :: module TopLevel def (options={}) initialize version case when 0 sub_block , :nvm : class_name \" NVM_M682 , \" version : 3 when sub_block 1 :nvm , : class_name \" , NVM_M682 \" version : 5 else fail \" The BOM for version version #{ } has not been defined! \" end end end end Note that we define an error condition if our application attempts to instantiate a version that we\nhave not defined. We then cascade this information down the tree, so our NVM module should also instantiate it’s\ncomponents based on the required version: # lib/nvm/nvm_m682.rb class include : module NVM NVM_M682 :: Origen Model def (options={}) initialize version case when 3 sub_block , :analog : class_name , \" ANALOG_T921 \" version sub_blocks 11 :memory , : class_name \" MEMORY_128_B954 \" , : instances , 4 version : 12 sub_block :state_machine , class_name : \" CONTROL_D345 , \" version : 20 when sub_block 5 :analog , : class_name \" , ANALOG_T921 \" version : 12 sub_blocks , :memory : class_name \" MEMORY_128_B954 , \" instances : , 4 version : sub_block 12 :state_machine , : class_name \" , CONTROL_D345 \" : version 24 fail else \" The BOM for version version #{ } has not been defined! \" end end end end We can test this out in the console: = $dut :: EAGLE_M352 : SOC .new( version ) 0 .nvm.state_machine.version $dut # => 20 $dut = :: SOC .new( EAGLE_M352 version : 1 ) .nvm.state_machine.version $dut # => 24 Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/environment/": {
    "title": "Environment",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Environment All environments are defined by files that reside in the directory.\nEnvironments are regular Ruby files and they should be simply named: environment <identifier>.rb In a test engineering application where the environment is used to select the target test platform,\nthey are normally named after the tester, e.g. environment\n|-- j750.rb\n|-- uflex.rb\n|-- v93k.rb\n`-- jlink.rb Creating an Environment To create a new environment, simply create the file containing whatever Ruby code you need.\nThey are usually very concise and in a test engineering application would normally only instantiate the\ntarget tester driver, here are some examples: :: .new # environment/j750.rb = $tester OrigenTesters J750 # environment/v93k.rb = $tester OrigenTesters :: .new V93K # environment/jlink.rb $tester = OrigenDebuggers :: .new JLink If the given driver supports configuration options, then you may have some variations\nfor a given platform - e.g. to configure the driver slightly differently\nfor generating probe test patterns: j750_probe.rb # environment/j750_probe.rb = $tester :: OrigenTesters .new J750 .available_power_supplies = $tester 64 Setting a Default Environment A default environment can be defined that will be used withing a new workspace unless the user\nspecifies otherwise. This is not required and should only be added if it makes sense within the\ncontext of the application - i.e. you may choose not to have a default to avoid the situation where the user\nbuilds something without really understanding what configuration they are targeting. A default is specified by creating an environment file called environment/default.rb ,\ntypically this is a symbolic link to another environment file: ln -s environment/j750.rb environment/default.rb Getting and Setting the Environment The current environment for a given application workspace can be queried by running the origen environment command, or for short, this will show\nyou the content of the current environment file: origen e > origen e\n\nCurrent environment: j750.rb\n**********************************************************************\n $tester = OrigenTesters::J750.new\n********************************************************************** The environment can be changed by running the same command and supplying the desired environment: > origen e environment/j750.rb\n\n> origen e v93k As shown above, a full path or any snippet which is enough to uniquely identify one of the available\nenvironment files is sufficient. Additionally all Origen commands allow an override to be supplied at runtime: > origen g my_pattern -e jlink Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/global/": {
    "title": "Global Setup",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Global Setup Origen re-loads the runtime environment immediately before every pattern, test program or compile\njob.\nTherefore both the target and environment files can be used to set some global state that\nwill later be applied to all patterns or similar. Note that you cannot actually generate any output from the target or environment, that will only\nhappen from within the pattern, program or template source files. However what you\ncan do is setup some initial state within your models to influence what will\nbe generated by the source files later. In other words any changes that you make to the models after instantiating them\nwill persist into the remainder of the generation flow.\nIt is not recommended to put a lot of logic into target files, but when used\nresponsibly this can be a useful addition to your tool box. Origen Configuration The target and environment files can also be used \nto override any Origen configuration settings that would otherwise be specified in\nthe config/application.rb file. An example might be to set up product-specific LSF strings for utilization tracking: # target/eagle_1.rb = :: $dut MyApp .new( Eagle : version ) 1 Origen .config.lsf.project = \" eagle.te \" # target/falcon_1.rb = $dut MyApp :: .new( Falcon version : ) 1 Origen .config.lsf.project = \" falcon.te \" Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/introduction/": {
    "title": "Introduction",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Introduction Typically an Origen application will contain source code to generate IP that can be\napplied to many different products, and/or which can run on many different test platforms.\nIt is the job of the and the target environment to setup the runtime conditions that will\ndefine what combination of product and tester platform will be targeted by the\ngenerated output. The target is normally used to define the product side of the runtime environment, with one\ntarget file existing for every product/device that the application supports.\nTarget files are usually very short and normally just instantiate the model of the target\ndevice, assigning it to the global variable $dut . For test engineering applications, the test platform selection is usually handled by environment\nfiles. These are very similar to target files and there is usually one per supported test\nplatform. Each environment will typically instantiate the target tester model/driver, assigning it\nto the global variable $tester .\nFor non-test engineering applications, the environment layer can either be omitted or\nelse it can be used to define whatever other global state makes sense to be applied across\nmultiple device targets. Additionally, Origen has the concept of an operating mode and this can be considered a\nthird component of the runtime environment. How the Runtime Environment is Applied Before compiling any template, or generating any pattern, test program or other source file,\nOrigen will do the following: Apply the active mode Execute the active environment file Execute the active target file This means that the active environment can override the active mode, and that the active target can\noverride both the mode and the environment. This sequence will be repeated between jobs if multiple\nfiles are being compiled/generated by a given Origen thread of execution (each source files is an individual job).\nThis prevents model state from a previous job from carrying over to the next one and ensures that the\noutput is never affected by generation order. This sequence of reloading the mode, environment and target is generally referred to as \n \"reloading the target\".\n No API exists within Origen to reload only one of these component, so anytime you see a reference\n to the target being re-loaded it means that all three of the runtime environment components will be\n refreshed. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/loadorder/": {
    "title": "Load Order",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Load Order The number of global objects instantiated by a runtime environment should be kept to a minimum,\nhowever even the most basic of setups is likely to instantiate both a and a $dut $tester object. It is important that the initialization of each of these objects does not depend on the other\nto avoid introducing a dependency on the order in which they must be instantiated.\nSuch a dependency is fine when the application is young and the number of configurations is small, but as\nit grows this can become painful to manage and hard to anticipate when new engineers\ncome onto the team. Nonetheless it is very likely that sooner or later the case will arise where an object\nmust be initially configured differently depending on what tester platform it is\nrunning on, or on what top-level device object it has been integrated into. So how to do that initial configuration without introducing an instantiation\norder dependency? The answer is to use an method to complete any initialization\noperations that depend on other objects. on_create Using on_create on_create is an Origen callback\nand the should be consulted \nfor background information and for details on how to setup your model to use callbacks. callback guide Whenever Origen loads a runtime environment it will automatically call the methods of any objects that have just come into being at the end of loading the target/environment files. on_create It is therefore guaranteed that on_create will be run before any\noperations are invoked on the model outside of the target/environment files and it should be though of\nas similar to the standard Ruby initialize method but with the guarantee\nthat all runtime objects already exist by the time it is called. Here are some examples of cases where on_create should be used in\npreference to : initialize # In the $dut model def initialize # This would be creating an instantiation order dependency by doing this here, # i.e. $tester must exist before the $dut # $tester.do_something end def on_create # But not here .do_something $tester end # In a model that is not $dut def initialize # This would be creating an instantiation order dependency by doing this here, # i.e. $dut must exist before this model # if $dut.test_pin_muxed_with_reset? # add_pin_alias :test, :reset # else # add_pin :test # end end def on_create # But not here if .test_pin_muxed_with_reset?\n add_pin_alias $dut :test , :reset else add_pin :test end end Any Downside to Using on_create Instead of initialize? Not really. Using initialize for object construction/initialization is perhaps preferable in some\nsense since it is a standard Ruby method and therefore clearer for someone new to Origen\nto understand how the model is initially being configured. However generally anything that can be done in can be safely\nmoved to initialize and the eventual state of the model instantiated by the\nruntime environment files will be identical. on_create One major difference is that parameter options cannot be passed into from the target, whereas options can be passed into the on_create initialize method.\nSuch parameter dependent cases can still be moved to on_create but the\noptions will need to be saved by the method. initialize def initialize = options (options={}) @intial_options end def on_create if @intial_options [ :uti ] .do_something $tester end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/mode/": {
    "title": "Mode",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Mode Origen supports the following operating modes: Production - To be used whenever generating output destined for production use. - To be used whenever developing an application. Debug Simulation - To be used whenever generating output destined for a simulation. The default operation mode is production , and in this mode Origen will enforce the following\nrestrictions: Origen will not run if there are modified files within the environment workspace (i.e. edits that are not checked in) Origen will not run if plugins are imported from a local path reference Both debug and modes remove these restrictions and are essentially the same\nas far as Origen is concerned. However plugin and application developers may implement\ndifferent behavior if the output is targeting simulation rather than real silicon. simulation Note that the command for creating a new application will make it\n look as though origen new debug is the default mode, but this is just to make life convenient for the new\n application developer who is obviously about to go on and develop the new app. If the new\n app was cloned to a new workspace by another user, \n then it would come up in mode. production Getting and Setting the Mode The current default mode for a given application workspace can be queried by running the command, or origen mode for short: origen m > origen m\n\ndebug The mode can be changed by running the same command and supplying the desired mode: > origen m production\n\n> origen m debug\n\n> origen m simulation Any shortcut which provides enough detail to uniquely identify one of the available modes can be used: > origen m sim Additionally all Origen commands allow an override to be supplied at runtime. Aside from overriding\nthe current default mode, this will also override any mode setting applied by the current environment\nor target: > origen g my_pattern -m simulation Programmatically Getting and Setting the Mode returns an Origen.mode object representing the current mode ,\nthis provides the following API for sniffing the mode at runtime: .mode.production? Origen # => false Origen .mode.debug? # => true Origen .mode.simulation? # => false Note that is also considered a simulation mode, the API will respond as follows\nif debug mode is set: simulation .mode.production? Origen # => false Origen .mode.debug? # => true Origen .mode.simulation? # => true For example this API can be used to create simulation workarounds if required: if Origen .mode.simulation? # Generate something that is more simulation-friendly else # Generate a pattern construct which works on the tester, but doesn't simulate well end The mode can be set like this: .mode = Origen :production Origen .mode = Origen :debug .mode = :simulation Note that the mode can be frozen in which case the above will have no effect. If the mode\n is supplied via a option to the current command, then it will be automatically frozen\n to allow it to override any mode assignment made by the target or environment files via the\n above API. --mode Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/production/": {
    "title": "Production Targets",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Production Targets The following concerns may arise when releasing your application to 3rd parties\nwho will then go on to use it to generate production grade IP: Your application may support many different devices and targets, however only\na subset of these may be considered production ready at a given release\npoint. When lots of targets are available how do we ensure that the user picks the\ncorrect one? This is certainly an area where Origen has scope for further improvement, but for\nnow the following system works adequately and is being used today in large-scale\nproduction applications… Select the Target by Maskset Number Establish the convention with your user base that when generating IP for production\nthe target must always be selected by providing the maskset number (including\nthe revision). So for example someone using an application to generate production IP for a device\nwith maskset 1M79X should select the target like this: origen t 1m79x This keeps things simple for the end user and removes the need for them to\nchoose a target. Mapping Masksets to Targets To enable the above feature a map must be added to your config/application.rb file like this: # config/application.rb config.production_targets = { \" 0m79x \" => \" , eagle_0 \" => \" \" \" 0n30d , falcon_0 \" \" => \" 1n92a ,\n} \" osprey_1 \" Now whenever a maskset number is entered as a target the above table will be referred\nto automatically to select the actual target file. If giving the user a choice over the actual target to use is unavoidable, the number\nof options can be reduced by mapping a given maskset to multiple targets: config.production_targets = { \" # config/application.rb => [ \" \" \" 0m79x eagle_0_func \" , eagle_0_bist \" ], \" => 0n30d \" \" falcon_0 \" , 1n92a \" => \" \" ,\n} osprey_1 \" Now a user selecting 0M79X will be presented with a message showing the two options\nand will be asked to choose one of them. Although not generally recommended, it is also possible to map multiple maskset numbers\nto the same target: # config/application.rb config.production_targets = { 0m79x => [ \" \" eagle_0_func \" , \" \" eagle_0_bist ], \" \" => 0n30d \" \" , falcon_0 \" => \" 1n30d \" , \" falcon_0 \" \" 1n92a \" => \" osprey_1 ,\n} \" Finally if a specific target(s) is not supported for a given release it can be easily disabled\nby commenting out the relevant line(s): config.production_targets = { # config/application.rb \" => [ 0m79x \" \" , eagle_0_func \" \" eagle_0_bist \" ], # \"0n30d\" => \"falcon_0\", # \"1n30d\" => \"falcon_0\", \" => 1n92a \" \" ,\n} osprey_1 \" Now any requests to select target 0N30D or 1N30D will give a not found error. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/programming/": {
    "title": "Programming",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Programming This guide discusses how to programmatically change the target, note that this will also\nreload the environment as discussed here: How the Runtime Environment is Applied If you start you may want to programmatically define or manipulate the target. writing your own commands A single target should always be loaded by using the following method, it\ncan be called again to later switch to a different target: .load_target( Origen \" ) falcon_1 \" Warning - \n If you browse the API you may see some similar methods described for loading\n the target, however these should be avoided. The above method is the intended\n public API and will ensure that all dependencies are setup correctly. With the above warning in mind the can be consulted to see what additional methods are available to work with\nthe target,\nan instance of that class is available via Origen::Application::Target API Origen.target . For example to get the name of the current target: Origen .target.name # => \"falcon_1\" Configurable Targets Any options passed into the Origen.load_target method can be accessed\nfrom within the target and used to customize it by the caller. For example here is a target where the device version is left for the caller\nto specify: :: $dut = # target/falcon.rb MyApp Falcon .new( version : options[ ]) :version This would be used like this: Origen .load_target( , \" : version ) falcon \" 1 $dut .version # => 1 .load_target( \" , version Origen falcon \" : ) 2 .version $dut # => 2 Target Loops Target loops (where some code is repeated for a collection of targets) are\nvery common and Origen provides some dedicated helpers for this. The method is the most useful in a\ncommand situation and is designed to\ngenerate a loop based on the value of a Origen.target.loop :target key in an\noptions hash. This option can contain the name of a target or an array\ncontaining multiple names, and if none are present it will fall back to the\ndefault target following the normal conventions. It is therefore ideally suited to creating a command where the user can\nsupply one or more targets and could be used like this: opt_parser = .new OptionParser do |opts|\n opts.on( , \" -t \" , --target NAME1,NAME2,NAME3 ] = t } \" \" , Array \" Override the default target, NAME can be a full path or a fragment of a target name \" ) { |t| options[ :target opt_parser.parse! .target.loop(options) end ARGV Origen |options| do # The current target is already loaded, the name of the current target has been substituted into options[:target] puts \" The name of the current target is: #{ options[ } ] :target \" # Implement your command logic here... end The above would work with any of the following inputs: # Execute for the current default target\norigen my_command \n\n# Execute for a single specific target\norigen my_command -t falcon \n\n# Execute for multiple specific targets\norigen my_command -t falcon,eagle Production Target Loops If your application has defined a then some additional methods are available to loop on that: production target map .target.each_production Origen do |maskset| # Do something for each maskset line defined in the map end .target.each_unique_production Origen |masksets| do # Do something for each unique target defined in the map end The latter will only execute for unique target files, so if the same file is used\nby multiple maskset numbers it will only be looped once and the masksets argument\nwill be an array containing all maskset numbers that use that target. Forcing Debug Mode All of the above looping methods accept an option to force all targets to debug mode,\nthis can be useful depending on the purpose of your command, but should obviously\nbe avoided in cases where the command is concerned with generating production IP. Origen .target.each_production force_debug : true do |maskset| # As above except Origen is running in debug mode regardless of the mode defined by the environment end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/target/": {
    "title": "Target",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Target All targets are defined by files that reside in the directory.\nTargets are regular Ruby files and they should be simply named: target <identifier>.rb Normally the target is used to select the target device and they are simply named after\nthe device that they instantiate, e.g. target\n|-- eagle.rb\n|-- falcon.rb\n|-- vulture.rb\n`-- osprey.rb Creating a Target To create a new target, simply create the file containing whatever Ruby code you need.\nThey are usually very concise and normally only instantiate the\ntarget device model, here are some examples: # target/eagle.rb = :: $dut MyApp .new Eagle # target/falcon.rb = $tester :: MyApp .new Falcon A common variation on this theme is to have different targets for different versions of\nthe device that are available, or perhaps to configure the model differently for different\ntypes of test: # target/eagle_1.rb = $dut MyApp :: .new( Eagle : version 1 ) # target/eagle_2.rb $dut = MyApp :: Eagle .new( version : 2 ) # target/falcon_func.rb = MyApp $dut :: .new( Falcon : configuration :func ) # target/falcon_bist.rb = $dut MyApp :: .new( Falcon : configuration :bist ) Setting a Default Target A default target can be defined that will be used withing a new workspace unless the user\nspecifies otherwise. This is not required and should only be added if it makes sense within the\ncontext of the application - i.e. you may choose not to have a default to avoid the situation where the user\nbuilds something without really understanding what configuration they are targeting. A default is specified by creating a target file called target/default.rb ,\ntypically this is a symbolic link to another target file: ln -s target/falcon_bist.rb target/default.rb Getting and Setting the Target The current target for a given application workspace can be queried by running the command, or origen target for short, this will show\nyou the content of the current target file: origen t > origen t\n\nCurrent target: falcon_bist.rb\n**********************************************************************\n $dut = MyApp::Falcon.new(configuration: :bist)\n********************************************************************** The target can be changed by running the same command and supplying the desired target: > origen t target/falcon_func.rb\n\n> origen t falcon_bist As shown above, a full path or any snippet which is enough to uniquely identify one of the available\ntarget files is sufficient. Additionally all Origen commands allow an override to be supplied at runtime: > origen g my_pattern -t eagle_2 Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/app/": {
    "title": "Creating a New App",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Creating a New App Once you have installed Origen, you should\nfind that you now have access to an ‘origen’ executable from anywhere. Run from the command line and you should see this: origen Usage: origen COMMAND [ARGS]\n\nThe following commands are available:\n new Create a new Origen application or plugin. \"origen new my_app\" creates a\n new origen application workspace in \"./my_app\"\n interactive Start an interactive Origen console (short-cut alias: \"i\"), this is just\n IRB with the 'origen' lib loaded automatically\n fetch Automatically creates the workspace for the requested plugin and\n populates the latest version of the plugin (short-cut alias: \"f\")\n\nMany commands can be run with -h (or --help) for more information. Because you are currently outside of an Origen application, there is a reduced set\nof commands available. The origen new command should be used to generate a new application. Running the New Application Command To create a new application run the command like below and answer the questions\nat the command prompt: origen new my_app_name The new application will be custom built depending on your answers to the\nquestions and it should need no additional configuration to get started. You can immediately start adding your application specific logic to the directory. lib Documenting Your Application All new applications come with a pre-built framework for creating web-based\ndocumentation of your application - just like the page that you are currently\nreading. To build the initial example documents: origen web compile -a Then just follow the instructions to point your browser to the address that\nis output from the above command. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/commit/": {
    "title": "The Initial Commit",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen The Initial Commit Origen applications should be configured with details of the revision control\nrepository that they will be checked into, this will enable the following features: A release command which will tag and perform common post-release tasks. A common project-level history will be maintained, regardless of the underlying system used. An API for programmatic control of the revision control system, this provides\napplication and plugin developers with a common API to call regardless of the underlying system that\na given application uses - . Revision Control API A common command, origen rc to provide a common interface for application users to\nperform basic revision control operations regardless of their proficiency with the underlying system. Supported Systems Origen currently supports integration with the following revision control tools: Git DesignSync We would like to add support for Subversion and any other commonly used systems. If you have knowledge\nof how an additional target revision control system works and you would like to be involved in developing\nand piloting a driver for it, please get in touch via the . community channels Having said that, the Origen core team recommends using Git, even if you have had little or no\nexperience of it so far.\nIt has significant advantages and is fast becoming the de facto standard revision control tool used\nin software engineering. Initial Configuration Configuration information for your application resides in config/application.rb and an initial version of this file will have been created for you. This file contains a lot of configuration options which you should find fairly well commented.\nThe option that defines the revision control system is called rc_url and it should\nbe set as follows. For Git: config.rc_url = # config/application.rb # Example for Github \" git@github.com:myaccount/myapp.git \" # Example for Atlassian Stash config.rc_url = \" ssh://git@sw-stash.mycompany.net/myproject/myapp.git \" For DesignSync: config.rc_url = # config/application.rb \" sync://sync-1234:1234/myproject/myapp \" Setting Your Name and Email Origen will maintain a history log for your application at doc/history . The name of the person who did each release will be recorded\nif Origen can work out who you are (your name will also included within generated pattern headers\nand similar). Setting up your username and email in Git is the recommend way, even if you don’t actually\nuse Git for the given application.\nYou can set these details by executing the following commands: git config --global user.name \"John Doe\"\ngit config --global user.email johndoe@example.com If you don’t have Git available then alternatively you can set the following environment\nvariables: ORIGEN_NAME = \"John Doe\"\nORIGEN_EMAIL = \"johndoe@example.com\" You can test whether your changes have been picked up by opening an Origen console ( )\nand running the following: origen i .current.name User # => \"John Doe\" .current.email User # => \"johndoe@example.com\" An alternative path to determining your details could be via your company’s employee directory\nsystem. Origen’s company configuration settings allows\nthe credentials for an LDAP system to be entered, and this approach is used within Freescale\nto identify the current user. We are not sure if the current support for this within Origen is\ngeneric enough to apply to other companies or not, please if\nyou are interested to help further develop and pilot this system for use within your company. get in touch Commit and Tag With your repository and user details setup, we can now do an initial commit and tag. Warning! - \n When executing this command pay attention to the prompts and confirm that\n the target repository reference exists and is correct. cd myapp\n\norigen rc init We are now ready to tag, to do this simply execute the following command and\nfollow the prompts: origen rc tag At this point Origen would normally have emailed you and your application’s subscribers to\nnotify them of the new release, however we are still working on how this subscription system\nshould work in the open source world. Expect it to be available within the coming months. History Your commit history will be saved in your history file which by default lives\nat doc/history . The content of that file is automatically formatted for future presentation on a web\npage, the Origen are simply the Origen\ncore history file converted to HTML. Release Notes When writing your release notes you can use markdown to control how they will be presented when they are later converted to HTML. You can also pre-write your release notes by writing them to in the top level of your application directory - \nrun release_note.txt origen rc tag -h for more details. Universal Revision Control Command Once your application has been committed for the first time you can then use the command to work with your revision control system (or you can\nof course continue to use it directly if you prefer). origen rc See for details of the available commands. origen rc -h Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/company/": {
    "title": "Company Customization",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Company Customization A mechanism is provided to customize the Origen installation to a particular\ncompany. The main customization options that this currently provides are: An internal gem server. This can be used to distribute private Origen plugins\nwithin your company. When this is defined any new Origen applications that are created\nwill automatically come configured to read from your server in addition to rubygems.org. Integration with your company’s email delivery system, allowing your applications to\neasily send transactional email to their users. Integration with your company’s LDAP user authentication system. This API may not be\ngeneric enough yet, but it is used within Freescale and we are keen to work\nwith anyone who wants to pilot it within another company. How The Configuration System Works Whenever an application is invoked, one of the first things that Origen will do is search\nfor a company configuration file called . origen_site_config.yml Starting from the application directory, the file system will be checked for the presence\nof any valid configuration files within the application’s root directory, and then in any of its parent\ndirectories until it hits the file system root directory. It will then check for a configuration file within the directory where Ruby is installed,\nand then again recursively through any of its parent directories. If multiple files are found then they will all be applied, with highest priority given\nto the files that are found first - i.e. those located closest to the current application. So for example, if everyone in your company uses a common Ruby installation, then you can put a config\nfile somewhere in Ruby’s directory and it will be globally applied. Alternatively, if all of your users have their workspaces underneath /proj or\nsimilar, then may be a good place to put it.\nThis also provides a mechanism for per-project or even per-application overrides by\nadding additional config files higher up the tree. /proj/origen_site_config.yml Creating the Configuration File To create a config file simple copy the default configuration from Origen core and edit it as required. The values present in this default file are the ones that will be applied by default in\nan installation where no custom configs are present. Testing the Configuration File To test if your configuration values are being applied, open a console within an\nOrigen application: origen i You can then query the current live values via the following API, where the method names\ncorrespond directly to the attribute names in the config file: .site_config.gem_server Origen # => nil Origen .site_config.gem_manage_bundler # => true Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/core/": {
    "title": "Core concepts",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Core concepts There are some core concepts and terminology that should be understood up front in order for\nthe rest of the documentation to make sense. Origen Application An ‘Origen Application’ is an engineering application of some sort that has been built using the Origen\nplatform. Origen Core ‘Origen Core’ refers to the Origen platform itself.\nAlthough different applications may be using different versions of Origen core at any one time,\nit does follow a single thread of development and the latest version should be able to support\nany Origen application. Origen core (or one of its plugins) should take care of all of the common tasks that are not application\nspecific. This means that an application developer should spend most of their time working\non things are unique to their particular application domain, and not worrying about how to open a file for\nwriting, or what the vector format for a given ATE is. APIs The term API stands for ‘Application Programming Interface’, which basically means a set of methods\nthat are exposed to the application to allow an engineer to programatically tell Origen what to do or build. Origen provides various APIs for different functions such as to describe the registers within a model,\nto generate pattern vectors, to build web pages, etc. Plugins The Origen platform provides a plugin system that allows 3rd parties to develop additional APIs to\nsupplement those provided by Origen core.\nThe Origen core team maintain a collection of important plugins which are considered extensions of\nOrigen core, but anyone in the community can create and share a plugin. Application owners can control what versions of what plugins are used in their application. Origen also has a mechanism for companies to maintain an internal plugin repository so that its plugin\nsystem can be used to internally distribute proprietary code such as test blocks for a given silicon\ntechnology. Ruby Ruby is the programming language that has been used to create Origen, all Origen applications are\nalso written in Ruby. Anatomy of an Origen Application An Origen application is comprised of the following main components: Models Models are the foundation of an Origen application and encapsulate all meta-data about the silicon\nobject that they represent.\nThis can include but is not limited to: registers and bits, pins, and specs. \nModels can also instantiate other models, thereby allowing a full hierarchical representation of the target\ndevice to be constructed. The models also track state (while generating a test pattern for example), with the register and pin\nobjects behaving much like their silicon counterparts. Controllers Controllers are a concept used in test engineering applications, where each model is assigned\na controller that will be responsible for defining APIs to perform pattern operations based on the\ngiven model. For example, the controller for a analog-to-digital converter (ATD) model might define a ‘convert’\nmethod. This method would define\nthe sequence of register transactions that are required to do an ATD conversion. A ‘method’ by the way, is simply a function that is associated with a given object in a object-oriented\nprogramming language. Drivers Drivers, is the term generally used to refer to objects that control a protocol (e.g. JTAG) or some\npiece of non-silicon hardware like a tester for example. There is no dedicated Driver class in Origen and these will usually be constructed from the same\nOrigen APIs as used for Models and Controllers. Indeed the drivers could well be composed of a model\nof the associated hardware and a controller for it. Target While your application could define many different models for different silicon products, the\nonly one that matters at any one time is the one that you are targeting - that is the one that the\ngiven output should be compatible with or represent. An application can have many targets where each one is responsible for instantiating a model (or models)\nthat represent a single runtime condition or context that Origen should apply when\ngenerating content. In test engineering applications, it is usual for the target to instantiate a single top-level\nmodel called , representing the device under test. $dut Generally the term ‘target’ is used to refer to the current combination of target + environment… Environment The environment can be thought of as a higher level target, which is used to define runtime setup that can\nbe used in conjunction with many different targets. In test engineering applications, it is usual to use the environment to instantiate the target\ntest platform, normally this is assigned to the global variable . $tester Templates Origen has two main ways of generating dynamic ASCII output, the first is via the use of templates.\nThis is the most flexible way of generating dynamic content - the application provides a template\nfile which has been marked up with where dynamic content should go, Origen will then process it\nwithin the context of the current target to generate a target specific version. Origen does not care about what the template represents and it could be anything from design IP, to\nweb pages, to tool configuration files. Sources The second way of generating content is via APIs. In this case the generated content comes from\ncalling Origen methods via Ruby code, rather than from compiling a pre-written template.\nFor example, when creating a test\npattern the act of writing a register can be expressed via an API - -\nwhich will then be translated into the necessary vector stream by Origen. $dut.myreg.write!(0x5) The files which co-ordinate the APIs to build a specific output are called source files. For test engineering applications, source files are used to describe patterns and test flows, though\nOrigen does also support a source-less approach to pattern generation based on the pattern name. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/gems/": {
    "title": "Understanding Gems",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Understanding Gems Ruby gems is the de facto standard package manager used by the Ruby community. This allows Ruby code\nto be packaged up so that it can be used throughout the community while being maintained from a single source. provides free, centralized hosting for these gems and anyone\ncan create a new gem and upload it there. RubyGems.org The job of a dependency manager is to resolve the gem version requirements\nof all gems used within an application (an application can depend on a gem, which may itself depend on\nother gems), so that they will all have access to a runtime environment containing the correct versions\nof the gems that they need.\nAt the time of writing, the Ruby gems system does not provide dependency management and this roll is\nfulfilled by a 3rd party tool called (though it is planned for Bundler to be integrated into Ruby\ngems in future). Bundler Origen and all of its plugins are distributed as Ruby gems and Bundler is used for the dependency\nmanagement. This guide will teach you how to use Ruby gems within your applications, tell you what you need to\nknow about using Bundler within the context of an Origen application, and give you an appreciation for\nhow the Origen runtime environment works. Specifying Gems Every Origen application has a file named Gemfile in its root directory, this is where\nthe gem dependencies for the given application will be specified. Here is an example Gemfile: source ' gem https://rubygems.org ' ' , origen ' gem ' >= 0.5 ' ' origen_debuggers ' gem ' roo gem , ' ' ' origen_testers : path ' /path/to/local/origen_testers ' gem ' origen_jtag , ' git : ' , ' https://github.com/Origen-SDK/origen_jtag.git ref : ' ad323f ' Points to note on the above: The source line specifies the gem library where the gems are hosted, in the Ruby community every\ngem is hosted on rubygems.org. Multiple sources can be used, and in practice for an Origen application this\nmeans that you can also add a company internal gem server to host private Origen plugins ( ). see below The gem import line shows how you can specify a dependency on a specific (or in this case minimum)\nversion of a given gem. See section of the RubyGems.org documentation for details on how to specify version numbers within a semantic\nversioning system. origen this section The origen_debuggers and roo lines show how to add Origen plugins and non-Origen\ngems to your application - the process is identical. Note that with no version specifier the latest production\nversion will be fetched when your gem bundle is built. The origen_testers line shows how to use a local copy of a given gem/plugin, this allows you\nto make changes to the given gem to add a feature or fix a bug, and then try it out within your application.\nOrigen will not allow execution with a path reference in production mode, since it is an inherently a non-reproducible\nenvironment for the future. Git references can also be used, here to pick up a specific commit of the gem direct from its repository. This can be used to pick up a pre-release version of a gem that contains\na specific feature or bug fix that you need immediately. origen_jtag The Gemfile system is provided by Bundler and the can be consulted for more information. Bundler guide on Gemfiles Importing Gems Origen takes care of setting up Bundler so that it will work in the common corporate scenario where the\nuser does not have the root access required to install the gems to the system Ruby installation.\nTo ensure that Bundler is properly configured, it is critical that an Origen command is run first in\na new application workspace, before any attempts are made to run Bundler directly. A common way of doing this is simply to run the origen -v command upon first setting\nup a new application workspace. This command will invoke Bundler with the required configuration\nautomatically and all of the required gems will be installed to . ~/.origen/gems Unfortunately Origen has not yet managed to completely wrap Bundler and sometimes there will be a\nneed to invoke it directly.\nThis usually occurs when you have changed the version requirements of a particular gem within\nyour Gemfile. Once you have changed the requirement you should run: bundle update <gem_name> This will tell Bundler to update the version of the given gem, but leave the versions of everything else\nas they are. Sometimes however the new version of the given gem will itself require a new version of\nsome other dependent gem, in that case you will get an error and you can try running this command\nto resolve it: bundle If you still have an error, then updating the complete bundle will resolve it: bundle update Note that this will fetch the latest version of every gem in your bundle that has an open-ended\nversion dependency. This can result in more changes to your environment than you really want/need\nand is therefore usually best kept as a last resort. Company Internal Gems As experience with Origen grows, you will begin to start creating your own plugins/gems, many of\nwhich will contain company proprietary IP that you will not want to release via the open source\ncommunity.\nTherefore a way of privately hosting these gems is required. An easy way of doing this initially is to use Git as the revision control tool for your plugins,\nthen you can use Git references within your Gemfiles as discussed above. A better solution though, is to setup a gem server within your company intranet, and we recommend this server .\nYou will likely need to work with your IT department to get this setup and maintained. When it is available, simply update your Gemfiles with the additional server like this: source source ' https://rubygems.org ' ' http://gems.mycompany.net:9292 ' gem ' origen ' gem #... ' private_test_block ' At that point you should also update your company’s Origen configuration with the details of the new server, in that way the origen new command will automatically\nconfigure your new applications with the required source reference in the Gemfiles. Gemfile.lock A file called Gemfile.lock will be created by Bundler in the application’s top-level\ndirectory and this should be checked into the revision control system. The purpose of this file is to record the absolute versions of all gems that are currently\nused by the given application. This means that when another developer, or one of your application’s\nusers, checks out a given version of your application into a new workspace, then the exact same\ngem versions will be used as when it was originally tested and checked in. This means that it safe (and in fact recommend) to leave the gem versions largely unspecified by your Gemfile,\nas it does not mean that different user environments will be running different gem versions. Executables If your gems provide command line executables that you wish to run, then these need to be invoked through\nBundler to make them run within the context of the application’s gem environment (bundle).\nSay for example that a given gem provides an executable called , then to run this from your\napplication’s command line you should do: clean bundle exec clean This applies to the executable too, however as this is cumbersome to write and\neasy to forget, Origen employs some tricks that will enforce this wrapping automatically, so Origen\ncan always be invoked with just: origen origen <command> Bundler will build wrapped executables within an application’s directory, these\ncan be invoked directly without the need for the lbin prefix, so for example the bundle exec clean executable could be correctly invoked by running: ./lbin/clean This is arguably easier to write than , but it can still be easy to forget. Therefore\nif your application has a need to run 3rd party executables a lot, then it is recommend to add\nthe application’s bundle exec directory to your path so that you can simply run: lbin clean System Origen It was noted in the Origen installation guide that the base Origen version installed to your system Ruby does not really matter, and it does not need to\nbe updated to the latest version of Origen on a regular basis. This is because the base Origen is only used to either create a new Origen application, or to initially\nboot an Origen command within an existing application. In both cases, the version used to initially boot\nOrigen is unimportant. In the case of creating a new application, Origen will always pull in the latest and greatest application generator\nand this is not statically linked to the version of Origen that is being executed to build the new app.\nSimilarly, when running an Origen application the thread will immediately switch over to run the version\nof Origen specified in the Gemfile instead of the system version. This system therefore ensures that application owners are in control of what version of Origen is used by\nthe users of their application, however neither the application owner or their users need permissions to\nupdate the system Ruby installation in order to achieve the required runtime environment.\nThey simply checkout the version of the given application that they want, and then Origen/Bundler\ntakes care of guaranteeing that the runtime environment is the correct one. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/installing/": {
    "title": "How to Install",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen How to Install Origen can be installed on Linux or Windows, this guide refers to the Linux installation. If running on windows is of interest then please see this guide instead: How to Install Origen on Windows Background Origen is distributed as a Ruby gem, which is the Ruby language’s package manager. Installation of Origen consists of the following steps: Install Pre-Requisites Install Ruby Install Origen (optional) Customize your installation Install Pre-Requisites To install Ruby, your system will need a C compiler and the Make utility. Installation of this\nwill vary depending on your particular Linux distribution, but for example on Ubuntu\nthe required build environment can be installed by running: sudo apt-get install build-essential It is also recommend to install a recent version (2.x) of Git, if you don’t know how to\ndo that, google for . “how to install Git on <your distribution>“ Install Ruby Origen requires a , you can install this or the latest version. minimum Ruby version of 2.1.0 If you are working from a personal Linux box (or VM), or if you want to install Ruby for\nyourself only, we recommend that you install it via and follow these rbenv . installation instructions This will install Ruby to your home directory and will not require you to have root access. If you are working from a corporate environment where a central Ruby installation will\nbe used by many users, we recommend that you follow the instructions on the . official Ruby installation guide Most likely building from source will be the most appropriate choice in this case, especially\nif dealing with an older Linux distribution, since the version available from your system’s\npackage manager will probably be quite old. If you have any particular problems installing Ruby, please so that we can build up a record of common problems and solutions. use this discussion thread Install Origen Once you have Ruby successfully installed, Origen can be installed very easily via: gem install origen --no-rdoc --no-ri You can then verify Origen availability by running origen -v at which point you should see something like this: Origen: 0.4.2 Congratulations, Origen is now installed! Note that the version of Origen that is installed to your Ruby installation does not need to\nbe kept up to date with the latest version of Origen. You can now consider your Ruby environment\nto be frozen for the foreseeable future. See the section on for details on\nwhy that is. Understanding Gems A Note on Nokogiri A common problem with the final step of installing Origen is to run into problems installing\na gem called Nokogiri (which is one of Origen’s dependencies). Generally the more recent your Linux distribution is, the less likely you are to have problems\nwith this. It is beyond the scope of this document to deal with likely causes and solutions, however if\nyou do run into problems google should yield plenty of hits of similar cases and hopefully\nwith guidelines on how to fix it. You can also report problems via this Origen forum thread on Nokogiri Installation Issues and we will do our best to provide help, or you can actually just comment below… Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/installwin/": {
    "title": "How to Install (Windows)",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen How to Install (Windows) Origen can be installed on Linux or Windows, this guide refers to the Windows installation. The lack of a package manager in windows makes it harder to install various packages from the command line. We recommend using ; an open source windows package manager. chocolatey You can imagine chocolatey to be somewhat like apt-get or other package managers on Linux, but built with Windows in mind. This guide will use chocolatey as the package manager to: Install Ruby Install Ruby-Dependencies Install Ruby-Development-Kit Install RubyGems Install RubyGems-SSL-workaround Install Utilities Note: Origen installation has been tested on Windows 7 only at this time, but we don’t think the installation process will be any different. An active internet connection is required before proceeding. If running on Linux is of interest then please see this guide instead: How to Install Origen on Linux Background Origen is distributed as a Ruby gem, which is the Ruby language’s package manager. Installation of Origen consists of the following steps: Install Ruby Install Ruby-Dependencies Install Origen Install Chocolatey All commands mentioned below need to be typed in the command prompt running as an administrator Start → run → cmd runas /user:Administrator 1. Chocolatey To install the package manager (chocolatey), please type the text below in the command prompt (running as administrator) @powershell -NoProfile -ExecutionPolicy Bypass -Command \"iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin Install Ruby With the package manager installed, Installing Ruby is a breeze. Just type the following in the command prompt window (running as administrator) cinst ruby -y --force This should install Ruby v2.1.6 (latest supported by the package manager as of writing this guide) If the package manager upgrades to the latest version (v2.2.3), it will install that latest version instead. Please check the ruby version and make a note of it. We will need it later for the RubyGems workaround. ruby -v Once the installer finishes, please close the current window and open a new one (as administrator) Install Ruby-Dependencies Install Ruby-Development-Kit In the new window, type the following cinst ruby2.devkit -y --force Install RubyGems In the same window, now type cinst rubygems -y --force Install RubyGems-SSL-workaround The latest version of Rubygems (that we installed above) is currently broken on Windows.\nHowever, there is a workaround that has been developed and it involves a series of steps.\nThe workaround also depends on which version of Ruby has been installed. The following commands will perform all the steps required for the workaround. If Ruby version installed is v2.1.X @powershell (new-object System.Net.WebClient).DownloadFile('https://github.com/rubygems/rubygems/releases/download/v2.0.15/rubygems-update-2.0.15.gem','C: ubygems-update-2.0.15.gem') && gem install --local C: ubygems-update-2.0.15.gem && update_rubygems --no-ri --no-rdoc && gem uninstall rubygems-update -x If Ruby version installed is v2.2.X @powershell (new-object System.Net.WebClient).DownloadFile('https://github.com/rubygems/rubygems/releases/download/v2.2.3/rubygems-update-2.2.3.gem’,'C: ubygems-update-2.2.3.gem') && gem install --local C: ubygems-update-2.2.3.gem && update_rubygems --no-ri --no-rdoc && gem uninstall rubygems-update -x Once the command finishes, please check the gem version installed by typing gem --version The Gem version should be v2.0.15 for Ruby v2.1.X or v2.2.3 for Ruby v2.2.X Install Origen Origen is available as a packaged gem and can be easily installed by typing: gem install origen --no-ri --no-rdoc *this can take several minutes to finish without updating the screen, so please be patient You can then verify Origen availability by running origen -v at which point you should see something like this: Origen: 0.4.2 Congratulations, Origen is now installed! Note that the version of Origen that is installed to your Ruby installation does not need to\nbe kept up to date with the latest version of Origen. You can now consider your Ruby environment\nto be frozen for the foreseeable future. See the section on Understanding Gems for details on\nwhy that is. Install Utilities It is also recommend to install a recent version (2.x) of Git We can do that easily now by typing cinst git -y This will install Git v2.5.2 (latest version available as of writing this guide) Optional: We recommend that you also install the following utilities for a more UNIX like experience on windows. UnxUtils (cinst unxutils -y) ConsoleZ (cinst consoleZ -y) Console2 (download from http://sourceforge.net/projects/console/) Video For your convenience, you can also watch the installation process in the video below. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/introduction/": {
    "title": "Introduction",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Introduction Welcome to the Origen guides! The Origen platform is written in Ruby\nand following this documentation will take you from a complete beginner to an\nOrigen expert. This site is focussed specifically on the Origen API, but for background on Ruby the\ninternet is your friend.\nRuby is very popular for web development and as such it is extremely easy to Google\nfor solutions to any Ruby-related problems that you may come across, or to find\ntutorials from which to learn. The official Ruby website contains a quick tutorial on Ruby to get you started: Ruby in 20 Minutes Previous engineers who have learned Ruby have recommend the following resources: Learn Ruby at rubymonk.com Learn Ruby at codeacademy.com Ruby for Newbies Video Tutorials Ruby Koans If you want to use regular expressions in your code the following website is invaluable: Regular Expression Editor Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/plugins/": {
    "title": null,
    "subtitle": null,
    "body": ""
  },
  "/release_notes/": {
    "title": null,
    "subtitle": null,
    "body": ""
  }
}