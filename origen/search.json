{
  "/community/": {
    "title": null,
    "subtitle": null,
    "body": ""
  },
  "/guides/compiler/creating/": {
    "title": "Creating Templates",
    "subtitle": "Compiler (Views)",
    "body": "Compiler (Views) Creating Templates A template is created by taking an existing ASCII file and embedding Ruby\nsnippets to either conditionally include/exclude parts of it or to actually\ngenerate content into the output file. By convention all template files associated with an Origen application live\nin a sub-directory of the templates directory. However it is also\npossible to compile templates that live outside of the application as long as\nthey are accessible via a path from the Origen application workspace. Normally templates are identified by appending the extension .erb to the filename. So for example a template for the file dut_regs.h would be called dut_regs.h.erb . Appending the .erb extension has the following advantages: When Origen is asked to compile a directory only those files ending with the .erb extension will be processed through the compiler. The other\nfiles will be copied across to the output directory unmodified. This can be\nuseful if you want to store binaries or some other non-compiler friendly files\nalongside your template files. If you use an editor like Vim it can be setup to recognize the .erb extension and then syntax highlight the embedded Ruby snippets as\nRuby, while highlighting the rest of the template in its native format. If you would prefer not to have to add the .erb extension add the\nfollowing to your application configuration, this will cause all files presented\nto the compiler to be evaluated for embedded Ruby regardless of their name. # config/application.rb config.compile_only_dot_erb_files = false Template Syntax The compiler uses a markup language called ERB (embedded Ruby) which ships as\npart of the Ruby language and has a very minimal and easy to learn syntax.\nThis makes the entire Ruby language available to conditionally include or\nexclude portions of the file, to expand sections of the file via loops, or to\ninject dynamic snippets that will be evaluated at runtime. Most importantly of all\nof course the runtime ERB environment will have full access to the models that\nhave been instantiated by the current target. Here is an example of a text file to which some ERB has been added: The ERB syntax is very simple:\n% # Lines that start with % (no spaces allowed before it) will be interpreted\n% # as Ruby. Since these lines start with a comment character they will simply be\n% # deleted by the compilation process - very useful for annotating your source files!\n\nRuby logic can be used to conditionally include/exclude lines:\n% if 1 == 1\n You will see me in the compiled file\n% else\n But you won't see me :-(\n% end\n\nLoops can be used to expand the content:\n% 3.times do\n I must not talk in class\n% end\n\nInject dynamic content like this: 4 + 4 = <%= 4 + 4 %> Whatever is returned by a Ruby snippet <%= ' like this ' %> will be converted to a\nstring and output to the compiled file.\n\nAnd not forgetting the best part, you can access any objects that your\ntarget instantiates:\n\nMemory block details:\n% $dut.nvm.memories.each_with_index do |mem, i|\n Memory <%= i %> : Version <%= mem.version %> % end When this file is processed by the compiler it will look something like this: The ERB syntax is very simple:\n\nRuby logic can be used to conditionally include/exclude lines:\n You will see me in the compiled file\n\nLoops can be used to expand the content:\n I must not talk in class\n I must not talk in class\n I must not talk in class\n\nInject dynamic content like this: 4 + 4 = 8\n\nWhatever is returned by a Ruby snippet like this will be converted to a\nstring and output to the compiled file.\n\nAnd not forgetting the best part, you can access any objects that your\ntarget instantiates:\n\nMemory block details:\n Memory 0: Version 12\n Memory 1: Version 12\n Memory 2: Version 12\n Memory 3: Version 12 A Note on State When compiling multiple templates at once the target will be re-loaded\nprior to processing each template. This means that state cannot be carried forward from one template to the\nnext and generally prevents compile order dependent bugs from creeping\nin due to intentionally or otherwise relying on state that has been setup from a previous\ntemplate. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/compiler/helpers/": {
    "title": "Helpers",
    "subtitle": "Compiler (Views)",
    "body": "Compiler (Views) Helpers By default your templates have access to a small number of template specific\nmethods, such as the options hash, and the usual global scope. This means that your device attributes are normally accessed via\nthe global top-level objects that were instantiated in the target like this: % if $dut.analog.atd\n\nThe <%= $dut .part_number %> device has a <%= $dut .analog.atd.bits %> bit analog to\ndigital converter block which provides superior conversion accuracy... \n\n% end However you can easily create additional helper methods by opening the Origen::Generator::Compiler class\nand defining methods which can then be called directly from any template. As a trivial example if I was writing a large document about the ATD module it might\nbecome tedious having to keep writing $dut.analog.atd every time I wanted to access an ATD attribute. In that case the following helper method could be created to give me a shorthand access to the ATD\nmodel: # config/boot.rb require \" #{ Origen .root } /templates/helpers \" # templates/helpers.rb class Origen::Generator::Compiler def atd $dut .analog.atd end end The above template could now be re-written as: % if atd\n\nThe <%= $dut .part_number %> device has a <%= atd.bits %> bit analog to\ndigital converter block which provides superior conversion accuracy... \n\n% end These helper methods can become very powerful depending on what you are trying to generate\nwith your template.\nFor example the J750 test program sheets for the flagship Origen application were originally\ngenerated via templates\nand we built up quite a large library of helper methods to generate entire test instance lines\nand flow sheet entries. These helpers have since been incorporated into the Origen J750 generator and you should definitely\nuse that in preference to templates if you are generating a test program for that platform.\nHowever it shows that with templates + custom helper methods you can very easily build\npowerful ASCII generators for your specific domain. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/compiler/inline/": {
    "title": "Inline Compiler",
    "subtitle": "Compiler (Views)",
    "body": "Compiler (Views) Inline Compiler The conventional use of the compiler generates an output file for every template\nthat is compiled. Sometimes though it can be useful to invoke the compiler and get the output back\nas a string so that you can further process it, embed it in another file, or\notherwise work with it in some way. Use the following API\nto invoke the compiler in an in-line manner such that it will return a string\nrather than generate a file: Origen .compile( \" #{ Origen .root } /templates/my_template.txt.erb \" , some_option : 10 ) Any options given as shown above will be available in the options hash within the template in the usual way. The inline compiler will also accept the template in the form of a string: template = <<-END X is: END Origen .compile(template, string : true , x : 10 ) Changing Scope The compile command will accept a :scope option to\nhave the template compile such that ‘self’ inside the template will refer to an\nexisting object. i.e. to give the template direct access to all of that objects methods and attributes: Origen .compile( \" #{ Origen .root } /templates/my_template.txt.erb \" , scope : $dut ) For example let’s say we had a simple template like this to display some information\nabout an ATD block: # templates/atd.txt.erb\n\nType: <%= type %> Bits: <%= bits %> Then in our model let’s say we have two ATD instances: $dut .atd[ 0 ].type # => :sar $dut .atd[ 0 ].bits # => 16 $dut .atd[ 1 ].type # => :sigma_delta $dut .atd[ 1 ].bits # => 8 We can compile our template for each ATD as follows: template = \" #{ Origen .root } /templates/atd.txt.erb \" Origen .compile(template, scope : $dut .atd[ 0 ]) # => \"Type: sar Bits: 16 \" Origen .compile(template, scope : $dut .atd[ 1 ]) # => \"Type: sigma_delta Bits: 8 \" Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/compiler/introduction/": {
    "title": "Introduction",
    "subtitle": "Compiler (Views)",
    "body": "Compiler (Views) Introduction The compiler is probably the most versatile component of Origen and which will\nallow you to dynamically customize any ASCII file to the\ncurrent target. This is often called ‘creating a view’ of the current model/target.\nFor example this can be used to compile device-specific versions of your documentation,\nC code, RTL, test program sheets, Visual Basic, .csv files, etc, etc, etc. When employed in this capacity Origen is often used to replace traditional\npre-compilers (the place where your #ifdefs are evaluated) to provide\nthe benefit of being able to manage device configurations in an object oriented\nfashion. Additional benefits of the Origen compiler are: It is universal It could be the last compiler you ever need to learn Ideal for managing source files for different tool chains under a\ncentrally managed configuration e.g. compile RTL and firmware against\na common target model It is generally more powerful than domain-specific compilers The entire Ruby language is available to implement build logic It can actually generate content into the template as well as\nconditionally including/excluding sections of it It supplements Origen to cover gaps in the generation APIs e.g. the J750 test\nprogram generator does not currently provide a DC spec generator API, that\ngap can be easily plugged by using a template for that sheet Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/compiler/running/": {
    "title": "Running The Compiler",
    "subtitle": "Compiler (Views)",
    "body": "Compiler (Views) Running The Compiler The compiler is launched via the Origen compile command, see the command line\nhelp to get details of the most up to date options: origen compile -h As this is such a common command it has a short cut alias: origen c -h The compiler can be run on a single file: origen c templates/bench/dut_regs.h.erb or on a whole directory: origen c templates/bench In the case of running on a directory the compiler will recursively compile the\ncontents of all contained sub-directories.\nThe sub-directory structure will be maintained and mirrored in the compiler output directory. The given path can even be somewhere outside of the Origen application: origen c /proj/c28/eagle/jim/rtl_v A commonly used option is to specify the output directory: origen c templates/bench -o output/compiled_bench_code By default the compiled files will be put in output or whatever directory\nis returned by the config.output_directory attribute defined by config/application.rb . Submit to the LSF, by appending -l and optionally interactively\nwait for completion: origen c templates/bench -l -w Regression Testing Every time Origen compiles a file it will check to see if it has compiled it before, and\nif so it will compare the current version to the previous version and alert if there is a\ndifference. This can be used to check for regressions when making changes that you don’t want\nto affect the output, or to verify that the change is what you intended in cases where you\nare intentionally modifying the output. In the case of a difference being found Origen will automatically present you with the diff command\nto run if you want to view the change. To accept changes or to start tracking the differences in a file (or files) run the following command\nafter compiling: origen save all Programmatically Launching the Compiler If you start writing your own commands you may want\nto launch the compiler from Ruby, do that as follows: Origen .app.runner.launch action : :compile , files : \" path/to/input/file.erb \" Additionally the following options can be supplied: output : \" path/to/output/dir \" , # Override the default output directory output_file_name : \" my_name.txt \" , # Specify the output file name, by default is the name of the input file output_sub_dir : \" testflow \" , # Specify a subdirectory to be appended to the default output directory # The combination of these two options will run the compiler silently, allowing your application # code to handle all presentation of information about the created file to the user quiet : true , # Don't log to the console check_for_changes : false , # Don't check the output file for changes to a previous version # You can supply a hash of options that will be accessible within the template as 'options' options : { some_attr : true , some_other_attr : 20 } This can be combined with Target Loops to run the\ncompiler for multiple targets. A compile job can also be posted to the LSF by supplying the same options that you would use\non the command line like this: Origen .lsf.submit_origen_job( \" c path/to/input \" ) Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/compiler/subtemplates/": {
    "title": "Using Sub-Templates",
    "subtitle": "Compiler (Views)",
    "body": "Compiler (Views) Using Sub-Templates Sub-templates can be used to make parameterizable snippets that can then be\nre-used throughout your main templates. A sub-template is like a regular template with the following differences: Its name must begin with an underscore It has access to an options hash which contains any parameters\npassed in by the parent template The underscore is used in the name to identify the file as a sub-template\nto Origen and this will prevent it from trying to compile the file standalone\nwhen it is working through a directory. Here is an example sub-template in file templates/_sub_template.txt.erb : This is a sub-template.\n\n% options[:x].times do\n You will see this X times\n% end \n\nThe value of Y is: <%= options[ :y ] %> Sub-templates are called from a top-level template by using the render method, here is an example top-level template that calls this sub-template, this file\nis templates/example.txt.erb : This is a top-level template <%= render ' sub_template ' , x : 3 , y : 10 %> This would compile to: This is a top-level template\n\nThis is a sub-template.\n\n You will see this X times\n You will see this X times\n You will see this X times\n\nThe value of Y is: 10 import can also be used as an alias for render , this may\nbe more intuitive if the sub-template originates from a plugin for example. A Note on Path References Origen is fairly flexible when it comes to working out the path to a sub-template\nfrom a render method call. Generally the following rules apply: The leading underscore does not need to be added The .erb does not need to be added The filetype extension does not need to be added if it is the same as the calling\ntemplate’s extension Paths can be either: Relative to the calling template Relative to Origen.root Absolute Paths can also be a reference to a plugin’s shared directory, see here for\ndetails - Sharing Templates Defining Defaults A sub-template can define parameter defaults similar to a regular Ruby method,\nhere is the above example re-written to add default values that will be used\nif the parent template does not specify one of both of the options: % # Default option values...\n% options = {\n% x: 5,\n% y: 20,\n% }.merge(options)\nThis is a sub-template.\n\n% options[:x].times do\n You will see this X times\n% end \n\nThe value of Y is: <%= options[ :y ] %> Using Sub-Templates for Layout The render method also supports a block form which can be used\nto surround content from the parent template with header and footer content\nfrom the sub-template.\nDefine where the parent content should go using the yield keyword\nwithin the sub-template: This is some header content from the sub-template. <%= yield %> This is some footer content from the sub-template. Call in a parent template like this: % render \"sub_template\" do\n\nThis is some content from the parent template.\n\n% end This will compile to: This is some header content from the sub-template.\n\nThis is some content from the parent template.\n\nThis is some footer content from the sub-template. Options can be passed to the block form as you would expect: % render \"sub_template\", x: 5 do Nesting Sub-templates can themselves render other sub-templates. There is no limit on\nthe depth of template nesting and this can be used to build complex output from\nlayers of building blocks. Indenting Render will accept an :indent option to indent the compiled text\nby the given number of spaces: <%= render ' sub_template ' %> <%= render ' sub_template ' , indent : 2 %> <%= render ' sub_template ' , indent : 4 %> This would produce: Some lines from\nthe sub template\n Some lines from\n the sub template\n Some lines from\n the sub template A Note on Performance Sub-templates are much slower to process than content generated from a helper . Normally this is not\na problem but if for example a sub-template is rendered 1000 times within\na template file then you might be waiting quite some time for it to process. Normally this type of situation would occur when the sub-template is only generating\na single line and replacing it with a helper would immediately solve the\nperformance problem. As a general rule of thumb if you need to generate one or two lines of content\nthen use a helper, otherwise use a sub-template. A Note on State A sub-template is always evaluated with a fresh target load which means that state\ncannot be carried forward from the parent template via the target models. Generally this makes for more predictable behavior and ensures that customization of\nthe sub-template output can only be done via option arguments. Over time use of the model state to customize the sub-template output can result\nin compile order dependencies starting to creep in, and potentially this can be\nvery dangerous when it comes to compiling production critical output like test\nprogram sheets. However in cases where rendering performance is an issue and the implications of preserving\nmodel state into the sub-template are understood, the target refresh can be inhibited\nby using the following option: <%= render ' sub_template ' , preserve_target : true %> Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/controllers/direct/": {
    "title": "Direct Controllers",
    "subtitle": "Controllers",
    "body": "Controllers Direct Controllers Direct controllers provide identical functionality to Shadow controllers and you should read that guide first to understand the background here. Direct controllers are designed to work in the case where the model for a given IP block\nis managed by a 3rd party and not the test engineer responsible for the given block. Often\nthis may exist as part of a complete device model as shown here: From the perspective of the ATD test engineer, how the model is constructed is unimportant and\nthe main thing they need to know is what is the path to their sub-model of interest.\nLet’s say in our example that the model is instantiated as $model and the path to the\nATD model is $model.atd . Controller Implementation Creation of the controller is almost identical to the example Shadow controller . The key difference is that instead of linking the controller to a model class who’s instances it should shadow,\nit is instead linked to a model instance: # lib/atd_test_block/atd_controller.rb module ATDTestBlock class ATDController include Origen :: Controller model path : \" $model.atd \" # ATD pattern API implementation as before end end Instantiating the Controller This is where the main difference between Shadow and Direct controllers exists, the direct controller\nneeds to be instantiated directly: $model = SoC :: Eagle .new # Instantiates a model of the target device atd = ATDTestBlock :: ATDController .new\n\natd.convert( 10 ) # => <BitCollection> Once instantiated the atd object above will otherwise behave identically to the Shadow controller example . Typical Integration Application environments designed in this manner are a fairly recent development, and the best\npractices for how to build them are probably still to emerge. However here is one approach that would work;\nfirst the top-level controller would be created and managed by the top-level test engineer: class EagleController include Origen :: Controller model path : \" $model \" # Instantiate a model whenever a new controller is instantiated def initialize (options = {}) $model = Eagle .new(options) end # Instantiate an ATD controller as required def atd @atd ||= ATDTestBlock :: ATDController .new end end The target would instantiate the top-level controller, not the model: $dut = EagleController .new The ATD API is now available within the ecosystem as per the Shadow controller example : $dut .atd.convert( 10 ) # => <BitCollection> Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/controllers/introduction/": {
    "title": "Introduction",
    "subtitle": "Controllers",
    "body": "Controllers Introduction Controllers are a concept used for pattern generation and they are responsible for\ncontrolling a given model. As will be discussed in more detail in the pattern generation section ,\nit is bad practice for any 3rd party to reach into a model and directly\naccess its registers. This is because it tightly couples the 3rd party to the current\nimplementation of the given IP, which means that if the IP changes in the future then all\nof the 3rd parties who directly access the model’s internals may need to understand the\nchange. This can lead to test bugs, brittle\nenvironments, and significant maintenance issues as an application begins to scale. Instead it is better for the model to expose a consistent API (a set of methods) to allow the\n3rd party to invoke the functionality provided by the given IP, while shielding them from\nthe internal implementation details and the impact of future changes.\nOriginally there was no concept of a controller and such an API was created directly\nwithin the model itself,\nhowever this led to the model being used for two distinct concerns: Modelling the properties of the silicon IP and tracking state Implementing an API for pattern generation The first concern can generally be thought of as the responsibility of the design engineer,\nit is an immutable and unambiguous representation of the hardware as it was at the point\nwhen it taped out. As such, it never really changes until a new version of the hardware is released. The second concern has a different owner, the test engineer, and it is also much more fluid - \nnew functions can be added and the implementation of existing functions can change over time. It therefore made sense to separate these two completely different responsibilities given\ntheir completely different ownership models and lifecycles. So a given IP now has the following\ncomponents in the Origen domain: A model - responsible for modelling the hardware properties of the IP and tracking its state A controller - responsible for implementing an API to control the IP within test patterns A significant advantage of this architecture is that it allows the model to be created manually\nat first, and then later swapped out for a fully or partially imported model with no changes required\nto the controller or the wider ecosystem. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/controllers/shadow/": {
    "title": "Shadow Controllers",
    "subtitle": "Controllers",
    "body": "Controllers Shadow Controllers There are two flavors of controller. These provide exactly the same functionality, but\nthey are setup slightly differently and are designed to support two distinct approaches of\ncreating models within a test engineering application. The first type, the so called Shadow Controller, supports the case where the model\nis created and maintained by the test engineer for the given IP block. So for example, let’s say we have a test engineer who is responsible for an analog-to-digital\nconverter (ATD) IP, and they have decided to create an Origen plugin which will provide\na complete test solution for this IP.\nThis plugin will provide both the model and the controller as shown below: Here is a simple ATD model implementation which defines some register: # lib/atd_test_block/atd.rb module ATDTestBlock class ATD include Origen :: Model def initialize (options = {})\n instantiate_registers end def instantiate_registers # ATD control register reg :ctrl , 0x0024 do |reg|\n reg.bit 7 , :coco , access : :ro reg.bit 6 , :aien reg.bit 5 , :diff reg.bit 4 .. 0 , :adch , reset : 0x1F end # ATD data result register reg :result , 0x0028 do |reg|\n reg.bit 15 .. 0 , :d end end end end Controller Implementation A common thing that users of our test block might want to do is to use it to make the ATD perform a conversion. Let’s create a controller to provide the user with the following API: result = $dut .atd.convert( 10 ) # Perform a conversion on the voltage at ATD input channel 10 and return the result # The caller can then process the result as they wish, here for example to capture it to the tester result.store! A controller is implemented as follows, this is just a regular Ruby class that includes the Origen::Controller module: # lib/atd_test_block/atd_controller.rb module ATDTestBlock class ATDController include Origen :: Controller end end Naming of controllers can be significant, here Origen will know that this this the controller for the ATD model since we have followed the naming convention: <model name>Controller If you cannot follow this convention (the main reason would be if the model lives in a different namespace), \nthen you can supply the class of the model like this: # lib/atd_test_block/atd_controller.rb module ATDTestBlock class ATDController include Origen :: Controller model class_name : \" SomeOtherNamespace::ATD_M325 \" end end The controller now gives us the place to create our pattern API, here is the covert method \nimplementation: # lib/atd_test_block/atd_controller.rb module ATDTestBlock class ATDController include Origen :: Controller # Convert the input on the given channel to a digital representation. # # An Origen::Register::BitCollection will be returned containing the result. def convert (channel) # Launch the conversion by setting the channel ctrl.adch.write!(channel) # Wait to complete tester.wait( time_in_us : 100 ) # Verify the conversion has completed ctrl.coco.assert!( 1 ) # Return the result (the data bits from the result register) result.d end end end A key point to note from the above is that the controller has direct access to the registers of\nthe model that it controls, that is you can call ctrl instead of having to drill\ndown through the global namespace ( $dut.atd.ctrl ). Instantiating the Controller Shadow controllers are never instantiated directly, instead Origen will automatically materialize\nthem whenever a new instance of the model comes into being. atd = ATDTestBlock :: ATD .new # Instantiates the model, a controller will also be created automatically This is where the name comes from, whenever a model is created it is shadowed by a corresponding\ncontroller. So how do we invoke our controller API? We simply call the methods on the model: atd = ATDTestBlock :: ATD .new\n\natd.convert( 10 ) # => <BitCollection> Origen employs some Ruby trickery such that the object assigned to atd above will\nrespond to the methods available to the model and the controller - models will proxy (send) methods\nthat they don’t recognize to their controller and vice versa. Most of the time then, it doesn’t matter whether the atd object is actually the model\nor the controller, they will respond the same. However if for some reason you really do need to deal directly with one or the other then you can\nuse the following API: atd.model # => <ATD instance> atd.controller # => <ATDController instance> Typical Integration Such a test block would normally be plugged into a top-level application in order to generate\npatterns for a target device. The ATD test block’s integration guide should instruct the top-level test engineer to instantiate the\nATD model within the top-level model like this: # lib/eagle.rb class Eagle include Origen :: TopLevel def initialize (options = {})\n sub_block :atd , class_name : \" ATDTestBlock::ATD \" , base_address : 0x1000_2000 end end The ATD API provided by the ATD test engineer is now available to the Eagle device’s test\nengineers: $dut = Eagle .new $dut .atd.convert( 10 ) # => <BitCollection> Transitioning to an Imported Model If at some point the ATD test engineer gets access to an XML-based or similar definition of\nthe ATD registers from the design team, then the model can be simplified like this: # lib/atd_test_block/atd.rb module ATDTestBlock class ATD include Origen :: Model include CrossOrigen def initialize (options = {})\n cr_import( path : \" #{ Origen .root! } /ipxact_files/atd_regs.xml \" ) end end end See the Cross Origen plugin for more details on\nimporting 3rd party data formats. If on the other hand someone comes along and says, “ok everyone, from now on a full IP-XACT\nrepresentation will be available for every device”, then it would be time to move to\na Direct Controller… Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/documentation/api/": {
    "title": "API Generation",
    "subtitle": "Documentation Generator",
    "body": "Documentation Generator API Generation Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/documentation/deploying/": {
    "title": "Deploying",
    "subtitle": "Documentation Generator",
    "body": "Documentation Generator Deploying Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/documentation/introduction/": {
    "title": "Introduction",
    "subtitle": "Documentation Generator",
    "body": "Documentation Generator Introduction Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/documentation/linking/": {
    "title": "Linking",
    "subtitle": "Documentation Generator",
    "body": "Documentation Generator Linking Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/documentation/markdown/": {
    "title": "Markdown",
    "subtitle": "Documentation Generator",
    "body": "Documentation Generator Markdown Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/documentation/styling/": {
    "title": "Styling",
    "subtitle": "Documentation Generator",
    "body": "Documentation Generator Styling Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/documentation/testing/": {
    "title": "Testing",
    "subtitle": "Documentation Generator",
    "body": "Documentation Generator Testing Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/appcallbacks/": {
    "title": "Application Callbacks",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Application Callbacks The callback pattern can also be used in application code where it can be used\nto provide applications and plugins with a de-coupled way to hook into each\nother’s processes/flows. A call to all listeners for a specific callback method is made like this: Origen .listeners_for( :my_specific_callback_method ).each do |listener|\n listener.my_specific_callback_method( any : :options , you : :want , to : :pass ) end Callback handlers (the my_specific_callback_method in the example above) can be\nimplemented in the application’s (or plugin’s) application.rb or any instantiated\nobject that includes the Origen::Callbacks module (this is automatically\nincluded by Origen::Model ). Note: If adding the callback handler to the config/application.rb file in a\n plugin, it will only be called when it is considered the current\n plugin within its host application.\n See Current Plugin for\n more information on how to set the current plugin. A Practical Example Let’s say in a test engineering scenario that the top-level model has some logic to generate\nsome vectors to sync the DUT to the tester.\nOnce the DUT has been sync’d individual test block owners may want to take some action within\ntheir models to reflect this change of events. Since this top-level model could potentially be used by many test blocks it is not\npractical for the top-level to maintain a list of them and call them individually.\nInstead it is better to use a callback pattern where the top-level broadcasts that\nan event has just taken place and then anyone who cares can listen for the broadcast\nand anyone who doesn’t care need take no action. To implement such a system the top-level object can do this: class MySoC include Origen :: TopLevel # Sync the DUT to the tester def sync_up # Logic to sync up the DUT goes here # Now let everyone know that the DUT is now sync'd Origen .listeners_for( :on_sync_up ).each do |listener|\n listener.on_sync_up end end end Then in the test block code the test engineer who wants to do something on sync up\ncan simply implement the necessary callback handler: class MyTestBlockModel include Origen :: Model def on_sync_up # Action to take when the DUT has been sync'd end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/callbacks/": {
    "title": "Callbacks",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Callbacks Callbacks provide a way for an application to hook into the Origen process\nand have the opportunity to modify the standard behavior in some way. This could also be accomplished by redefining any of Origen’s code at application-level\nbut that approach\nis not recommended since it leaves the application at risk of breaking if Origen ever\nmakes changes to how things work internally. Callbacks on the other hand are an official API that will always work between releases. Note that it is very easy to add additional callbacks to Origen, so if you can see the need\nfor one that is not already covered please contact us via the community channels to discuss. Registering Listeners Callbacks work by registering listeners with Origen. As the Origen process executes\nit will come across various points where callbacks have been enabled and which will cause\nOrigen to pause and ask all of the listeners if they have any code that they wish to execute.\nIf so control will transfer to the listener who will execute something and who may or may not return\ncontrol back to the Origen process when complete. In other words Origen will call-back to the application at various points during the process. A listener can be any object instance within your application and by default the application\nitself (as defined in config/application.rb ) and any classes which include Origen::TopLevel or Origen::Model are already registered as listeners. Additional custom classes can be registered by simply including the callbacks module: module NVM class CallbackHandlers include Origen :: Callbacks end end Note that listeners have to be object instances, so in the example above the listener is only\nregistered when the application creates a new instance of CallbackHandlers .\nIf an instance is never created then the callbacks implemented in that class will never be\ncalled. Persistent Listeners By default the pool of listeners is cleared out before a target load and they will be replaced\nby whatever objects are instantiated by the new target.\nIn most cases this is the desired behavior and everything in the application will behave\nas you would expect. However in some cases it may be desired to setup callback listeners that will persist across\ntarget loads so that they keep listening for the entire duration of an Origen thread.\nThis can be achieved by including the PersistentCallbacks module instead: module NVM class PersistentCallbackHandlers include Origen :: PersistentCallbacks end # Instantiate an instance of this class immediately when this file is loaded, this object will # then listen for the remainder of the Origen thread PersistentCallbackHandlers .new end A common use case is to use a persistent callback listener that implements on_load_target to\nimplement common target behavior - i.e. implement logic that should run for every target.\nMost crucially plugins can take full advantage of this to augment all of the targets of their\nhost application. Implementing a Callback Implementing a callback is simply a matter of implementing an agreed method name within a\nlistener. So at each callback point the Origen code is basically: listeners.each do |listener| if listener.respond_to?(callback_x)\n listener.callback_x(arg_x, arg_y) end end So any listeners which don’t implement a specific callback are simply ignored. To enable the above callback our custom listener would be changed to: module NVM class CallbackHandlers include Origen :: Callbacks def callback_x (arg_x, arg_y) if arg_x == :ft_pattern puts \" Final test not supported yet! \" exit 0 end # Otherwise return to Origen end end end As mentioned the application is already registered as a listener, so the above callback_x method could be added to config/application.rb and it would be called at the appropriate\ntime. Calling Order If an application has mutliple listeners for the same callback then they will all get called,\nhowever the order that they are called in is undefined unless otherwise specified in the\ndocumentation for a particular callback (e.g. startup and shutdown callbacks). Generally if calling order is important the recommended approach is for the application to\nimplement a single callback and then from there co-ordinate calling any additional application\nmethods that need to be run. Available Callbacks There now follows a listing of all available callbacks, these have been split up by function: Environment Setup Generation Reset Pattern Generation Web Compiler Release Process Environment Setup before_load_target This callback is triggered immediately before the target is loaded. The intended use case is to allow any domain specific clean up that needs to be done when reloading\nor changing the target during an Origen thread of execution.\nOrigen will take care of ensuring that the top-level model, the tester and all callback listeners are\nsafely removed and/or re-instantiated between target loads, and in the vast majority of cases the\napplication should never need to use this. on_create This callback is triggered immediately after the target is loaded. The intended use case is to allow the application to complete any target object initialization that may\nbe dependent on other target objects. \nIn other words you can think of this like a regular initialize method but one where\nall objects instaniated by the target are guaranteed to be available. No return value is expected. include Origen :: Callbacks def initialize # Would be creating a target instantiation order dependency by doing this here # tester.do_something end def on_create # But not here tester.do_something end on_load_target This is basically an alias of on_create and it behaves in exactly the same way. Conceptually though it reflects a different way of using this callback: on_create can be thought of\nas an enhanced version of initialize at a model level, whereas on_load_target can be thought of as\na way to augment all targets with common behavior. See the section on Persistent Listeners above for some more discussion on this. on_top_level_instantiated(top_level_object) This callback is triggered immediately after a top-level object (an object that includes the Origen::TopLevel module, normally an object representing the top-level of the SoC)\nis instantiated. No return value is expected. include Origen :: Callbacks # Automatically instantiate a RAM model whenever a DUT model is instantiated, the size will # be determined by the ram_size attribute of the DUT def on_top_level_instantiated (dut) $ram = MyPlugin :: RAM .new size : dut.ram_size end interactive_startup This will be called immediately before giving control to the user when opening an interactive\nconsole session (by running origen i ).\nThe target will already be loaded prior to calling. The intended use case is to give the application a chance to perform a device setup sequence in the\ncase where the environment is connected to an Origen Link compatible tester driver. # This is called automatically at the start of an interactive session (origen i) def interactive_startup # Run the regular pattern startup method upon opening the console to put the device in test mode startup if tester.link? end interactive_shutdown This will be called immediately before shutting down an interactive console session. The intended use case is to shutdown the device in the case where the environment is connected\nto an Origen Link compatible tester driver. # This is called automatically at the end of an interactive session (origen i) def interactive_shutdown # Run the regular pattern shutdown method to put the device in reset shutdown if tester.link? end Generation before_lsf_submission This callback is triggered immediately before submitting a batch of jobs to the LSF. No return value is expected. before_generate(options) This callback is triggered immediately before launching a generate operation, that is before\nstarting the current batch of program generation, pattern generation or compile jobs. No return value is expected. before_generate_local(options) As above but only called when running locally. before_generate_remote(options) As above but only called when running on a remote LSF machine. Reset The reset callbacks will kick in when the reset or reset! method\nis called on the top-level object. They will be executed in the following order: before_top_level_reset shutdown (reset! only) on_top_level_reset! (reset! only) on_top_level_reset registers are reset here startup (reset! only) after_top_level_reset Generally with all reset callbacks the application code is not expected to take care of\nreseting registers or any other Origen-owned objects.\nOnly state specifically setup by the application code should need to be teared down and\nre-established. before_top_level_reset Called as soon as the reset or reset! method is called on the\ntop-level object and before any other reset activity takes place. This callback should not be used to generate reset vectors, use the shutdown callback for that. No return value is expected. def before_top_level_reset @some_state_attribute = nil end on_top_level_reset Called when the reset or reset! method has been called on the\ntop-level object and after the top-level has been shutdown. No return value is expected. def on_top_level_reset @some_state_attribute = nil end on_top_level_reset! Called only when the reset! method has been called on the top-level object,\notherwise the same as reset . after_top_level_reset Called at the very end of a reset sequence initiated by calling reset or reset! on the\ntop-level object at which point the top-level has already been re-started. This callback should not be used to generate reset vectors, use the startup callback for that. No return value is expected. def after_top_level_reset @some_state_attribute = nil end Pattern Generation startup(options) Called at the start of a Pattern.create block, this callback provides an opportunity to\nimplement startup vectors. It will also be called as part of a within-pattern reset sequence initiated by calling reset! on the top-level object. Any options supplied to Pattern.create are passed in as an argument. The top-level (DUT) object is guaranteed to be called first for this callback, this enables\nthe common case where the top-level will generate the mode entry vectors from\nthis callback and then child modules can generate any additional vectors safe in the knowledge\nthat mode has already been entered. No return value is expected. def startup (options)\n tester.set_timeset( \" nvmbist \" , 40 )\n dut.pin( :reset ).drive!( 1 ) end shutdown(options) Called at the very end of a Pattern.create block, this callback provides an opportunity to\nimplement reset vectors. It will also be called as part of a within-pattern reset sequence initiated by calling reset! on the top-level object. Any options supplied to Pattern.create are passed in as an argument. The top-level (DUT) object is guaranteed to be called last for this callback, this enables\nthe common case where the child modules can insert any shutdown/safe-state vectors before\nthe top-level finally pulls reset. No return value is expected. def shutdown (options)\n dut.pin( :reset ).drive!( 0 ) end before_pattern(pattern_name) This callback is triggered immediately before running a Pattern.create block. At this point the target is fully loaded but the pattern is not yet opened - so you can’t\ngenerate vectors from here. The intended use case for this callback is to establish state within your models based on the\npattern name. This can be used in conjunction with a pattern name translator to generate\nvariants of your existing patterns without having to create a new pattern source. No return value is expected. # If the requested pattern has 'trimmed' in the name then look for the equivalent # source file without 'trimmed' in the name. # The output pattern will still contain 'trimmed' in the name. config.pattern_name_translator do |name| if name =~ / trimmed / { source : name.gsub( \" trimmed_ \" , \" \" ), output : name} else name end end # Setup the dut model differently if generating a pattern for a trimmed device def before_pattern (pattern_name) if name =~ / trimmed / dut.apply_default_trims = false end end before_pattern_lookup(requested_pattern) This callback is triggered before Origen searches for the requested pattern source. The intended use case is to give the application a chance to dispatch the pattern itself,\nor to decide to withhold it based on some properties of the current target. If the callback returns a value of false or nil then Origen will abort further processing\nof this pattern and move onto the next one.\nOrigen will proceed to dispatch the pattern as normal\nif any other value is returned. def before_pattern_lookup (requested_pattern) if requested_pattern =~ / blk_1 / # Only proceed with this pattern if the current target has a blk 1 dut.has_blk1? else # Proceed as normal requested_pattern end end pattern_generated(path_to_generated_pattern) This callback is triggered at the end of every pattern that is generated, the path to\nthe generated file (wrapped in a Pathname) is passed to the listener. The intended use case is to give plugins a hook to kick off additional operations at the\nend of a pattern being generated, such as to go and simulate it or to compile it to a\nbinary. Normally this callback would be implemented in a persistent listener within a plugin\nto have the plugin called after every pattern that is generated. No return value is expected. module VirtualTester class PersistentCallbackHandlers include Origen :: PersistentCallbacks def pattern_generated (path_to_generated_pattern) if $vt_simulation_enabled # Set this back when the command was launched or however you want to enable VirtualTester :: Runner .new(path_to_generated_pattern) end end end # Instantiate an instance of this class immediately when this file is required, this object will # then listen for the remainder of the Origen thread PersistentCallbackHandlers .new end Web Compiler before_web_compile(options) This is called immediately prior to running the requested origen web compile operation\nand it provides the application with an opportunity to dynamically generate some templates\nfor the compiler to execute. The command line arguments are decoded and available in the given options hash. No return value is expected. after_web_compile(options) This is called immediately after running the requested origen web compile operation\nand provides the application with an opportunity to add anything else to the web/output\ndirectory. The command line arguments are decoded and available in the given options hash. No return value is expected. after_web_site_compile(options) Similar to after_web_compile , except that this one will only be called when\na request has been made to compile the entire web site, i.e. when origen web compile has been called without a file argument(s). The command line arguments are decoded and available in the given options hash. No return value is expected. Release Process validate_release This is called immediately prior to the release (origen rc tag) process and gives the application\na chance to do any final checks to authorize that the release can go ahead. No return value is expected but the callback handler is expected to exit the process if\nit decides that the release should be aborted. Typically this hook would be used to launch the application’s test suite and if it fails\nabort the process, here is an example: # Ensure that all tests pass before allowing a release to continue def validate_release if !system( \" origen specs \" ) || !system( \" origen examples \" )\n puts \" Sorry but you can't release with failing tests, please fix them and try again. \" exit 1 else puts \" All tests passing, proceeding with release process! \" end end before_release_tag(identifier, note, type, selector, options) This callback is triggered immediately before the application is tagged, all release properties\nare available in the arguments. No return value is expected. after_release_tag(identifier, note, type, selector, options) This callback is triggered immediately after the application has been tagged and before the\nrelease email has been sent. If the callback doesn’t return then the release email will not be sent. No return value is expected. after_release_email(identifier, note, type, selector, options) Called at the very end of the release process. This callback is commonly used to kick off any doc builds or other post release tasks within\nthe application. No return value is expected. # Example of automatically deploying documents after a tag def after_release_email (tag, note, type, selector, options)\n command = \" origen web compile --remote --api \" Dir .chdir Origen .root do system command end end before_deploy_site Called immediately before a web site is deployed. This gives the application a chance to add any additional files to the web site\nbefore it is deployed. No return value is expected. # Generate a test coverage report and add it to the web site def before_deploy_site Dir .chdir Origen .root do system \" origen specs -c \" system \" mv #{ Origen .root } /coverage #{ Origen .root } /web/output/coverage \" end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/commands/": {
    "title": "Adding Commands",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Adding Commands Applications can add their own custom commands to the Origen namespace which makes\nit very easy to distribute and document custom scripts that support the application environment.\nOf course like everything else these scripts will have full access to the device models\nby default. Commands should be added to the file config/commands.rb in the first instance\nand as they grow you can extract the larger commands out to their own files. A skeleton config/commands.rb file should already exist in your application and\nwhen an origen command is launched via the command line Origen gives the application\ncommand file the first shot at fulfilling it.\nSo in fact it is also possible to override the built-in commands if you ever have a need to do so. An empty command file has this structure: aliases ={\n} # The requested command is passed in here as @command, this checks it against # the above alias table and should not be removed. @command = aliases[ @command ] || @command # Now branch to the specific task code case @command else @application_commands = <<-END END end When the command is launched the first argument, the command name, will be available in the instance\nvariable @command .\nYour code should interrogate this variable to decide whether the command request is one that should be\nhandled by your application, or else left for Origen to dispatch (in the skeleton commands file all\nrequests are simply passed through to Origen by default). Let’s say for example that we want to implement a command that will print the current time, we could\naccomplish this like so: aliases ={ \" time \" => \" current_time \" } # The requested command is passed in here as @command, this checks it against # the above alias table and should not be removed. @command = aliases[ @command ] || @command # Now branch to the specific task code case @command when \" current_time \" puts Time .now\n exit 0 else @application_commands = <<-END current_time Print the current time (aliased as \"time\") END end The following points are worth noting from this example: We implemented an alias of “time” for the “current_time” command. This means that it\ncan be launched either via origen current_time or the more succinct origen time . The\nuse of aliases is completely at your discretion and they are not required. The command code should always complete with exit 0 . This is to end the current command\nrequest since otherwise the request will then fall through to Origen which will attempt to process it. You can document your commands via the @application_commands variable, this should\nbe a simple one liner that describes what your command does. This information will be available to the\nuser when they run origen -h . More detailed documentation for your command can be added\nby adding support for command options (see below). Loading the Application Such commands will execute very quickly since they don’t bother to load any of your\napplication environment, but what if you need to access your models? The application will load automatically anytime you reference Origen.app , this\nwill load your config/boot.rb file and all of your models and other logic\nwill then become available.\nOne other useful side effect of this for\nscripting purposes is that it will make the root directory of your application available\nvia Origen.root . For example: MyClass .do_something # => I want to access my code here but this is giving an error Origen .app # Make a reference to the application, this will load it if is not already loaded MyClass .do_something # => Now it works Loading the Target See the dedicated section on Programming the Runtime Environment . Handling Command Options Most scripts will benefit from giving the user some options to configure the behavior and this is easy to add.\nAny command arguments or options passed in by the user will be available via the ARGV array. Note! -d is a reserved option which you cannot use, Origen uses this to enable the debugger and will strip it\nout of ARGV before handing it over to your command code. You can actually query this variable manually to decide what to do, but it is recommended that you use\nthe Ruby OptionParser library\nwhich makes it very easy to both parse user options and to document them. Let’s say that we wanted to give the user the ability to specify what format the time should be presented\nin by using the strftime method. This could\nbe accomplished like this: aliases ={ \" time \" => \" current_time \" } # The requested command is passed in here as @command, this checks it against # the above alias table and should not be removed. @command = aliases[ @command ] || @command # Now branch to the specific task code case @command when \" current_time \" options = {}\n opt_parser = OptionParser .new do |opts|\n opts.banner = <<-END_DESC origen time - This command will print the current time using the default Time\n format, alternatively specify your own format via the -f option. END_DESC opts.on( \" -f \" , \" --format FORMAT \" , String , \" FORMAT should use strftime notation \" ) { |t| options[ :format ] = t }\n opts.separator \" \" opts.on( \" -h \" , \" --help \" , \" Show this message \" ) { puts opts; exit } end opt_parser.parse! ARGV if options[ :format ]\n puts Time .now.strftime(options[ :format ]) else puts Time .now end exit 0 else @application_commands = <<-END current_time Print the current time (aliased as \"time\") END end Note the following in the above example: We initially declare an empty hash called options which we will then populate based on the\nuser input. opts.banner can be used to specify a detailed description of how the command works. This is\nused in conjunction with the -h option which we have handled at the bottom. This should be\nincluded in all of your commands to provided a consistent user interface, the user can now\nrun origen time -h to display the command description and a summary of all \navailable options. The -h implementation is an example of how to handle Boolean options. The -f option itself is implemented as an option that accepts a String parameter, which we\ncollect and place in the options hash to make it easily available to downstream code. This allows\nthe user to run origen time -f \"%Y\" for example which will display the current year only. Moving To a New File As your application becomes more complex you will find that you want to organize your commands better instead\nof having them all dumped into a single file. In this case we could extract the command code above into the application library, lib/commands/current_time.rb , \nfor example, and then include it like this: aliases ={ \" time \" => \" current_time \" } # The requested command is passed in here as @command, this checks it against # the above alias table and should not be removed. @command = aliases[ @command ] || @command # Now branch to the specific task code case @command when \" current_time \" require \" commands/current_time \" exit 0 else @application_commands = <<-END current_time Print the current time (aliased as \"time\") END end More Examples This is obviously a very trivial example and real commands can grow to be infinitely complex.\nFor some real world examples you can look at the implementation of the built in Origen commands which have been implemented using the\nsame techniques described above. Also be sure to check out the OptionParser documentation\nwhich contains further examples and documentation on option parsing. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/commandsov/": {
    "title": "Overriding Commands",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Overriding Commands Occasionally you might come across the need to extend Origen’s built in commands\nwith application specific functionality. In extreme cases the entire command can be overridden entirely by using the\nprocedure described in Adding Commands .\nHowever in most scenarios the desire will be to add additional command switches\nto implement the custom behavior. This can be achieved by overriding the command as normal and then setting a flag\n(usually an application attribute or global variable) that your downstream application code can then act on,\nbefore handing control back to Origen to complete the command processing as normal. To document the new option you can pass the details to Origen via the @application_options variable and the new option will appear in the help\nas if it was a built-in part of the command. Example In one application we added an MD5 checksum to the names of all generated patterns\nbut sometimes we needed the ability to revert back to the original names. Such an option could be implemented by using different targets but for something\nso trivial it is not worth the overhead of requiring duplicate versions of all targets\nthat need this functionality. A more efficient implementation is therefore to add a runtime option: # config/application.rb # Add an attribute to disable md5 pattern names attr_accessor :no_md5 # config/commands.rb # Add an additional option to the standard command, important not # to exit here to allow the standard Origen command to run afterwards when \" generate \" # Option definitions must be pushed into the @application_options array, don't re-assign it! @application_options << [ \" --no_md5 \" , \" Don't apply the MD5 checksum to pattern names \" ], # Note that it is important not to delete the argument from ARGV, this is necessary to make Origen # fully aware of it, so that it can be passed on to any additional jobs invoked from this process Origen .app.no_md5 = true if ARGV .include?( \" --no_md5 \" ) # Don't exit here, allow the flow to fall through to Origen to implement the rest of the command In our application code we then implement something to the effect of: def pattern_name if Origen .app.no_md5 # code to generate original name else # code to generate with MD5 end end Now when we run origen g -h we see our new option alongside the standard options: Usage: origen g [space separated patterns or lists] [options]\n -t, --target NAME Override the default target, NAME can be ...\n -l, --lsf [ACTION] Submit jobs to the LSF, optionally specify ...\n -c, --continue Continue on error (to the next pattern)\n -f, --file FILE Override the default log file\n -o, --output DIR Override the default output directory\n -r, --reference DIR Override the default reference directory\n -d, --debugger Enable the debugger\n --no_md5 Don't apply the MD5 checksum to pattern names\n\n -h, --help Show this message Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/coreext/": {
    "title": "Ruby Extensions",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Ruby Extensions Ruby allows for any object, including all of its core classes, to be extended with new or modified\nfunctionality and such modifications are typically known as core extensions. Origen adds a number of methods to Ruby to make it more useful for use in Origen applications and more generally\nwithin the semiconductor domain. For a complete list of the available extensions go to\nthe Origen API , click on Class List in the top-right, and then all of the\nclasses listed under the Top Level Namespace contain extension. For example see\nthe extensions added to the String class. Here now is a summary of some of the most useful helpers that are available: Unit Helpers When engineering semiconductor devices we often have to deal with very large or very small numbers, Ruby’s\nnumeric classes have been extended to support most common units and to make writing spec\nlimits more descriptive, here are some examples: 50 # => 50 50 .V # => 50 50 .mV # => 50E-03 50 .uA # => 50E-06 50 .nS # => 50E-09 50 .pA # => 50E-12 50 .kHz # => 50,000 50 .MHz # => 50,000,000 50 .GHz # => 50,000,000,000 Number Formatting Helpers Displaying numbers in hex or binary format is very common, some helpers exist for that: 100 .to_hex # => \"0x64\" 100 .to_bin # => \"0b1100100\" 100 .to_hex.to_dec # => 100 100 .to_bin.to_dec # => 100 Part Select Ruby does not natively support a Verilog style part select to allow the numeric value of a subset\nof bits to be extracted.\nUnfortunately the Ruby parser will\nnever consider 0x1234[7:0] to be valid due to Ruby’s use of a colon to pre-fix\nsymbol names.\nHowever with a little compromise we can get very close: number = 0x1234 number[ 3 .. 0 ] # => 0x4 number[ 7 .. 0 ] # => 0x34 number[ 15 .. 8 ] # => 0x12 Try Method All objects within Origen have a try method to allow application developers to preferentially\nselect the source of a given attribute. The first value provided by the first option to return a value\nwill be returned, if none return a value then nil will be returned: # Take the value assigned to db_version if present, if not fall back to version $dut .try( :db_version , :version ) # => 5 $dut .try( :missing_method_x , :missing_method_y ) # => nil Hash Hashes can be transformed to a version which will accept either string or symbol key references: # A standard hash my_hash = { :one => 1 , \" two \" => 2 }\nmy_hash[ :one ] # => 1 my_hash[ \" one \" ] # => nil my_hash[ :two ] # => nil my_hash[ \" two \" ] # => 2 # A hash with indifferent access my_hash = my_hash.with_indifferent_access\nmy_hash[ :one ] # => 1 my_hash[ \" one \" ] # => 1 my_hash[ :two ] # => 2 my_hash[ \" two \" ] # => 2 Over time Origen will transition to returning this kind of hash to application-facing methods by\ndefault, but for now you can easily apply the transform on the application side if you want to use\nthis feature. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/lint/": {
    "title": "Lint Testing",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Lint Testing What is ‘Lint and Style Testing’? Lint testing refers to looking for suspicious or unusual coding patterns which could be an\nindication of buggy or hard to maintain code. Style checking refers to ensuring that the general coding style, for example the use of indentation,\nis consistent and follows generally accepted conventions. Since Origen applications are typically developed and maintained by multiple engineers it is\nimportant to establish common coding practices so that code can be easily read and reasoned\nabout by anyone involved in the project. The Origen lint test uses a 3rd party tool to enforce\nthe Ruby community maintained style guide .\nBest of all this tool can automatically correct many of the common style violations, including\nthe (very common) inconsistent use of indentation. By taking this approach individual preferences are taken out of the equation and adherence\nto the standards are no longer reliant on individuals remembering to use spaces instead\nof tabs (for example). How to Run the Tests Invoke the lint tests via the following command, by default this will run on the application’s lib directory: origen lint To run on individual files, or other directories: origen lint pattern config/application.rb To automatically correct violations where possible: origen lint -c Waivers for Legacy Applications By default the tests will be fairly strict and will enforce most of the requirements of\nthe Ruby style guide . However many of the checks will involve some manual modification of the code to resolve them\nand for legacy applications with large code bases this is probably not worth the effort.\nIn that case an easier set of tests can be run instead: origen lint -e The easier set will mainly limit the tests to those which can be corrected automatically,\nwhich still covers the most annoying issues such as inconsistent indentation and general\ncode formatting problems. However all new applications should use the strict tests and Origen core has already been\nmade clean to the strict checks. Setting Application Defaults An application configuration option can be added to specify the default\noptions that should be applied when the origen lint command is run without\nany arguments. Here is the default value that will be present in all new Origen applications: # config/application.rb config.lint_test = { # Require the lint tests to pass before allowing a release to proceed run_on_tag : true , # Auto correct violations where possible whenever 'origen lint' is run auto_correct : true , # Limit the testing for large legacy applications #level: :easy, # Run on these directories/files by default #files: [\"lib\", \"config/application.rb\"], } Pre-Release Validation The lint test will be run automatically when a user tries to tag/release the application\nwhenever the Origen.config.lint_test[:run_on_tag] attribute is set to true as shown above. In such a case the user will not be allowed to release until the issues are resolved and\nthis should be the approach taken by all new applications. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/logger/": {
    "title": "Logger",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Logger Every Origen thread will log output data to the console and to the files in the log directory. Currently, Origen implements 5 types of logging messages and they can be called globally as shown below: # INFO messages will always appear Origen .log.info \" This is an INFO message. \" # WARNING messages will always appear Origen .log.warn \" This is a WARNING message. \" # ERROR messages will always appear Origen .log.error \" This is an ERROR message. \" # DEPRECATE messages will always appear Origen .log.deprecate \" This is a DEPRECATE message. \" # DEBUG messages will only appear when logging verbosity level is set to 'VERBOSE' Origen .log.debug \" This is a DEBUG message. \" Logging Verbosity Levels There are in total three verbosity levels, they are ‘VERBOSE’, ‘QUIET’ and ‘SILENT’. These levels\nonly affect the output which appear on the console window, the log file will always capture everything\nregardless of the verbosity level. You can set logging verbosity level to ‘VERBOSE’ by adding ‘-verbose’ to your Origen command line: origen compile templates/web/index.html.erb -verbose When in verbose mode, Origen will output and store all 5 types of log messages to \nshell windows and log files. To set verbosity level to ‘QUIET’, you simply just need to run Origen commands without the ‘-verbose’ option: origen compile templates/web/index.html.erb When in quiet mode, Origen will NOT log any ‘DEBUG’ messages in the code either to shell window. To set verbosity level to ‘SILENT’ run Origen commands with the ‘-silent’ option: origen compile templates/web/index.html.erb -silent When in silent mode, Origen will NOT output anything to the linux console window and will save\neverything to the log file only. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/lsf/": {
    "title": "LSF API",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous LSF API The LSF is an industry standard platform that allows compute jobs, like running Origen, to be run in parallel across a pool\nof computers. As you may know, Origen makes it easy to utilize the LSF to speed up generate or compile jobs\nby simply appending -l (and optionally -w to make it automatically\npoll and wait for completion) to the command. However Origen’s internal LSF API is also available to application developers if they wish\nto leverage the LSF in their application specific functionality.\nIn fact this can even be used to wrap and manage non-Origen jobs (where the command to run\nthe job is not ‘origen …’). Preparing to Run Code Remotely Before submitting a new piece of code for remote execution give some thought as to whether\nit will cause any race conditions or competition for resources between jobs as they\nrun in parallel. When jobs are run remotely they will be executing within the same workspace from which they have been\nlaunched locally. Therefore generally have a think about whether there would be any problems if\nyou were to open up two terminals pointing to the same workspace and then run two instances\nof the same operation in parallel - this is the same as what happens when you submit to the LSF. A good example would be if your job involved importing some data to the workspace from a 3rd\nparty area. In such a case it is better to import it once before launching the jobs rather\nthan have 10 processes running in parallel all trying to import (and write to the same files)\nat the same time. To detect if code is running remotely or not you can use Origen.running_remotely? : if Origen .running_remotely? # Branch to handle something differently to account for parallel execution else # Conventional execution where the code is executing single-threaded locally end Main API Here is a summary of the main API methods, see the LSFManager API for full details. All jobs submitted to the LSF through Origen will be monitored, to abandon monitoring of\nexisting jobs the queue can be cleared like this: # Clear the LSF monitor queue Origen .lsf.clear_all Jobs are submitted like this: # Submit any Origen commands to the queue like this, you should always supply a target Origen .lsf.submit_origen_job \" generate bistcom -t p2_debug \" Origen .lsf.submit_origen_job \" compile templates/j750 -t p3_debug \" # Any application-specific Origen commands will work in the same way Origen .lsf.submit_origen_job \" my_custom_command -t p2_debug \" # Any non-origen commands can also be submitted and monitored using the more generic submit_job # method. The job will be considered passed/failed based on standard unix result codes Origen .lsf.submit_job \" cd path/to/some/dir && do_something \" If a call to submit_origen_job will invoke the same command to that from which the\nsubmission is being made then Origen will automatically forward any command options that were\npassed to the parent process. This also applies to custom commands. The jobs can then be monitored from the command line with the origen l command: > origen l\n\nLSF Status\n----------\nQueuing: 2\nRunning: 5\nLost: 0\n\nPassed: 0\nFailed: 0\n\nCommon tasks\n------------\n\nReset the LSF manager (clear all jobs): origen lsf -c -t all Origen will automatically re-launch any lost jobs and the common tasks section will tell\nyou what command to run if you want to re-launch any failed jobs. You can also wait for job completion within the Ruby/Origen thread from which they were\nlaunched: # Wait for jobs to complete, this will automatically re-try lost jobs and optionally can # retry any failed jobs (should never really be required though, any failures due to the # remote host going down or similar will automatically re-try silently). Origen .lsf.wait_for_completion # By default lost jobs will retry up to 10 times Origen .lsf.wait_for_completion( max_fail_retries : 1 ) # Retry all failures once Advanced Scheduling Sometimes a given job may not be able to run until another one has completed first, the\nAPI allows for such dependencies to be managed using job IDs. First capture the job ID of the parent job(s) when it is launched: # Each submission will return a job id which you can capture id = Origen .lsf.submit_origen_job \" generate global_subs -t p2_debug \" You can deal with the dependency resolution at Origen level by waiting for the\nindividual jobs to complete: # Wait for the parent job(s) to complete Origen .lsf.wait_for_completion id : id Origen .lsf.wait_for_completion ids : [id1, id2] # Now launch the dependent jobs The LSF itself has a mechanism for resolving such dependencies and that functionality\nis exposed via a :depends option when submitting jobs: # Dependencies can also be resolved automatically by supplying a depends argument when # submitting, for example the 3rd job here will only run once the first two have completed id1 = Origen .lsf.submit_origen_job \" g overlay_subs -t p2_debug \" id2 = Origen .lsf.submit_origen_job \" g global_subs -t p2_debug \" Origen .lsf.submit_origen_job \" g master_subs -t p2_debug \" , depends : [id1, id2] Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/remotes/": {
    "title": "Origen Remotes",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Origen Remotes Unfortunately this API currently only supports remote DesignSync repositories, however it\n will soon be updated to use the abstract revision control API under the hood. At that point it will work with remote data stored in any revision control\n system supported by Origen. What is a ‘Remote’? In some cases, your application may require access to external data that is \nkept under revision control but not necessarily as part of the Origen environment.\nFor example, you may need access to a design file that is stored with the IP and rather than store\na static copy in the application vault, you want to easy populate a local version based on a \nspecified tag. Then what you need is an Origen Remote. How to Populate a Remote Populating a remote is extremely easy, all that has to be done is to define\nthe required remote within the config/application.rb file. Three details are required: The sub-directory within the Origen remotes workspace where you want the population to occur The path to the vault containing the plugin application The version of it that you want to use Once in possession of these details add them to the config.remotes attribute. \nThis accepts an array and any number of remotes can be added, here is an example\nthat populates two remotes: config.remotes = [\n { dir : \" source/include/v_ip_ate \" , vault : \" sync://sync-15000:15000/v_ip_ate_c90lp/compiler/include \" , version : \" v0.0.0.dev1 \" ,\n },\n { dir : \" source/include/v_ip_capi \" , vault : \" sync://sync-15100:15100/v_ip_capi/compiler/include \" , version : \" v1.0.0 \" ,\n }\n] Location Population of the remotes will occur within the remotes workspace located at the top-level \nof the receiving application. For instance, in the above example, the v_ip_ate remote would be\nlocated at: .<top>_remotes_DO_NOT_HAND_MODIFY/source/include/v_ip_ate Please note that the value of :dir must be unique within the application. Origen Does the Rest With those details added Origen will then take care of ensuring that the dependencies\nare fulfilled every time that the application is invoked. Setting up a Remote Development Environment If you are still developing some parts of your remote, your environment setup may need to be slightly\ndifferent vs. working on a known good remote. You can configure the receiving application to use\na development workspace like this: config.remotes = [\n { dir : \" source/include/v_ip_ate \" , vault : \" sync://sync-15000:15000/v_ip_ate_c90lp/compiler/include \" , version : \" v0.0.0.dev2 \" , path : \" /proj/thao/build.22/common_vip/v_ip_ate \" ,\n }\n] When a path reference is present Origen will override the vault/version reference and\nwill setup up a symbolic link from the regular\nremote location to your development workspace - this means that the receiving application\nis now always looking at your latest development code. Origen will not allow the receiving application to be tagged when a path reference is active,\nso you don’t need to worry too much about forgetting to remove it! Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/revisioncontrol/": {
    "title": "Revision Control",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Revision Control Introduction While Git is fast becoming the de-facto standard revision control tool in many software domains,\nit is likely that some Origen application developers may still want to use something else.\nOrigen provides a revision control system abstraction to help Origen users switch between apps\nthat use different systems, and to help Origen and its plugins work within different revision\ncontrol environments. Currently the following systems are supported by the abstract API: Git Enovia Synchronicity Design Sync If you would like to see another system supported and you are willing\nto help us develop and pilot the driver for it, then please get in touch via\nthe community channels . Programmable API The programmable API exposes a common set of methods to the application developer that will work\nregardless of the underlying system that is being used. An revision control driver is created by instantiating a new revision controller instance, this\nrequires a reference to the remote repository, and the path to the local root directory (which\ndoesn’t have to exist yet): rc = Origen :: RevisionControl .new remote : \" ssh://git@github.com:myaccount/myproj.git \" , local : \" my/path \" rc.git? # => true rc = Origen :: RevisionControl .new remote : \" sync://sync-15000:15000/myaccount/myproj \" , local : \" my/path \" rc.dssc? # => true In the case of an Origen application, a short cut is available (assuming the application has\nset config.rc_url in config/application.rb ): rc = Origen .app.rc\nrc.git? # => true This revision controller object provides the Revision Control API described here . Here are some examples: rc.local_modifications # => [\"lib/my_app/model1.rb\", \"lib/my_app/model2.rb\", \"lib/my_app/model3.rb\", \"lib/my_app/model4.rb\"] # Check in a single file rc.checkin \" lib/my_app/model2.rb \" rc.local_modifications # => [\"lib/my_app/model1.rb\", \"lib/my_app/model3.rb\", \"lib/my_app/model4.rb\"] # Checkout latest version of a single file, forcing overwrite of local mods rc.checkout \" lib/my_app/model4.rb \" , force : true rc.local_modifications # => [\"lib/my_app/model1.rb\", \"lib/my_app/model3.rb\"] # Check in everything rc.checkin comment : \" Added a cool feature \" rc.local_modifications # => [] Revision Control Command The origen rc command uses this API to provide a universal command line\ninterface for working with revision control systems, thereby providing the following benefits to the user: Intimate knowledge of how the underlying revision control system works is not required,\nthe command maintainers will ensure that you are using it in an efficient and correct way. The workflow remains the same regardless of what underlying revision control tool is used. Here are some examples: origen rc co # Checkout the latest version of the application, local edits will be merged\norigen rc co -v v1.2.3 # As above but a specific version\norigen rc co -f # As above but force overwrite of local edits\norigen rc co file.txt # As above but on a specific file or directory, -v and -f will work to\n\norigen rc ci # Check in the application\norigen rc ci --unman # As above but also include files that are currently unmanaged\norigen rc ci file.txt # Check in a specific file\norigen rc new file.txt # Create the given file and check in an initial version of it\n\norigen rc unman # Show unmanaged files\norigen rc mods # Show modified files in local workspace\norigen rc tag # Tag and release the application See origen rc -h for an up to date list of supported commands. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/session/": {
    "title": "Session Store",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Session Store The session store can be used to persist information (or state) across Origen threads\nof execution within a given workspace. Setting the current target with origen t is a example\nof session information being used to setup some state that will persist into\nfuture Origen commands that are executed within that workspace, while having no bearing on what happens\nin other workspaces. To access the session store: Origen .app.session The session is split into named stores which will be automatically created as soon as data\nis added to them,\nthis gives application developers a namespace level to keep their data organized. The namespace returns a key-value store containing all of the values in that namespace: Origen .app.session.main # => A key-value store Origen .app.session.blah # => A different key-value store Plugin developers should use a store named after their plugin, for example the ATDTest plugin would use: Origen .app.session.atd_test # => A key-value store for use by the ATDTest plugin To store values to the session simply set them like this: Origen .app.session.main[ :exec_count ] = 10 Unlike assigning values to a regular Hash variable, this value will survive between Origen\nthreads - go on fire up an origen i session and try it out: Origen .app.session.main[ :exec_count ] # => 10 Generally you can store hashes, arrays and even objects to the session although your\nmileage-may-vary with particularly rich objects. Note that in the case of storing objects the class\ndefinition must still be around when Origen tries to resurrect it from the session. i.e. you\ncannot store an object, delete the class definition for that object, and then materialize it\nfrom the session later. Similarly binary data cannot be stored to the session. For now no API is provided to delete things from the session, although you can set values to nil: Origen .app.session.main[ :exec_count ] = nil A Practical Example In one of our applications, called ‘NVM’, there is a need to program firmware images\nthat are provided by the design team. Rather than duplicate the firmware images in the design and test repositories they are typically\nimported from the design repository into the test workspace at runtime (on as as-required\nbasis).\nIt is critical to keep track of what version of the firmware exists locally so\nthat if the production firmware version changes then the new version will be fetched, but if it\nis the same as what is already there then the user is not made to wait for a redundant import operation. In early Origen applications, significant logic had to be added to the application to implement\nsuch a system, but the availability of the session store now makes this trivial: # Return the associated firmware file, this will automatically fetch the new version # if the production firmware tag has changed since this was last called def firmware_file path_to_local_file = \" #{ Origen .app.imports_dir } /firmware/production.hex \" f = Pathname .new(path_to_local_file) if !f.exist? || Origen .app.session.nvm[ :local_firmware_version ] != production_tag # Clear this up front as we won't know what we will have if the checkout fails Origen .app.session.nvm[ :local_firmware_version ] = nil firmware_rc.checkout( \" production.hex \" , force : true , version : production_tag) Origen .app.session.nvm[ :local_firmware_version ] = production_tag end f end # Returns a revision controller to manage local import of firmware files def firmware_rc @firmware_rc ||= Origen :: RevisionControl .new remote : \" sync://sync-15000:15000/nvm/firmware \" , local : \" #{ Origen .app.imports_dir } /firmware \" end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/misc/users/": {
    "title": "Users, Emails & Maillists",
    "subtitle": "Miscellaneous",
    "body": "Miscellaneous Users, Emails & Maillists This guide describes some APIs that are available to customize the output or behavior of\nyour application to the current user, or to send emails to the current user or a group\nof users. To access an object representing the current user simply call User.current and from there many attributes can be accessed: User .current # => <user object> User .current.name # => \"John Doe\" User .current.email # => \"johndoe@example.com\" See the User API for a full list of available\nattributes.\nNote that this is contingent on the current user setting up their name and email as described here . User objects for 3rd parties can be created by supplying a name and/or email like this: thao = User .new( \" thao@example.com \" )\nthao = User .new( \" thao@example.com \" , \" Thao Huynh \" ) LDAP Integration Origen can be integrated with an LDAP employee directory, to enable this configure the LDAP\nattributes in your company’s Origen configuration .\nTo look up a user within the LDAP system an ID is required, by default Origen will take the\nlogin name of the current Linux user as there ID. User objects can now be created by supplying a single ID argument: thao = User .new( \" b53254 \" ) To see the full information that is available for a user: User .new( \" b53254 \" ).display # => Prints a listing of all information available All attributes returned by your LDAP system will have accessors, in most cases these will\nreturn an array: User .new( \" b53254 \" ).country # => [\"Vietnam\"] Sending Emails If details of your company’s email server have been added to your company’s Origen configuration , then you can\neasily send emails from your application. An email can be sent to a given user by calling the send method on the user object,\ntry this in the console to send yourself an email: User .current.send subject : \" Hello \" , message : \" Origen is cool! \" Multi-line emails can be composed using Ruby’s multi-line string syntax: user = User .new( \" b53254 \" )\n\nuser.send subject : \" Hello \" , message : <<-END Hi #{ user.name } ,\n\nThis is just a short email, to say hello!\n\nCheers, #{ User .current.name } END Group emails can be sent by talking to the Origen mailer directly, an array of user objects or\nemail addresses can be given to the :to option: message = <<-END Hi All,\n\nJust to say have a nice day!\n\nThanks, #{ User .current.name } END distribution_list = [ User .new( \" r49409 \" ), User .new( \" r6aanf \" )] Origen .mailer.send_email( subject : \" Hello \" , to : distribution_list, body : message) Maillists Origen uses maillists to send notifications of development and production releases. The maillist files\nshould be located at config/maillist_dev.txt and config/maillist_prod.txt Sample lists: # config/maillist_dev.txt\n#\n# Product team X (handles commenting like this)\nfirst.last@company.com\njohn.smith@company.com # config/maillist_prod.txt\n#\n# Some other product team\nmemory.expert@company.com # Memory Test Lead (commenting like this is ok too)\n# Example of an ID only\nlast.first\nx49509 To get a list of your application’s mailists: Origen .app.maillist_dev # => [<first.last@company.com>, <john.smith@company.com>] Origen .app.maillist_prod # => [<memory.expert@company.com>, <last.first@MYcompany.com>, <x49509@MYcompany.com>] You can pass the returned array directly to the send_email method: Origen .mailer.send_email( subject : \" Hello \" , to : Origen .app.maillist_dev, body : \" Hello to all developers! \" ) Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/attributes/": {
    "title": "Adding Attributes",
    "subtitle": "Models",
    "body": "Models Adding Attributes Origen is an object-oriented environment and we have already seen that the application\ndomain will be modelled by creating object instances which represent the physical silicon.\nHowever the real power of object-oriented programming comes when we start assigning attributes\nto our objects. Static Attributes Continuing our example of modelling a fictional NVM module, an obvious attribute to start with is the\nsize of our NVM memory blocks, we can add this attribute like this: # lib/nvm/memory_128_b954.rb module NVM class MEMORY_128_B954 include Origen :: Model def initialize (options={}) @size_in_kb = 128 end end end @size_in_kb is an example of an instance variable in Ruby. An instance variable\nis one where the value it contains is unique to each object instance, so for example if we have multiple\ninstances of the same class then we can update the value held by an instance variable in one of them without\naffecting the value held by the same variable in the other instances. Instances variables are globally available within a class definition, in other words you can make\na reference to @size_in_kb from any methods that are defined within that class. However to\naccess them externally we need to create a getter method: # lib/nvm/memory_128_b954.rb module NVM class MEMORY_128_B954 include Origen :: Model def initialize (options={}) @size_in_kb = 128 end def size_in_kb @size_in_kb end end end In Ruby a method implicitly returns the value of the last piece of code it executed, so the method we\njust added will return the value held by @size_in_kb .\nWe can now ask a memory block it’s size: $dut = SOC :: EAGLE_M352 .new $dut .nvm.memories.first.size_in_kb # => 128 Note that we have used a method named first above but we have not defined that anywhere.\nThe memorys method created by Origen (which we aliased as memories returns the associated sub-blocks within a Ruby array. In Ruby everything\nis an object, so an array is a built-in object that comes complete with it’s own set of useful methods\nthat we can leverage.\nRuby is very well documented, here is the page describing all of the methods available to an Array: Ruby Array . Because the above example of creating a getter method is so common, Ruby provides a shorthand. We can re-write\nthe above example as: # lib/nvm/memory_128_b954.rb module NVM class MEMORY_128_B954 include Origen :: Model attr_reader :size_in_kb def initialize (options={}) @size_in_kb = 128 end end end This creates a reader (or getter) method which will look for an instance variable of the same name and\nreturn it. If the variable of the same name doesn’t exist then it will return nil . Calculated Attributes Attributes can also be derived from functions. For example within our application it may be useful to consume the size attribute in various formats,\nlet’s create a method to return the size in bytes: # lib/nvm/memory_128_b954.rb module NVM class MEMORY_128_B954 include Origen :: Model attr_reader :size_in_kb def initialize (options={}) @size_in_kb = 128 end def size_in_bytes @size_in_kb * 1024 end end end Of course such functions can also incorporate multiple attributes, here we create a method to return\nthe size in longwords: # lib/nvm/memory_128_b954.rb module NVM class MEMORY_128_B954 include Origen :: Model attr_reader :size_in_kb , :longword_size_in_bytes def initialize (options={}) @size_in_kb = 128 @longword_size_in_bytes = 8 end def size_in_bytes @size_in_kb * 1024 end def size_in_longwords size_in_bytes / longword_size_in_bytes end end end Note that sometimes you will see attribute or method references using the keyword self which means “the current instance”. Our size_in_longwords method could be re-written as: def size_in_longwords self .size_in_bytes / self .longword_size_in_bytes end Whether or not to use the self notation is really a matter of personal preference but be aware\nof it as you may see it used in other code whether or not you use it yourself. Another point to note is that the method was not written like this: def size_in_longwords @size_in_bytes / @longword_size_in_bytes end While this would have worked equally well, it is generally bad practice to reference instance variables\ndirectly and instead it is preferable to access them through a reader method, even when referencing\nthem internally. The reason for this is that if you ever need to transform or filter the value of an attribute, it can\nbe done easily in a single place if all references to the variable are made through a reader method. Dynamic Attributes Some attributes will change value during the course of executing your application, therefore in such\ncases we need a way of setting the value of the attribute in addition to reading it. Sticking with our NVM memory model such an attribute might be the value held by certain addresses in\nthe flash memory. Let’s create a new attribute to represent the data held by a location which we\nwill call config . # lib/nvm/memory_128_b954.rb module NVM class MEMORY_128_B954 include Origen :: Model def initialize (options={}) @config_data = 0xFF end def config_data @config_data end def config_data= (value) @config_data = value end end end With our new getter and setter methods for the config_data attribute we can now change\nthe value of it dynamically: $dut = SOC :: EAGLE_M352 .new\n\nmem = $dut .nvm.memories.first\n\nmem.config_data # => 0xFF mem.config_data = 5 mem.config_data # => 5 Again this is such a common pattern that a shorthand exists, to create getter and setter methods equivalent to\nthose above we can do: # lib/nvm/memory_128_b954.rb module NVM class MEMORY_128_B954 include Origen :: Model attr_reader :config_data attr_writer :config_data end end Or to create both, a further shorthand exists: # lib/nvm/memory_128_b954.rb module NVM class MEMORY_128_B954 include Origen :: Model attr_accessor :config_data end end Anonymous Sub-blocks with Attributes Sub-blocks without a specific class definition also support attributes, any attributes can either be\ndirectly written to the sub-block or supplied in the sub-block definition: class MySoC include Origen :: TopLevel def initialize (options={})\n sub_block :ram , size_in_kb : 128 # Once defined any additional attributes can be declared on the fly ram.clk_domain = :ipg end end $dut = MySoC .new $dut .ram.size_in_kb # => 128 $dut .ram.clk_domain # => :ipg $dut .ram.vendor = \" Mentor \" $dut .ram.vendor # \"Mentor\" Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/bugs/": {
    "title": "Bugs & Features",
    "subtitle": "Models",
    "body": "Models Bugs & Features The example code for tracking versions may seem like a\nlot of effort but it is very quick to implement additional\nconfigurations by copying and pasting the previous one, and remember that this only\nneeds to be done for revisions that make it to silicon. While it may seem like overkill initially, the benefit will become apparent as the\nnumber of silicon derivatives that your application must support begins to grow. By following\nthis architecture you will find that your application can scale to any number of derivatives easily and\nmost importantly you will continue to feel in control of it - especially when it comes to tracking which\nbugs and features exist on each device. Assigning Bugs to the Responsible Module A primary goal of Origen is to help with the creation of complex applications that remain easy to manage and a key\ncomponent of this is the creation of high level code flows that are both easy to follow and to understand. Therefore we do\nnot want our application to be littered with things like “if the device version is 50 then do this…“ , but rather to use the\nmore descriptive “if the device has the low reference voltage bug then do this…“ . Furthermore bugs should be assigned to the sub-block that is actually responsible for them - they should not\nbe assigned at SoC level . Adding bugs at SoC-level is equivalent to adding branches to your code like “if the device is an Eagle then do this…” which may seem reasonable but that has proven to be the path to a maintenance\nnightmare. The problem with that approach is that you have now set yourself up to have to answer the question “does this\ndevice have this bug?” for every new device that you ever add support for in the future. As the number of\ndevices and bugs (and features) grows, the number of such cases to manually track will grow exponentially. The solution to this problem is to track the bug or feature at component level and change your branch to “if the analog module in the NVM module of the current device has the low reference voltage bug then do this…“ . \nThen in the future simply add new device configurations\nby declaring the BOM as we have seen in the versioning guide . Your job is then done. This is because the bug workaround has been implemented in a way that requires no further human interaction\never again - if we create a new device that instantiates a version of the NVM analog that has the bug then\nour workaround will kick in automatically. Similarly if we add a new device which instantiates a version \nof the analog that doesn’t have the bug then the workaround will be bypassed automatically. Recording a Bug Here are some examples of adding bugs to the analog module within our example NVM module, note that bug\nmethod is a class method that must be called outside of the initialize (or any other) instance method: # file: lib/nvm/analog_t921.rb module NVM class ANALOG_T921 include Origen :: Model bug :low_vref , :affected_version => 11 bug :low_iref , :affected_versions => [ 11 , 12 ]\n bug :dac_code , :fixed_on_version => 12 bug :unfixable def initialize (options={}) end end end We have defined these bugs in terms of the affected versions and since our models already contain\nversion information the presence of bugs will be modelled accurately. We can test this in the console: # This will instantiate version 11 of the analog block $dut = SOC :: EAGLE_M352 .new( version : 0 ) $dut .nvm.analog.has_bug?( :low_vref ) # => true $dut .nvm.analog.has_bug?( :low_iref ) # => true $dut .nvm.analog.has_bug?( :dac_code ) # => true $dut .nvm.analog.has_bug?( :unfixable ) # => true # This will instantiate version 12 of the analog block $dut = SOC :: EAGLE_M352 .new( version : 1 ) $dut .nvm.analog.has_bug?( :low_vref ) # => false $dut .nvm.analog.has_bug?( :low_iref ) # => true $dut .nvm.analog.has_bug?( :dac_code ) # => false $dut .nvm.analog.has_bug?( :unfixable ) # => true When we get to the point of implementing a template or source file we will then be able to deal with these\nbugs via logic like: if $dut .nvm.analog.has_bug?( :low_vref ) # Workaround the bug else # Proceed as normal end Recording a Feature Feature identification can be added in a similar way, this API also supports optionally adding descriptions: # file: lib/nvm/analog_t921.rb module NVM class ANALOG_T921 include Origen :: Model feature :feature1 feature :feature2 , :description => \" feature2 description, this API for tools \" # This is feature 3 description, this API is for humans # and markdown should be used for formatting feature :feature3 def initialize (options={}) end end end $dut = SOC :: EAGLE_M352 .new( version : 0 ) $dut .nvm.analog.has_feature?( :feature1 ) # => true $dut .nvm.analog.has_feature?( :feature2 ) # => true $dut .nvm.analog.has_feature?( :feature3 ) # => true $dut .nvm.analog.has_feature?( :feature4 ) # => false $dut .nvm.analog.feature( :feature1 ).description # => [] $dut .nvm.analog.feature( :feature2 ).description # => [\"feature2 description, this API for tools\"] $dut .nvm.analog.feature( :feature3 ).description # => [\"This is feature 3...\", \"and markdown should be..\"] Note that it is not currently possible to track features by version like it is for bugs, however it would not\nbe very difficult to add this should the need arise. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/datasheets/": {
    "title": null,
    "subtitle": "Creating Datasheets",
    "body": "Origen provides an API for creating and manipulating datasheets within an Origen application. Datasheets are intended to provide all of the specific spec-tables, revision-history, \nand notes that are associated with a particular device. Including a datasheet in your \napplication will allow you to quickly call up any relevant information about a device\ndirectly to your console. The API is made available by including the Origen::Datasheet module. module MyApplication class TopLevel include Origen :: Datasheet # => makes the Datasheet available to application attr_accessor :datasheet end end Creating Datasheets Creating a datasheet is very simple and is demonstrated in the following code sample: module MyApplication class TopLevel include Origen :: Datasheet # => makes the Datasheet available to application attr_accessor :datasheet @datasheet = TopLevel .new.ds #=> Creates instance of a Datasheet in your application. end end Note: Creating a Datasheet in your Origen application does not physically instantiate an \nXML Datasheet, but rather an Origen model of one that is visible to your application. Importing an Existing Datasheet Through the RosettaStone plug-in, Origen is able to consume existing XML datasheets provided\nthey conform to the XML standards that the program expects. Importation is done via\nthe rs_import method like in the code sample below. The importation process is very fast in will complete in just a few seconds, even for very large XML\nfiles. module MyApplication class TopLevel include Origen :: Datasheet # => makes the Datasheet available to application attr_accessor :datasheet @datasheet = TopLevel .new.ds #=> Creates instance of a Datasheet in your application. @datasheet = rs_import( :path => \" path_to_your_datasheet.xml \" ) end end Spec Tables Spec Tables contain all of the relevant spec information for a particular device. \nAny given Spec contains information such as the Min and Max values, Note references, \nUnits, and Spec symbol, along with dozens of other possible attributes specified in the \nSpec API. Calling up Spec Tables from a datasheet to the console is very simple. All you will need is \nthe unique Spec Table ID. In the case that the specific Spec Table ID is not known, you will \nneed to follow the command examples below. $dut .ds.spec_tables # => This command lists every Spec Table in a datasheet, along with information including the ID. Once the correct ID is provided the Spec Table will be displayed on the console in a very friendly\ntable-view format. $dut .ds.spec_tables[ :unique_id ] # => Displays the Spec Table to the console You can also add a Spec Table to your datasheet and provide your own values if necessary. This\nis shown below. @datasheet .spec_table :unique_id do |t|\n t.full_name = \" Information you want to specify is done like this! \" end Revision History Often it is useful to know a datasheet has changed over time, and the revision history contains \nexactly that information. A Revision History is organized into a list of different Versions, \nwhere each Version lists every change that was made to the datasheet. Calling up information from the Revision History is very simple. If you are unsure of exactly\nwhich version you will need to look at, the below command will display a list of different Versions\nfor a datasheet’s Revision History, along with some information about each Version including the \naccess-key for each one. $dut .ds.revision_history # => diplays a list of each Version in a Revision History To view a specific Version use the following command $dut .ds.revision_history.versions[ :access_key ] # => displays the version to the console! Each Version will display a small table with the specific information concerning that version, \nas well as the list of changes displayed as text. Notes Notes provide engineers a way to include extra information about a Spec that may not\nfit into a specific attribute. Each note contains information like the item_area, the note text,\nand a unique ID for easy referencing and retrieval. Typing the following command into the Origen console will display a list of all notes and their IDs \nassociated with the datasheet. $dut .ds.notes If you would like to get a specific note use the following command $dut .ds.notes[ :note_id ] Searching Sometimes when a datasheet is very large it’s not always convenient to spend time looking up\ndifferent IDs to get the information you want. Currently, searching can be performed on Spec Tables\nand Notes. The way to perform a search is outlined in the following command examples. $dut .ds.spec_tables.search( \" search_string \" ) => this will display every Spec Table that matches \" search_string. \" $dut .ds.notes.search( \" search_string \" ) => displays every note corresponding to \" search_string. \" Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/defining/": {
    "title": "Definition & Hierarchy",
    "subtitle": "Models",
    "body": "Models Definition & Hierarchy Creating A Model A model can be any class that includes the Origen::Model module, this will give you access to\nall Origen APIs for defining registers, pins, etc. and generally makes Origen aware of any instances of the\nmodel when you instantiate them. class MyModel include Origen :: Model end As a general rule include the Origen::Model module every time you create a new class in Origen ,\neven if the model is\nnot of an SoC or an IP block and the concept of registers and pins does not apply.\nThere is not really any downside to including these APIs if you are not going to use them and this\nmodule is the main mechanism to hook your class into the Origen ecosystem. Creating A Top Level Model If a given model represents the top-level of an device then you should also include the Origen::TopLevel module, this specifically lets Origen know that it is a top-level model and as such it holds a special\nplace in the Origen runtime environment - for example any register write requests will be sent to this\nobject for dispatch. Internally the Origen::TopLevel module includes the Origen::Model module and\ntherefore it does not need to be specifically included in top-level model classes (although there is\nno harm from doing so). class MySoCModel include Origen :: TopLevel end Warning! While you can define multiple top-level models only one of them can be instantiated\n per target or Origen thread of execution. Attempts to instantiate a 2nd top-level object will raise an error. Regardless of what name is given to an instance of a top-level class it can always be looked up via Origen.top_level or more simply $dut . All Origen developers can rely on this\nconvention to access the current top-level object: soc = MySoCModel .new Origen .top_level == soc # => true $dut == soc # => true Modelling Hierarchy by Example As your experience with your application grows, the way to partition your models for easiest maintenance\nand development will start to become clear. At that point you may feel decide to start introducing\nabstract classes to handle the concepts that exist within your domain and which don’t necessarily have\na direct counterpart in the physical domain. However to get started we recommend that you closely follow the physical architecture of your target device, where\neach of the main IP blocks that you care about has an associated model. In this example we are going to set up an Origen model structure that will allow us to write some \ntest code for a fictional NVM module contained within an SoC. The Top Level We are going to call our application ‘NVM’ and all of our code will reside in the NVM namespace. However\nthe top-level SoC model is something of a special case because potentially it could be shared by many\napplications - e.g. an application concerned with testing the SRAM could re-use our SoC model. So to set us up to handle that eventuality in the future let’s put all of our top-level definitions into\ntheir own namespace which\nwe will call SOC . Here is how to define the top level model: # lib/soc/eagle_m352.rb module SOC class EAGLE_M352 include Origen :: TopLevel def initialize (options={}) end end end The initialize method will automatically be called by Ruby whenever a new instance of this class is\ninstantiated - so this is a place to do any setup or initialization that is required whenever a new\nEagle model comes into being. At this point we have also chosen to have this method optionally accept a hash of options, we will do this\nalmost every time we define a method since it builds in great flexibility and the ability to handle\nadditional arguments in future that we may not have thought about when first defining a new method. Interacting with Our New Model Our first model is now defined and we can now go and talk to it for the first time, to do so start\nan interactive Origen session from your terminal: origen i This command loads up an interactive Ruby terminal and automatically loads Origen and your application, so we can\nnow experiment with our models: $dut = SOC :: EAGLE_M352 .new $dut .is_a?( SOC :: EAGLE_M352 ) # => true Above we simply instantiated a new instance of our class, and then asked it if it was an instance of SOC::EAGLE_M352 , to which it replied: ‘yes’. Adding Sub Blocks Sub-blocks should be used to model IP blocks or indeed any sub-components within that IP, a generic sub-block\ncan be declared very simply within the top-level’s initialize method: # lib/soc/eagle_m352.rb def initialize (options={})\n sub_block :nvm end By default this will instantiate an object that includes all of the usual Origen APIs (regs, pins, etc.) and \nthis can then be decorated as required by the application (see example below). Most importantly this wires up\neverything internally such that the relationship between the child and the parent are known to Origen and it\nwill automatically build an accessor to get the child module: $dut = SOC :: EAGLE_M352 .new $dut .nvm # => Generic Origen object $dut .nvm.parent # => $dut $dut .children # => {:nvm => <object>} # Decorate as required by calling Origen APIs on the object $dut .nvm.reg :reg1 , 0x30 do |reg|\n reg.bits 31 .. 0 , :data end # The NVM now has a register available... $dut .nvm.reg1.write( 0x1234 ) The above approach is ideal where the models are being built from a 3rd party data source (e.g. standard XML)\nand all that is required is to get an Origen object representation of the same data. However in cases where more native richness is required you can supply a class for the object,\nlet’s create a dedicated model for our NVM IP: # lib/nvm/nvm_m682.rb module NVM class NVM_M682 include Origen :: Model def initialize (options={}) # Add an example register reg :reg1 , 0x30 do |reg|\n reg.bits 31 .. 0 , :data , reset : 0xFFFF_FFFF end end end end This follows the same pattern as our first model, note the use of the NVM namespace and the\nsubsequent storage of the file in the lib/nvm directory rather than lib/soc . We can now refer to this class in our sub-block definition and verify that the register we added is available: # lib/soc/eagle_m352.rb def initialize (options={})\n sub_block :nvm , class_name : \" NVM_M682 \" end $dut = SOC :: EAGLE_M352 .new $dut .nvm.reg1.address # => 0x30 $dut .nvm.reg1.data # => 0xFFFF_FFFF Wash, Rinse, Repeat This process can now be repeated to model the complete design hierarchy, the sub_block method\ncan be used within sub-blocks themselves with no limit on depth. Here are the complete set of initial stub models for the Eagle and it’s NVM module: # lib/soc/eagle_m352.rb module SOC class EAGLE_M352 include Origen :: TopLevel def initialize (options={})\n sub_block :nvm , class_name : \" NVM_M682 \" end end end # lib/nvm/nvm_m682.rb module NVM class NVM_M682 include Origen :: Model def initialize (options={})\n sub_block :analog , class_name : \" ANALOG_T921 \" sub_blocks :memory , class_name : \" MEMORY_128_B954 \" , instances : 4 sub_block :state_machine , class_name : \" CONTROL_D345 \" end # Origen is not yet smart enough to correctly pluralize 'memory', but we # can manually add this method to create a better experience for our users def memories memorys end end end # lib/nvm/analog_t921.rb module NVM class ANALOG_T921 include Origen :: Model def initialize (options={}) end end end # lib/nvm/memory_128_b954.rb module NVM class MEMORY_128_B954 include Origen :: Model def initialize (options={}) end end end # file: lib/nvm/control_d345.rb module NVM class CONTROL_D345 include Origen :: Model def initialize (options={}) end end end A couple of points are worth noting from the above code: The namespace reference is not required when making references to other models/classes within the\nsame namespace. Multiple instances have been specified for the memory sub-block. By convention use the\nsingular for the name, i.e. :memory , and then Origen will automatically create\naccessors called memory0 , memory1 , etc., and a method to get an\narray of all sub-blocks called memorys . Origen is not yet smart enough to generate\nthe correct English pluralization in this case, memories , but hopefully in future it will.\nIn the meantime we have manually created a memories method which will simply call\nthe memorys method that Origen created. The classes for the various NVM sub-blocks are all empty right now and as such they did\nnot really need to be defined, however these are placeholders for us to go on and add more\nlogic in the future. Even though we have not yet added any logic to our models they are starting to become useful,\nfor example we can now ask the Eagle how many NVM memory blocks that it has: $dut = SOC :: EAGLE_M352 .new $dut .nvm.memories.size # => 4 Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/hw/": {
    "title": "Hardware Attributes",
    "subtitle": "Models",
    "body": "Models Hardware Attributes The need to model abstract hardware properties can sometimes arise, most\ncommonly when generating a view of the models which needs to contain some detailed\ninformation about the RTL architecture - generating an IP-XACT view of the IP for use\nin verification would be a good example of this. HDL Paths For designers using Origen as the master definition of their registers and other metadata, it\nis always preferable to setup the Origen models to mirror the eventual hierarchy of\nthe RTL.\nIn that case nothing special is required to extract HDL path information and the path method available on all sub-blocks, registers and bits should do a\ngood job: $dut .atd.path # => \"mydut.atd\" (Where 'mydut' is the lowercased class name) $dut .atd.reg1.path # => \"mydut.atd.reg1\" $dut .atd.reg1.data.path # => \"mydut.atd.reg1[15:0]\" (Where 'data' are some named bits in reg1) However in cases where that is not possible the following API exists to reconcile\nany differences. For any point in the tree the default can be overridden by setting the @path instance variable within the\ngiven object, this can also be supplied at sub-block declaration time. e.g. class MyDut include Origen :: TopLevel def initialize sub_block :atd , class_name : \" ATD \" , base : 0x1000_0000 , path : \" atds.atd0 \" end end $dut .atd.reg1.data.path # => \"mydut.atds.atd0.reg1[15:0]\" $dut .atd.path = \" atds.atd1 \" $dut .atd.reg1.data.path # => \"mydut.atds.atd1.reg1[15:0]\" Layers can be taken out of the hierarchy altogether by setting the path attribute to :hidden : sub_block :atd , class_name : \" ATD \" , base : 0x1000_0000 , path : :hidden $dut .atd.reg1.data.path # => \"mydut.reg1[15:0]\" Register and bit definitions can also be given a path override: reg :reg1 , 0 do |reg|\n reg.bits 31 .. 0 , :data end reg :reg2 , 0x4 , path : \" reg2_reg \" do |reg|\n reg.bits 31 .. 0 , :data end reg :reg3 , 0xC , path : \" reg3_reg \" do |reg|\n reg.bits 31 .. 0 , :data , path : \" data_reg \" end reg1.data.path # => \"mydut.atd.reg1[15:0]\" reg2.data.path # => \"mydut.atd.reg2_reg[15:0]\" reg3.data.path # => \"mydut.atd.data_reg\" Note that in the case of the path being given to the bits it bypasses the\nregister altogether, to include the register prefix the bit path name with\na . reg :reg3 , 0xC , path : \" reg3_reg \" do |reg|\n reg.bits 31 .. 0 , :data , path : \" .data_reg \" end reg3.data.path # => \"mydut.atd.reg3_reg.data_reg\" Absolute Paths Sometimes for a given node that is handled ‘unusually’ in RTL it is easier just\nto give an absolute path, the abs_path attribute can be set in\nplace of the path attribute for any of the examples above. When resolving paths from a child object the final path will be returned\nimmediately when an absolute path is encountered, this is best shown by example: sub_block :sub1 sub_block :sub2 , path : \" memory_block.ram \" sub_block :sub3 , abs_path : \" p2.flash \" sub1.reg1.path # => \"p1.sub1.reg1\" (where p1 is the path of the parent) sub2.reg1.path # => \"p1.memory_block.ram.reg1\" sub3.reg1.path # => \"p2.flash.reg1\" Registers and bits will also accept abs_path in place of path . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/introduction/": {
    "title": "Introduction",
    "subtitle": "Models",
    "body": "Models Introduction Models are at the heart of an Origen application and can be thought of as\nobject representations of the silicon in the application domain.\nModels can instantiate other models and they can be nested arbitrarily deep\ndepending on the needs of your application. For example, if your application is only concerned with generating dynamic \ndocumentation for a small number of devices, then it may be sufficient\nto have a single model representing each device. If on the other hand, your application is concerned with generating complex\ndesign or test code, then a lot more information will be encapsulated within your\nmodels. In these cases your application will be much easier to manage\nusing multiple models\nto represent the sub-blocks that make up the device or module in\nquestion. Model responsibilities include but are not limited to: Defining the architecture of the target device Defining what bugs or features are present in the target device Defining register and bit maps Defining any other attributes of the target device, e.g. memory size Within the Origen ecosystem, the model is intended to be the master of\nthe universe and everything from documents, to test patterns, even to\nthe design IP itself, can be considered different ways of viewing or consuming the\nmodel. It is important to spend\nthe time to architect the models in an organized manner and one which closely\nresembles the silicon that you are trying to represent.\nOnce the solid model foundation is in place, it then becomes very easy to decide\nwhere to add additional data in the future. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/modes/": {
    "title": "Package, Mode & Configuration",
    "subtitle": "Models",
    "body": "Models Package, Mode & Configuration A given SoC or IP block can typically operate in various modes or configurations\nand may have its feature set modulated by the package that it is in. The following APIs allow such concepts to be modelled so that they can then be used\nto scope things like pin availability. Package This represents the package that the device is in, however this could be a real physical\npackage or a pseudo package such as the subset of pins available to a given probecard.\nThe package is an a SoC attribute and therefore this API is only available to models\nthat include the Origen::TopLevel module. A simple package definition requires simply supplying a name for it, here are\nsome examples but the names are completely arbitrary and you can use whatever you\nlike: class MyDut include Origen :: TopLevel def initialize add_package :probe add_package :mapbga add_package :qfp end end By default the model will boot with no package set, this state would be used\nto represent the die with all pins exposed. The package state can then be changed as shown: $dut .package # => nil $dut .package = :mapbga $dut .package # => <mapbga package object> $dut .with_package :qfp do $dut .package # => <qfp package object> end $dut .package # => <mapbga package object> Packages are objects (an instance of the Origen::ChipPackage class)\nand additional attributes can be set at definition time like this: def initialize add_package :t2080 do |package|\n package.number_of_rows = 16 package.number_of_columns = 16 end add_package :t4080 do |package|\n package.number_of_rows = 32 package.number_of_columns = 32 end end $dut .package = :t2080 $dut .package.number_of_columns # => 16 $dut .package = :t4080 $dut .package.number_of_columns # => 32 See the ChipPackage API for the up to\ndate list of available attributes. Mode This represents which mode the device is in, again this can represent a real operating mode\nsuch as user, functional test, RAMBIST, etc. or some abstract concept that is specific to the\ngiven domain. The mode API is available to any object that includes Origen::Model and therefore\nsub-blocks can also define their own modes and have a mode context independent of the top-level\nobject. Modes are defined and set in the same way as packages, here are some examples: class MyDut include Origen :: TopLevel def initialize add_mode :user add_mode :rambist end end $dut .mode # => nil $dut .mode = :user $dut .mode # => <user mode object> $dut .with_mode :rambist do $dut .mode # => <rambist mode object> end $dut .mode # => <user mode object> Note that like packages the modes are represented by objects which can be assigned attributes,\nsee the ChipMode API for the up to\ndate list of available attributes. Mode objects do support a convenience API for checking the current mode: $dut .mode.user? # => false $dut .mode.rambist? # => true Configuration This is another layer which supports the concept that different configurations may exist within\nthe one mode. More generally it is simply another scope that the application can use to describe\ndifferent states/configurations. Like modes, the configuration API is available to any object that includes Origen::Model and therefore\nsub-blocks can also define their own configurations and have a configuration context independent of the top-level\nobject. Here are some examples: class MyDut include Origen :: TopLevel def initialize add_mode :user add_mode :bist add_configuration :nvm add_configuration :ram end def enter_rambist_mode self .mode = :bist self .configuration = :ram # In a test application you would generate the necessary vectors to actually do this here # Upon exit from this method 3rd parties will now be able to tell that the DUT is in RAMBIST mode/configuration end end $dut .enter_rambist_mode # => nil $dut .mode.bist? # => true $dut .configuration # => :ram Note that currently the configuration is not represented as an object and therefore cannot\nstore additional attributes associated with the given configuration. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/naming/": {
    "title": "Naming",
    "subtitle": "Models",
    "body": "Models Naming One of the hardest things in computer science is said to be naming things. Model naming convention may vary from company to company, but we recommend aligning to whatever\nsystem is used by the hardware design teams. In other words the Origen model name for a given\nIP should be the same as whatever the RTL or macro is called for the corresponding object in the\ndesign world. The overall goal is to eliminate ambiguity and end up with a system where it straightforward to\nidentify what silicon IP is represented by a given Origen model. Class Naming Each of your model definitions will be a Ruby class and it is required by Ruby that the class\nname starts with a capital letter. It is also Ruby convention to use CamelCase for class names,\nhowever in our experience this is not necessarily easy to stick to if you are also trying to\nkeep your class names in sync with a 3rd party naming system as recommended above. If not following CamelCasedNaming, then we recommend that you uppercase and underscore\nTHE_CLASS_NAME for consistency. It is Ruby (and Origen) conventions that each class is contained within it’s own file that\nhas been assigned the lower_cased_and_underscored version of the class name. So for example the model for EAGLE_M352 would look like this: # lib/eagle_m352.rb class EAGLE_M352 # Model definition and logic goes here end Namespacing Namespacing your code is good practice and is also recommended, in Ruby a namespace involves wrapping\nall of your code in a uniquely named module. For example all of the Origen code is contained within the Origen namespace and this\n(as we will see shortly) is why the Origen register API is accessible via Origen::Registers instead of just Registers . The name used for the namespace should uniquely identify your application within your ecosystem,\nif you were writing an application to test a RAM module at a 28nm node for example, then you might go\nwith simply C28RAM . The namespacing is also mirrored in the file system hierarchy, so all of the files for C28RAM should live in lib/c28ram . Wrapping the above example in the namespace would change it to: # lib/c28ram/eagle_m352.rb module C28RAM class EAGLE_M352 # Model definition and logic goes here end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/parameters/": {
    "title": "Parameters",
    "subtitle": "Models",
    "body": "Models Parameters A given model, or indeed an application, will often have some parameters associated with\nit.\nWhile any standard Ruby accessors and instance variables can be used to define such\nparameters the following API is provided to define them in a standardized way. The \nadvantages to using this API vs. a roll-your-own solution are as follows: The API provides a number of features that go above and beyond what basic Ruby\nattribute accessors provide, this would require significant application-side code to\nreplicate Using standard APIs gives your code a familiar look and feel to any new developers who\nmay work on it in future You will be able to benefit from future additions to the Origen ecosystem that hook into\nthis API, e.g. a documentation helper to automatically generate a parameter summary\nwill almost certainly emerge Basic Idea Parameters are defined as a group of named values that will apply in a given context, many\ndifferent sets of values to apply in different contexts can be defined.\nA context can be used to represent any abstract concept that you like, but a good example \nwould be to have a set of parameter values that will apply at probe, a different set for final test and a\ndifferent set for spec operation. The current parameter context can be set and changed dynamically at runtime as required\nby your application, typically this would be set on a per-target/environment basis or for pattern\ngeneration on a per-pattern basis.\nA common approach for pattern generation is to leverage sourceless pattern generation and employ the convention that the first field in the pattern name refers to the spec\ncontext - e.g. probe_mypat, ft_mypat, spec_mypat.\nIt is then trivial to set the parameter context based on the pattern name, thereby providing a bulletproof way to update any\ngiven parameter for every probe pattern by simply updating its value in the probe parameter\nset definition. Including the Parameters API To use the parameters API in an abstract class the following module can be included: include Origen :: Parameters However this is already included the Origen::Model and Origen::TopLevel modules and any class which includes those will already have access to this API. Defining a Set of Parameters Parameters are defined as shown below, it is always a good idea to create a parameter\ncontext called :default , these are the values that will be enabled when\na parameter context has not explicitly been set: define_params :default do |params|\n params.tprog = 20 .uS\n params.terase = 100 .mS end Parameters can be organized into namespaces by simply writing them, no upfront definition\nis required and there is no limit to how deeply nested they can be: define_params :default do |params|\n params.program.time = 20 .uS\n params.erase.time = 100 .mS\n params.erase.pulse_count = 10 params.test.dc.vdd.min = 1.5 params.test.dc.vdd.max = 2.5 end Parameters are read back in application code via the params method: params.test.dc.vdd.min # => 1.5 Each namespace in the chain returns an object that can be used like a hash: def print_erase_parameters params.erase.each do |name, value|\n puts \" #{ name } : #{ value } \" end end print_erase_parameters # => time: 0.1 # => pulse_count: 10 The current parameter context is set as follows: params.context # => :default params = :probe params.context # => :probe with_params :ft do params.context # => :ft end params.context # => :probe Tracking the Context of Another Object The parameter context for a given object can be configured to automatically track that of another object by\nspecifying a Ruby path to the object to be tracked as shown below: # A short hand is available to track the parameter context from the top level ($dut) class MyObject include Origen :: Model parameters_context :top end # Or you can supply a path to the object in the form of a string, here the path reference is local to the MyObject # instance class MyObject include Origen :: Model parameters_context ' parent.mbist ' end # Or another example where the target object is found via the global scope class MyObject include Origen :: Model parameters_context ' $dut.pll ' end Then whenever the parameter context is set on the tracked object the same context name will be applied\nwhen referencing a parameter within the tracking object, for example: $dut .params.context # => :default my_object.params.context # => :default $dut .params.context = :probe $dut .params.context # => :probe my_object.params.context # => :probe Late Defined Parameters Occasionally the need may arise to base a parameter value on a property of the model\nor the wider environment that is not yet finalized or known at the time when the parameter\ndefinition code is being executed.\nIn that case the parameter can be defined as a function and Origen will hold off evaluating\nit until the last possible moment when it is first referenced: define_params :default do |params|\n params.test.dc.vdd.min = -> { $dut .vdd * 0.9 } end Such parameters will behave identically to standard parameters in all respects and consumers\nwill not be able to tell if a given parameter originated from a function. Defining Child Sets Complete parameter sets can be defined for different named contexts, however in many cases\nonly a subset of the parameters will have different values vs. another context.\nTo make maintenance of such cases efficient the API allows parameter sets to be defined in a\nhierarchy such that a given set can be defined with a parent and if it does not define\na value for a given parameter then the value from the parent will be returned instead. define_params :ate , inherit : :default do |params|\n params.erase.time = 40 .mS end define_params :probe , inherit : :ate do |params|\n params.erase.time = 20 .mS\n params.erase.pulse_count = 5 end define_params :ft , inherit : :ate do |params|\n params.erase.pulse_count = 7 end with_params :probe do params.program.time # => 20uS (inherited from :default) params.erase.time # => 20ms params.erase.pulse_count # => 5 end with_params :ft do params.program.time # => 20uS (inherited from :default) params.erase.time # => 40ms (inherited from :ate) params.erase.pulse_count # => 7 end Sometimes the parameter definition for a child context should be a function of the\nvalue from the parent, when defining a child context the parent can be accessed\nlike this: define_params :ate , inherit : :default do |params, parent|\n params.test.dc.vdd.min = parent.test.dc.vdd.min * 0.9 params.test.dc.vdd.max = parent.test.dc.vdd.max * 1.1 end params.context # => :default params.test.dc.vdd.min # => 1.5 params.test.dc.vdd.max # => 2.5 params = :ate params.test.dc.vdd.min # => 1.35 params.test.dc.vdd.max # => 2.75 The context can also be explicitly supplied when fetching a parameter, this will\noverride the parameter context that would otherwise be applied: params.context # => :default params.test.dc.vdd.min # => 1.5 params( :ate ).test.dc.vdd.min # => 1.35 Live Updating Parameters When a parameter is referenced a static value is returned which thereafter has no\nrelationship to the current parameter context, for example: terase = params.erase.time\nparams.erase.time # => 100ms terase # => 100ms params = :probe params.erase.time # => 20ms terase # => 100ms The above should not be surprising and is what would normally be expected, however\nthrough the magic of Ruby a live updating parameter can be returned by referring\nto it via params.live : terase = params.live.erase.time\nterase # => 100ms params = :probe terase # => 20ms This is an experimental feature and developers are encouraged to play around with it and\nreport back on any useful applications that they may find for it.\nPotentially this is a good way to expose parameters via an interface to 3rd parties without coupling\nthem tightly to the namespacing and organization of the parameters within the owning class. It is certainly only really useful when applied in conjunction with parameter contexts that can\nchange within the scope of a pattern or other Origen thread of execution. While the examples\nso far have focussed on parameter contexts that will be permanent for a given thread,\nlike probe or ft, contexts can be used to represent more dynamic concepts. For example a given\nNVM pattern may read the flash under different read conditions where the configuration for\neach one is modelled by parameter contexts defined within the read controller. Another possible use case is to bind register bit values to parameters, due to the way\nthat Origen stores register data at bit level a register cannot simply be written to a live\nparameter, however a dedicated API is provided for this case: reg :erase , 0x0 do bits 3 .. 0 , :pulses end erase.pulses.data # => 0 erase.pulses.bind params.live.erase.pulse_count\nerase.pulses.data # => 10 params = :probe erase.pulses.data # => 5 In other words anytime that register gets written in the course of a pattern generation\nrun its value will automatically track the current parameter context. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/pins/": {
    "title": "Pins",
    "subtitle": "Models",
    "body": "Models Pins Origen provides a pin (and pin group) API that should be used to define and manipulate the\nphysical pins of the device. Pins are mainly intended to be defined on models that will be used for pattern generation\nand where the pins represent the physical device pins that the tester can interact with.\nHowever in its basic form a pin is just an object that can hold a data state and there\nare probably some creative uses of the pin models outside of pattern generation. The pin API is made available to your model by including the Origen::TopLevel or Origen::Model modules. While pins can be added\nfrom any sub-module the ownership of all pins is always assigned to the top-level object,\nthis is reflecting real life where the pin is a physical property of the top-level SoC.\nTherefore it is recommended that pin definitions are always made on the top-level object\nand most modern Origen applications now take this approach. Defining Pins Pins should be defined as part of the object initialization process, but to avoid the\ninitialize method growing out of hand it is recommended that pins are instantiated in a\ndedicated method that is called upon initialization. Here is an example of how to define some JTAG interface pins in an SoC model: class MySoC include Origen :: TopLevel def initialize (options={})\n instantiate_pins(options) end def instantiate_pins (options={})\n add_pin :tclk , reset : :drive_hi add_pin :tdi , direction : :input add_pin :tdo , direction : :output add_pin :tms end end Some points to note in the above code: add_pin will instantiate an instance of Origen::Pins::Pin Each pin must be given a name, or handle, similar to how registers are named. However unlike\nregisters the name must not only be unique within the parent object but it must also be unique\nwithin the scope of all objects instantiated by a target . The easiest way to comply with this requirement\nis to follow the advice of handling all pin definitions at the top level. Pins are initialized in the don’t care state by default, an alternative default state can be specified via\nthe :reset option. Pins are I/Os by default, however they can be defined as input or output only by using the :direction option. Pins are accessed via the pin method: $dut .pin( :tdi ) # => <pin object> Note that pins can be accessed locally from any object that includes the Origen::Model module: $dut .pin( :tdi ) == $dut .memories.rambist.pin( :tdi ) # => true However references to pins within a sub-block would typically use an alias that reflected the pin function related to\nthat sub-block. Pin aliases are added like this: has_pin?( :tdi ) # => true has_pin?( :bisti ) # => false add_pin_alias :bisti , :tdi has_pin?( :bisti ) # => true pin( :bisti ) == pin( :tdi ) # => true Or called directly on the pin: pin( :tdi ).add_alias( :bisti ) Defining Pin Groups Pin groups are modelled by an object called a PinCollection which is very similar in principle to the BitCollection used for modelling registers.\nA PinCollection is essentially an extension of a regular Ruby\narray object which has some of its own attributes (such as an id for example) and everything else is proxied to\nthe contained pin objects. For pattern generation pins and pin groups will support the same API so that application code does not have to\ngive much concern as to whether it is dealing with one or the other. Pin groups are defined in a similar manner to single pins: add_pins :porta , size : 32 add_pins :portb , size : 16 , endian : :little Some points to note in the above code: add_pins will generate a new pin group, e.g. named :porta and individual pin\nobjects named :porta0 through :porta31 .\nSee below for how to define pin groups based on existing pins. Pin groups can be any size, define via the :size option. Pin groups are big endian by default, however little endian can be specified via the :endian option. Changing this attribute will have the effect of reversing the\norder that data is applied in a test pattern. Pin groups can be looked up like regular pins, or via a dedicated method if it makes application code clearer: pins( :porta ) # => <pin collection> pin_group( :porta ) # => <pin collection> A pin group is a regular Ruby array and can be iterated on and so on: pins( :porta ).size # => 32 pins( :porta ).each do |pin| # Do this for pin :porta0, :porta1, etc. end Within a pin group individual pins can be addressed via a local index: pins( :porta )[ 0 ] == pins( :porta0 ) # => true Anonymous pin groups can be composed from a range of indexes at runtime: pins( :porta ).data # => 0x0000_0000 pins( :porta )[ 0 , 1 , 2 , 3 ].drive( 0xF )\npins( :porta ).data # => 0x0000_000F pins( :porta )[ 8 .. 15 ].drive( 0x55 )\npins( :porta ).data # => 0x0000_550F Pin groups can be composed from any arbitrary group of existing pins using the add_pin_group method: # The first argument is the ID for the new pin group, followed by the IDs of the pins it should contain add_pin_group :jtag , :tdi , :tdo , :tclk , :tms pins( :jtag ).size # => 4 Pin groups can be aliased in the same way as pins, for readability the method add_pin_group_alias can be used, although internally it is the same as add_pin_alias : add_pin_group_alias :porta , :data pin_group( :data ).dont_care # Can now be used as if it were a regular first class pin group It is possible to alias a single pin within a pin group, in that case a pin number argument\nmust be supplied to add_pin_alias : add_pin_alias :moda , :porta , pin : 4 It is also possible to create a pin group from a subset of pins of a regular pin group, simply\npass in a range or an array of pin indexes to add_pin_group_alias : add_pin_group_alias :data_byte_0 , :porta , pins : [ 7 .. 0 ]\nadd_pin_group_alias :data_byte_1 , :porta , pins : [ 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 ]\n\npins( :data_byte_0 ).dont_care # Can now be used as if it were a regular first class pin group Power and Ground Pin Modelling The API supports modelling power and ground pins as follows: add_pin :pinx add_power_pin :vdd1 add_power_pin :vdd2 add_ground_pin :gnd1 add_ground_pin :gnd2 add_ground_pin :gnd3 add_power_pin_group :vdd , :vdd1 , :vdd2 add_ground_pin_group :gnd , :gnd1 , :gnd2 , :gnd3 This will cause these pins to be stored in separate collections to make pattern and other content generation easier: # Based on the above example pins.size # => 1 power_pins.size # => 2 ground_pins.size # => 3 Power and ground pin lookup should be done via dedicated methods: power_pin( :vdd1 )\nground_pins( :gnd )\n\nground_pin_groups.each do |id, group| # Do this for each ground pin group end Virtual Pin Modelling The API supports modelling virtual pins. Virtual pins are essentially user-defined pins that may not necessarily be\nassociated with the SoC, such as: Tester utility pins that control relay states on the device interface board (DIB) Tester channels to control components on the DIB add_virtual_pin( :virtual1 , type : :utility_pin )\nadd_virtual_pin( :virtual2 , type : :utility_pin )\nadd_virtual_pin( :virtual3 , type : :relay_pin )\n\nadd_virtual_pin_group :utility , :virtual1 , :virtual2 add_virtual_pin_group :relay , :virtual3 This will cause these pins to be stored in separate collections to make content generation easier: # Based on the above example virtual_pins.size # => 3 Virtual pin lookup should be done via a dedicated method: virtual_pin( :virtual1 )\n\nvirtual_pin_groups.each do |id, group| # Do this for each virtual pin group end Changing Data State See the Pin API for full details of what methods are available. Here are a few examples of working with pins: # Make the tester drive a value on a pin pin( :tdi ).drive_hi # Equivalent to above, this form is better when serially applying data in a loop... pin( :tdi ).drive( 1 ) # ...like this... reg( :data ).shift_out_left do |bit|\n pin( :porta ).drive(bit.data) end # Asserting that a pin drives a certain value has various aliases, these are all equivalent pin( :tdo ).assert( 1 )\npin( :tdo ).compare( 1 )\npin( :tdo ).expect( 1 ) # Current state can be queried pin( :tdo ).driving? # false pin( :tdo ).comparing? # true pin( :tdo ).dont_care\npin( :tdo ).comparing? # false pin( :tms ).drive_lo\npin( :tms ).toggle # Pin groups support the same methods as pins pins( :porta ).drive( 0x55 ) # 01010101 pins( :porta ).assert( 0x55 ) # LHLHLHLH pins( :porta ).dont_care # XXXXXXXX # Individual pins within a pin group can be accessed by index pins( :porta )[ 1 ].drive( 0 ) # XXXXXX0X Bang (!) Methods Almost all pin methods have a bang form, for example: pin( :tdi ).drive!( 1 ) The bang methods will set the state on the pin in the same way as the regular method but\nwill then automatically fire off a tester cycle to generate a vector. In other words the above is the shorthand equivalent of: pin( :tdi ).drive( 1 ) $tester .cycle Pin Availability by Package Pins can be defined based on a specific package context which can be used to gate their availability. Here is an example: # Initially define the available packages at the top level before adding any pins class MySoC include Origen :: TopLevel def initialize add_package :pkg1 add_package :pkg2 end end Pins can then be defined by package: add_pin :pin1 , packages : :all add_pin :pin2 # No constraint is equivalent to :all add_pin :pin3 , package : :pkg2 add_pin :pin4 , packages : [ :pkg1 , :pkg2 ] # Pins can also be added within a package scope, these will add to :pkg1 only with_package :pkg1 do add_pin :pin5 add_pin :pin6 end # All pins are available when the package is set to nil, no package represents the die package # => nil pins.size # => 6 package = :pkg1 pins.size # => 5 (no pin3) has_pin?( :pin3 ) # => false package = :pkg2 pins.size # => 4 (no pin5 or pin6) has_pin?( :pin3 ) # => true Pin groups can contain different sets of pins in different packages: add_pin( :pin1 )\nadd_pin( :pin2 )\nadd_pin( :pin3 )\n\nadd_pin_group :g1 , :pin1 , :pin2 , package : :pkg1 add_pin_group :g1 , :pin1 , :pin2 , :pin3 , package : :pkg2 has_pins?( :g1 ) # => false pin_groups.size # => 0 package = :pkg1 has_pins?( :g1 ) # => true pins( :g1 ).size # => 2 pin_groups.size # => 1 package = :pkg2 has_pins?( :g1 ) # => true pins( :g1 ).size # => 3 pin_groups.size # => 1 Package Attributes The attributes listed in the constant PACKAGE_SCOPED_ATTRIBUTES in the Pin API can be set to specific values per package. Here is an example of how to set the pin location by package: # At definition time add_pin :pin1 , packages : { pkg1 : { location : \" A2 \" }, pkg2 : { location : \" A3 \" }}\nadd_pin :pin2 # Or later pins( :pin2 ).add_location \" A5 \" , package : :pkg1 pins( :pin2 ).add_location \" B2 \" , package : :pkg2 package = :pkg1 pins( :pin1 ).location # => \"A2\" pins( :pin2 ).location # => \"A5\" package = :pkg2 pins( :pin1 ).location # => \"A3\" pins( :pin2 ).location # => \"B2\" A context can also be supplied when reading such attributes to override the current context: package = :pkg1 pins( :pin1 ).location # => \"A2\" pins( :pin1 ).location( package : :pkg2 ) # => \"A3\" Origen will automatically create an alias for the given location (a lower cased symbol) that is scoped to the package. package = :pkg1 has_pin?( :a2 ) # => true has_pin?( :a3 ) # => false package = :pkg2 has_pin?( :a2 ) # => false has_pin?( :a3 ) # => true Pin Functions Pin aliases are an example of modelling different pin functions that can be mux’d onto the same pin, in this case\nthe pin attributes are the same regardless of the function name being used. However sometimes it is necessary to model different attributes depending on the pin function - for example under\none function the pin may be an input, but when used as another function it is an output. The attributes listed in the constant FUNCTION_SCOPED_ATTRIBUTES in the Pin API can be set to specific values per context (mode and/or configuration). Here is an example of adding a function: class MySoC include Origen :: TopLevel def initialize add_pin :pin1 add_pin :pin2 # Define some pin functions pin( :pin1 ).add_function :nvm_fail , direction : :output pin( :pin2 ).add_function :nvm_done , direction : :output pin( :pin1 ).add_function :tdi , direction : :input pin( :pin2 ).add_function :tdo , direction : :output # Add some groupings that are associated with specific pin functions add_pin_group :jtag , :tdi , :tdo add_pin_group :nvm , :nvm_fail , :nvm_done end end $dut = MySoC .new # The name used to look up a pin now returns the pin with a thin wrapper around it # which defines its current function: $dut .pin( :nvm_fail ).direction # => :output $dut .pin( :nvm_done ).direction # => :output $dut .pin( :tdi ).direction # => :input $dut .pin( :tdo ).direction # => :output # If a function name is given when defining a pin group, the pin will always have # that function when it is accessed through the resultant group $dut .pins( :jtag )[ 0 ].direction # => :output $dut .pins( :jtag )[ 1 ].direction # => :input $dut .pins( :nvm )[ 0 ].direction # => :output $dut .pins( :nvm )[ 1 ].direction # => :output Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/registers/": {
    "title": "Registers",
    "subtitle": "Models",
    "body": "Models Registers When modelling semiconductor IP, there will almost always be a need to define register\nand bit maps and Origen provides an API specifically for this purpose. When modelling silicon with Origen, the hardware should be the guide as to\nwhere logic or attributes should go and if you have followed the advice so far\nthen you will already have a model framework that closely resembles the physical hardware.\nThe registers then, are simply instantiated within the model of the corresponding hardware\nthat owns them. Defining Registers Registers should be defined as part of the object initialization process, but to avoid the\ninitialize method growing out of hand it is recommended that you instantiate registers in a\ndedicated method that is called upon initialization. When defining registers you can either take the approach of defining them all up front\nor defining them individually on an as-needed basis - the latter is recommended as it is the most\nefficient in terms of effort. Here is an example of how to define this register in our memory map: # file: lib/nvm/analog_t921.rb module NVM class ANALOG_T921 include Origen :: Model def initialize (options={})\n instantiate_registers(options) end def instantiate_registers (options={})\n reg :ctrl , 0x0024 , size : 16 do |reg|\n reg.bit 7 , :coco , access : :ro reg.bit 6 , :aien reg.bit 5 , :diff reg.bit 4 .. 0 , :adch , reset : 0x1F end end end end Some points to note in the above code: Even though we have not used it we have continued the practice of setting up every method with\nan optional option argument and we have passed this between method calls - i.e. we passed the\ninitialize options when calling instantiate_registers. This keeps things extremely flexible for\nthe future and means that it is easy to influence the register instantiation externally, for\nexample: NVM::ANALOG_T921.new(include_test_registers: true) The reg method takes a name, address and size as arguments. The size is optional\nand is 32 by default. Bit definitions are contained within the do..end block passed to the reg method. By default bits are writable and will reset to 0, but this can be overridden as shown\nin the example. When defining bits the size is 1 by default and the reset state is 0 by default, these can be\noverridden on an as needed basis as shown above. Accessing Registers Origen will automatically create accessor methods for the register and its bits, the above register\nwould be accessed like this: $dut .nvm.analog.ctrl # => <register object> $dut .nvm.analog.ctrl.adch # => <subset of bits> The Origen console will show a nice graphical representation of the register which reflects its\ncurrent state, this can be very useful when debugging or more generally as an interactive\nversion of the block guide: > origen i\n\n>> $dut.nvm.analog.ctrl\n=>\n0x24 - :ctrl\n ================================================================================================================\n | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 |\n | | | | | | | | |\n | | | | | | | | |\n ----------------------------------------------------------------------------------------------------------------\n | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\n | :coco | :aien | :diff | :adch[4:0] |\n | 0(RO) | 0 | 0 | 0x1F |\n ---------------------------------------------------------------------------------------------------------------- Origen supports some more verbose APIs that you may see used in some codebases or documentation,\nthese are now considered legacy APIs but are equivalent to the above: $dut .nvm.analog.reg( :ctrl ) $dut .nvm.analog.reg( :ctrl ).bits( :adch ) $dut .nvm.analog.reg( :ctrl )[ :adch ] Origen supports Verilog style part selects to access an ad-hoc subset of bits, although unfortunately [3:0] is not valid Ruby and [3..0] is used instead. $dut .nvm.analog.ctrl[ 1 ] # => bit 1 of the register $dut .nvm.analog.ctrl.adch[ 1 ] # => bit 1 of the adch bits $dut .nvm.analog.ctrl[ 3 .. 0 ] $dut .nvm.analog.ctrl.adch[ 1 .. 0 ] Base Addresses When defining registers the address specified should be the local address within the owning\nIP block. Base addresses can be passed in within the sub block definition, base_address is an official\noption that Origen will recognize and automatically deal with. # lib/nvm/nvm_m682.rb sub_block :analog , class_name : \" ANALOG_T921 \" , base_address : 0x4000_0000 Registers will automatically pick up the base address of their parent, the local address can\nbe accessed via the offset method: $dut .nvm.analog.ctrl.address # => 0x4000_0024 $dut .nvm.analog.ctrl.offset # => 0x24 Note that when resolving a base address Origen will look right up the hierarchy until it reaches the top\nlevel object and all base addresses in that branch of the tree will be added together. Register Domains An API is available to model register domains, where domain could mean what bus or clk domain that the\nregister is on, or any similar concept. Domains must first be declared in the object that owns them and then they can be passed to sub block\ndefinitions: domain : :ips domain : :ahb , endian : :little sub_block :analog , class_name : \" ANALOG_T921 \" , base_address : 0x4000_0000 , domain : :ips The domain attribute will also accept an array of multiple domain names as required. The child block and any of its registers will then be associated with the given domains: $dut .nvm.analog.domains # => {ips: <object>} $dut .nvm.analog.ctrl.domains # => {ips: <object>} Note that the domains method returns a hash pointing to objects that represent the domains,\nthis can therefore be associated with attributes such as the :endian attribute in the\nexample above. See the Domain Class API for an up to date list of\nsupported attributes. Per-Domain Base Addresses Domain specific base addresses can be assigned to a sub-block by passing a hash to the :base_address option as shown in the example below: class Top include Origen :: TopLevel def initialize domain :ips domain :ahb sub_block :subx1 , class_name : \" SubX \" , base_address : 0x1000_0000 sub_block :subx2 , class_name : \" SubX \" , base_address : { ips : 0x2000_0000 , ahb : 0x3000_0000 } end end class SubX include Origen :: Model def initialize reg :reg1 , 0x200 do bits 31 .. 0 , :data end sub_block :suby1 , class_name : \" SubY \" , domain : :ips sub_block :suby2 , class_name : \" SubY \" , domain : :ahb end end class SubY include Origen :: Model def initialize reg :reg1 , 0x300 do bits 31 .. 0 , :data end end end $dut = Top .new $dut .subx1.reg1.address # => 0x1000_0200 $dut .subx1.suby1.reg1.address # => 0x1000_0300 $dut .subx1.suby2.reg1.address # => 0x1000_0300 # Where a register falls into the case where multiple domains are specified for it, you must # indicate the one you want $dut .subx1.reg1.address( domain : :ips ) # => 0x2000_0200 $dut .subx1.reg1.address( domain : :ahb ) # => 0x3000_0200 $dut .subx2.suby1.reg1.address # => 0x2000_0300 $dut .subx2.suby2.reg1.address # => 0x3000_0300 In the case where a register owned by a child sub-block is not in any of the domains listed in the base address\nhash then it will pick up a base address of 0. An alternative default can be set by adding a :default key to the hash: sub_block :subx2 , class_name : \" SubX \" , base_address : { default : 0x1000_0000 , ips : 0x2000_0000 , ahb : 0x3000_0000 } Documenting Registers Registers can be documented by Ruby comments like this: # ** MGATE Clock Divider Register ** # The MCLKDIV register is used to divide down the frequency of the HBOSCCLK input. If the MCLKDIV # register is set to value \"N\", then the output (beat) frequency of the clock divider is OSCCLK / (N+1). The # resulting beats are, in turn, counted by the PTIMER module to control the duration of Flash high-voltage # operations. reg :mclkdiv , 0x0003 , size : 16 do |reg| # **Oscillator (Hi)** - Firmware FMU clk source selection. (Note that in addition to this firmware-controlled bit, the # FMU clock source is also dependent on test and power control discretes). # # 0 | FMU clock is the externally supplied bus clock ipg_clk # 1 | FMU clock is the internal oscillator from the TFS hardblock reg.bit 15 , :osch , reset : 1 end The descriptions are then programmatically accessible via the following methods: mclkdiv.full_name # => \"MGATE Clock Divider Register\" mclkdiv.description( include_name : false ) # => [\"The MCLKDIV register is...\", \"register is set...\", ...] bit = mclkdiv.osch\nbit.full_name # => \"Oscillator (Hi)\" bit.description( include_name : false , include_bit_values : false ) # => [\"Firmware FMU clk...\", \"FMU clock...\", ...] bit.bit_value_descriptions[ 0 ] # => \"FMU clock is the externally supplied bus block ipg_clk\" bit.bit_value_descriptions[ 1 ] # => \"FMU clock is the internal oscillator from the TFS hardblock\" Most commonly these descriptions will be used for documentation, for example the Documentation Helpers plugin provides\nhelpers to easily present registers in Origen documentation as shown here - Register Helpers . The descriptions can also be supplied as in-line arguments, but doing so overrides any comment-based\ndocumentation. Thus, it is intended to be used\nonly when the register is being declared programmatically by an importer and humans\nshould stick to the above API for clarity: reg :mclkdiv , 0x0003 , size : 16 , description : \" ** MGATE Clock Divider Register ** The MCLKDIV reg... \" do |reg|\n reg.bit 15 , :osch , reset : 1 , description : \" ** Oscillator (Hi) ** - Firmware FMU clk source selection... \" end Defining Application-Specific Metadata Within a given application it may be desired to attach some meta-data to a register or bits to\ntrack application-specific properties, for example whether a register is only readable in test\nmode or not. The object owning the register can define a default set of custom attributes and then override\nthese for specific registers and bits.\nHere is an example: def instantiate_registers (options={})\n\n default_reg_metadata do |reg|\n reg.user_reg = false end default_bit_metadata do |bit|\n bit.time_to_respond = 0 end reg :fstat , 0x0001 , size : 8 , user_reg : true do |reg|\n reg.bit 8 , :ccif , time_to_respond : 10 .us\n reg.bit 7 , :rdcolerr reg.bit 6 , :accerr , access : :w1c reg.bit 5 , :fpviol , access : :w1c reg.bit 0 , :mgstat , access : :ro end reg :mclkdiv , 0x0002 , size : 16 do |reg|\n reg.bit 15 , :osch , reset : 1 reg.bit 13 .. 12 , :mode_rdy , writable : false reg.bit 10 , :eccen , reset : 1 reg.bit 9 .. 8 , :cmdloc reg.bit 7 .. 0 , :div end end fstat.user_reg? # => true mclkdiv.user_reg? # => false fstat.ccif.time_to_respond # => 10us fstat.accerr.time_to_respond # => 0 Global attributes can also be added, when done in this way the meta data\nwill be applied to all registers within the scope of an application. If the same attribute is later declared within a class as above then the value\nfrom the class will take precedence. As with the above example the attribute values can be overridden when\ndefining registers and bits. Origen :: Registers .default_reg_metadata do |reg|\n reg.attr_x # Adds the attribute with a default value of nil reg.attr_y = 10 # Adds the attribute with a default value of 10 end Origen :: Registers .default_bit_metadata do |reg|\n reg.attr_z = 15 end Plugins may also use this approach to globally extend the attributes of\nregisters and bits. Importing Registers If the register data for the target device/module is already mastered somewhere else, for\nexample in IP-XACT format, then it can be imported directly to save having to manually duplicate the\nregister definitions in Origen.\nThis will generate the exact same models of the registers as if they had been declared directly\ninto Origen. This import (and export) functionality is provided via the Cross Origen plugin and this should be consulted directly for the latest information on the API and the supported formats. However here is a brief example of how it can be used to import from a local XML file: # lib/nvm/nvm_m682.rb module NVM class NVM_M682 include Origen :: Model include CrossOrigen def initialize (options={})\n cr_import( path : \" #{ Origen .root } /ipxact_files/nvm_m682.xml \" ) end end end Understanding the Origen Register Model By using the above API Origen has now built an accurate register model that will look and behave like the\nreal register on silicon.\nThis is extremely convenient and useful for pattern generation as we will see later, but it can also\nbe very useful for other applications such as generating documentation . Each register created by Origen is an instance of the Origen::Registers::Reg class.\nThis does not by itself provide that much functionality and its main purpose is as a container for the\nindividual bits that make up the register. Each bit is an instance of the Origen::Registers::Bit class. The main function of the bit object is to store a single bit of data and to track the state of various\nattribute flags that monitor such things as whether the bit is writable, or readable, or whether a particular bit\nis required to be read during a test pattern operation. Similar to the Reg the Bit API is mainly for internal use. Instead the public facing API is implemented by the Origen::Registers::BitCollection class.\nThis class provides a consistent API whether you are working with an entire register or a subset of bits in\nthe register. By calling ctrl a new BitCollection is generated on the fly and populated\nwith all of the bit objects contained in the register.\nSimilarly if you call ctrl.adch then a BitCollection will be\nreturned that contains only the subset of requested bits. Examples Here are a few examples of working with the register that we recently added: $dut = SOC :: EAGLE_M352 .new( version : 1 )\n\nreg = $dut .nvm.analog.ctrl\n\nreg.data # => 31 reg.data.to_hex # => \"0x1F\" # Only bits that are writable can hold data, the same as real silicon reg.write( 0xFFFF )\nreg.data.to_hex # => \"0x7F\" # Individual bits can be manipulated reg.adch.data # => 31 reg.adch.write( 0 ) \nreg.adch.data # => 0 reg.data.to_hex # => \"0x60\" # Bits can be marked for read reg.is_to_be_read? # => false reg.coco.read\nreg.coco.is_to_be_read? # => true reg.aien.is_to_be_read? # => false reg.is_to_be_read? # => true # The register can be reset reg.reset\nreg.is_to_be_read? # => false reg.data.to_hex # => \"0x1F\" Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/specs/": {
    "title": "Specifications",
    "subtitle": "Models",
    "body": "Models Specifications Dictionary.com defines a specifications (or spec): a detailed description or assessment of requirements, dimensions, materials, etc., as of proposed building, machine, bridge, etc. Origen refines spec to mean a parametric measure that has the following basic attributes: Name Symbol Type Mode Audience Description Limits (min, max, typ) This is not the complete list of attributes but a well defined spec should define these\nattributes. Specification API The spec API is in the preliminary stages so please send feedback for enhancements Most engineers are probably familiar with a data sheet specification that looks something\nlike this: Parameter Symbol Min Typ Max Unit Notes ADDR/CMD Setup tddkhas 495     ps wrt MCK There are three attributes required to define a Spec: name, mode, and type. A fourth\nattribute (sub_type) can further delineate a Spec but it is not required. The basic\nspec API can take two syntactical forms. The first is a more traditional Ruby syntax\nand the second makes the API feel more like a custom DSL. spec :soc_vdd , :dc do |spec|\n spec.symbol = \" Vdd \" spec.description = \" Soc Core Power Supply \" spec.min = \" 1.00.V - 50.mV \" spec.max = 1.05 spec.unit = \" V \" spec.audience = :external end spec :soc_vdd , :dc do symbol \" Vdd \" description \" Soc Core Power Supply \" min \" 1.00.V - 50.mV \" max 1.05 unit \" V \" audience :external end While the user can be free to add various attributes over time, they must assign a valid\nname and have valid limits to complete instantiation. A valid name must not start with\nletters and cannot contain special characters forbidden by Ruby. Dashes and underscores\nare allowed but the preferred method is to make spec name Symbols in the snake-case format .\nLimits can be of type Numeric or String so the API is flexible enough to handle\nspecs with a formula as the limit. Valid limits are defined as: If Min && Max: Min < Max if limit is Numeric. If Target, Min < Target < Max A target can be thought of as an unofficial typical value. Targets are typically used when\nspecs are exported for use in data analysis and also help understand if a min anx max limit\nare not symetrical. During spec limit assignment the user just can either input a numeric value, a symbol or\na string. [ 1 ] pry()> @ip .specs( :ip_setup_time ).min\n=> #<struct Origen::Specs::Spec::Limit exp=\"250.ps + 25.ps\", maturity=nil, value=2.7e-10> [ 2 ] pry()> @ip .specs( :ip_setup_time ).min.exp\n=> \" 250.ps + 25.ps \" [ 3 ] pry()> @ip .specs( :ip_setup_time ).min.value\n=> 2.7e-10 The Spec model will save the original user input as an expression and will\nattempt to evaluate the string to a numeric value or lookup the symbol within the\nParameters and Specs database. Currently only the numeric and string expressions are working. Notice how the mode attribute is never specified. This is because the Spec API will\nalways use the mode of the current object as a default. If no mode is specified (nil)\nthe user intends for the Spec to be available to all modes of the defining object. The\nuser, of course, can specify a mode as shown below. The Spec API will only return\nspecs that match that specified mode instead of returning globally defined specs. spec :soc_vdd , :dc , :mymode do symbol \" Vdd \" description \" Soc Core Power Supply \" min \" 1.00.V - 50.mV \" max 1.05 unit \" V \" audience :external end Another thing to note about modes is that specs defined with no mode will be\ncatalogued as :global if the owning object is Origen.top_level and :local for\nany other owning IP. This allows certain specs to be used across the Origen\necosystem and other local specs to be contained inside the owning IP. The user can search for specs using filters for any of the following: Name Mode Type Sub-Type If any of the options are nil it will not filter by that option when interrogating the\nspec database. The API is: specs( :myspecname , options) In the example above a symbol is passed for the spec name but all four filter options\ncan be a String, Number or a Regexp. If an object defined three specs named :soc_vdd,\n:io_vdd, :pll_vdd the following call would occur. specs( / vdd / , verbose : true ) ================================================================================================\n| IP: soc |\n================================================================================================\n| Name | Symbol | Mode | Type | Parameter | Min | Max | Unit | Audience |\n------------------------------------------------------------------------------------------------\n| soc_vdd | Vdd | :global | dc | Soc Core Power Supply | 0.95 | 1.05 | V | external |\n| io_vdd | OVdd | :global | dc | Soc IO Power Supply | 1.45 | 1.55 | V | external |\n| pll_vdd | AVdd | :global | dc | Soc PLL Power Supply | 1.15 | 1.25 | V | external |\n------------------------------------------------------------------------------------------------ If the ‘verbose’ argument is not included, only an array of spec objects is returned. If only a\nsingle spec is found a Spec object is returned instead of an array of a single spec. The console\nprinting method only displays attributes which have content for at least one of the specs\nfound. It also auto-adjusts the attribute column padding so no space is wasted. Specs and Modes in Detail Specs can be defined globally or within nested sub_blocks or controllers . A spec\nis defined in the context of a mode, even if it only has a single mode. A mode is defined as\na known device state with a unique name or id. An simple example could be a basic PORESET\nthat defines the clocking and register space state after turning a chip on. The spec\nAPI does not require a mode to be defined but it will assign some reserved modes if none is\nprovided. If the owner of the block is equal to Origen.top_level a mode named :global is assigned,\notherwise a mode named :local is assigned. Specs with a local mode are not accessible\noutside the model in which they are defined. A spec with a global mode is accessible\neverywhere but will be overwritten is defined both globally and locally. Here is an\nexample where a spec is defined within three modes. class SoC_With_Specs include Origen :: TopLevel def initialize sub_block :ip_with_specs , class_name : \" IP_With_Specs \" , base_address : 0x1000_0000 add_mode :default add_mode :low_power add_mode :high_performance modes.each do |mode| case mode when :default vdd_nom = 1.0 .V when :low_power vdd_nom = 0.95 .V when :high_performance vdd_nom = 1.05 .V end spec :soc_vdd , :dc , mode do symbol \" Vdd \" description \" Soc Core Power Supply \" min \" #{ vdd_nom } - 50.mV \" max \" #{ vdd_nom } + 50.mV \" audience :external end end end end Notice below how both the limit expression and value get changed based on the mode\nselection of the owning IP. [8] pry()> @dut.mode\n=> high_performance\n[9] pry()> @dut.specs(:soc_vdd).min.exp\n=> \"1.05 - 50.mV\"\n[10] pry()> @dut.specs(:soc_vdd).min.value\n=> 1.0\n[11] pry()> @dut.mode = :low_power\n=> :low_power\n[12] pry()> @dut.specs(:soc_vdd).min.value\n=> 0.9\n[13] pry()> @dut.specs(:soc_vdd).min.exp\n=> \"0.95 - 50.mV\" Specs have an audience attribute that can be set to :internal or :external. They\nalso have a read-only attribute called ‘limit_type’ which is either :single_sided\nor :double_sided. Here are some attribute access examples: [7] pry()> @ip.specs(:ip_setup_time).mode\n=> :new_mode_with_altered_specs\n[8] pry()> @ip.specs(:ip_setup_time).limit_type\n=> :double_sided\n[10] pry()> @ip.specs(:ip_setup_time).notes = \"my note\"\n=> \"my note\"\n[11] pry()> @ip.specs(:ip_setup_time).notes\n=> \"my note\"\n[12] pry()> @ip.specs(:ip_setup_time).symbol # Defaults to name if no value supplied\n=> :ip_setup_time\n[13] pry()> @ip.specs(:ip_setup_time).testable\n=> true\n[14] pry()> @ip.specs(:ip_setup_time).audience\n=> :internal\n[15] pry()> @ip.specs(:ip_setup_time).description\n=> \"IP Setup Time with Double-Sided Limits\" The Origen::Specs::Spec class is available to all models and as such has a method ot find all specs\nthat exist in the model itself or any child models. This method is useful when trying to\nexport the spec information of a model to other API. [ 2 ] pry( #<RSpec::ExampleGroups::OrigenSpecsModule>)> @dut.find_specs.size => 8 Remaining Issues and Documentation Add in support for spec ‘notes’ being more than just a text string.\nWill require adding in a Note class to Origen. Add in support for Specs and Parameters lookup for formula evaluation. Enable more attributes required for traceability and test plan creation Formalize a spec guardband definition and methodology Enable Spec name lookup for symbols used in limit formulas Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/models/versioning/": {
    "title": "Versioning",
    "subtitle": "Models",
    "body": "Models Versioning Adding a version attribute is strongly encouraged since this will be how bugs and\nfeatures will be tracked in the future. Since this is such a common attribute all Origen models already have a version attribute and if\nthis key is passed to a sub_block definition it will automatically be attached to the sub-block,\neven in the case where a custom class is used. When instantiating an SoC model we can supply a version and this should then cascade down\nthe hierarchy affecting what versions of the sub-modules get instantiated. Let’s say that two different versions of our Eagle device exist, and in turn each one instantiated\na different version of the NVM IP.\nWe can model that like this: # lib/soc/eagle_m352.rb module SOC class EAGLE_M352 include Origen :: TopLevel def initialize (options={}) case version when 0 sub_block :nvm , class_name : \" NVM_M682 \" , version : 3 when 1 sub_block :nvm , class_name : \" NVM_M682 \" , version : 5 else fail \" The BOM for version #{ version } has not been defined! \" end end end end Note that we define an error condition if our application attempts to instantiate a version that we\nhave not defined. We then cascade this information down the tree, so our NVM module should also instantiate it’s\ncomponents based on the required version: # lib/nvm/nvm_m682.rb module NVM class NVM_M682 include Origen :: Model def initialize (options={}) case version when 3 sub_block :analog , class_name : \" ANALOG_T921 \" , version : 11 sub_blocks :memory , class_name : \" MEMORY_128_B954 \" , instances : 4 , version : 12 sub_block :state_machine , class_name : \" CONTROL_D345 \" , version : 20 when 5 sub_block :analog , class_name : \" ANALOG_T921 \" , version : 12 sub_blocks :memory , class_name : \" MEMORY_128_B954 \" , instances : 4 , version : 12 sub_block :state_machine , class_name : \" CONTROL_D345 \" , version : 24 else fail \" The BOM for version #{ version } has not been defined! \" end end end end We can test this out in the console: $dut = SOC :: EAGLE_M352 .new( version : 0 ) $dut .nvm.state_machine.version # => 20 $dut = SOC :: EAGLE_M352 .new( version : 1 ) $dut .nvm.state_machine.version # => 24 Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/common/": {
    "title": "Common API",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator Common API All tester drivers support the common API described in this guide. By building your patterns\nusing this API your will be able to generate them for any ATE that is supported by Origen. Some tester drivers may expose additional methods to leverage some key features of\nthe given ATE which do not have direct equivalents on other systems. You may or may not\nchoose to use these in your application. If you do, then be aware that you are introducing\nsome logic which cannot be automatically translated to other ATEs. In that case you will have to implement\nthe alternative implementation for other platforms on the application side,\nsomething like this: if $tester .uflex? # An implementation that uses a method that only exists on the UltraFLEX driver, # this will make the test run more efficiently on that platform else # Conventional implementation using the common API for all other platforms end Of course some applications may only ever wish to target a specific ATE, in that case you\ncan freely pick from the common and ATE-specific APIs. This API is currently provided by the Origen Testers plugin . In addition\nto the primary methods discussed below, all tester drivers support the methods described in the following\nAPI docs: OrigenTesters::VectorGenerator OrigenTesters::Timing OrigenTesters::API API Methods Here are each of the main methods supported by the common API. Generating Cycles These are the basic methods for generating vectors. cycle(options = {}) Generate a tester cycle or cycles: $tester .cycle $tester .cycle repeat : 1000 As this is such a commonly used method, there are some convenience methods available, this is\nequivalent to the above example: 1 .cycle 1000 .cycles A very common pattern when working at this level is to setup some pin states and\nthen trigger a cycle: pin( :tdi ).drive( 1 ) $tester .cycle\npin( :tdi ).drive( 0 ) $tester .cycle All of the pin state methods support a bang ( ! ) variant which will automatically\ncall a single cycle after setting the pin state, this is equivalent to the above: pin( :tdi ).drive!( 1 )\npin( :tdi ).drive!( 0 ) wait(options = {}) Repeats the last vector for the specified about of time. The time can be specified in cycles\nor a time, multiple arguments will be added together: $tester .wait cycles : 1000 # Equivalent to $tester.cycle(repeat: 1000) $tester .wait time_in_us : 1000 # Wait for 1000us $tester .wait time_in_ms : 1 # Wait for 1ms $tester .wait time_in_ms : 1 , time_in_us : 1000 , cycles : 100 # Wait for 2ms + 100 cycles The wait method can also be called with additional arguments to generate a dynamic wait,\ni.e. a match loop.\nHere for example to wait for up to 2 seconds for the done pin to go high: $tester .wait match : true , time_in_s : 2 , pin : pin( :done ), state : high The above API is somewhat verbose, a cleaner one is available by supplying a block to generate\nthe vectors which much pass for the match to resolve.\nThis is equivalent to the previous example: $tester .wait match : true , time_in_s : 2 do pin( :done ).assert!( 1 ) end This block form also allows much more complex match conditions to be described, here to wait\nfor either the fail pin to go high, OR the done pin to go high: $tester .wait match : true , time_in_s : 2 do |conditions, fail|\n conditions.add do pin( :done ).assert!( 1 ) end conditions.add do pin( :fail ).assert!( 1 ) end end To AND these conditions would simply be: $tester .wait match : true , time_in_s : 2 do pin( :done ).assert( 1 )\n pin( :fail ).assert( 1 ) 1 .cycle end ignore_fails(*pins) Ignore fails on the given pins for the duration of the given block, this\nhas the effect of temporarily setting the states of the given pins to\ndon’t care. # Temporarily ignore mis-compares on the fail and data pins $tester .ignore_fails(pin( :fail ), pins( :data )) do # Any vectors generated in here will force the state of the given pins to X end Data Capture store(*pins) Instruct the tester to capture the data on the given pins from the vector that was generated last,\nnote that it does not actually generate a new vector. Sometimes when generating vectors within a loop you may want to retrospectively capture\na previous vector, passing in an offset option will allow you to do this. Here are some examples: $tester .cycle # This is the vector that we want to capture $tester .store pin( :d0 ), pin( :d1 ) # Capture the data on the d0 and d1 pins $tester .cycle # This one gets stored $tester .cycle $tester .cycle $tester .store pin( :d0 ), pin( :d1 ), offset : -2 # Just realized I need to capture that earlier vector Note that this API is for engineers who are writing protocol drivers, most test IP would be\nwritten at a higher level, e.g. atd_result.data.store! # Capture the value of the ATD result bits to the tester store_next_cycle(*pins) Similar to the above, this API allows driver creators to indicate that the next vector,\nwherever that may be generated, should be captured: $tester .store_next_cycle pin( :d0 ), pin( :d1 ) # This is the vector that will be captured, in real life this could be done after returning # to a caller $tester .cycle Subroutines start_subroutine(name), end_subroutine Use these methods to write a pattern subroutine: $tester .start_subroutine \" wait_for_done \" $tester .wait match : true , time_in_s : 2 do pin( :done ).assert!( 1 ) end $tester .end_subroutine call_subroutine(name, options = {}) Call a pattern subroutine, an offset can be given to retrospectively jump to a subroutine\nfrom a previous vector: $tester .call_subroutine \" wait_for_done \" 1 .cycle 1 .cycle # A branch will also be made after completing this vector 1 .cycle 1 .cycle $tester .call_subroutine \" wait_for_done \" , offset : -2 Loops and Branching label(name) Inject an arbitrary label into the pattern: $tester .label \" on_failed \" branch_to(label) Branch to a label: $tester .branch_to \" on_failed \" loop_vectors(name, number_of_loops) Execute the vectors generated within the given block n times: $tester .loop_vectors( \" my_loop \" , 3 ) do # Do this 3 times... $tester .cycle end Miscellaneous freq_count(pin) Setup to measure the frequency on the given pin: $tester .freq_count pin( :clk_out ) microcode(code, options = {}) This can be used to inject arbitrary microcode into the pattern, which of course is\ninherently coupling your logic to a specific test platform - so use sparingly! An offset can be given to apply the microcode to previously generated vectors. $tester .microcode ' set_cpu (cpuC) ' 1 .cycle 1 .cycle # cpuB will be set here 1 .cycle 1 .cycle $tester .microcode ' set_cpu (cpuB) ' , offset : -2 Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/creating/": {
    "title": "Creating Patterns",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator Creating Patterns Patterns are generated by regular Ruby files that should live within the pattern directory - a sub-directory within there is fine and is in fact encouraged to help\nkeep things organized as the number of patterns increases.\nHowever keep in mind that each pattern should be uniquely named - i.e. no other files of the\nsame name should live in\nany of the sub-directories of pattern . Each pattern file should have the following structure: Pattern .create do # Pattern specific content goes here end Startup and Shutdown Sequences Startup and shutdown sequences will generally be the same for all patterns and these should\nbe implemented by using the callbacks that support pattern generation . Any options supplied to Pattern.create will be passed into the startup and shutdown methods when they are called, thereby providing a mechanism for per-pattern\ncustomization of the startup/shutdown sequences. Here is an example of an SoC controller with some startup and shutdown callbacks implemented: class MyDeviceController include Origen :: Controller def startup (options)\n options = { mode : :functional_test ,\n }.merge(options) if options[ :mode ] == :functional_test enter_functional_test_mode elsif options[ :mode ] == :bist enter_bist_test_mode else raise \" Unknown mode requested - #{ options[ :mode ] } \" end end def shutdown (options)\n options = { reset : true ,\n }.merge(options)\n reset_device if options[ :reset ] end end So by default this pattern will enter functional test mode at the start and reset the device at the end: Pattern .create do # Pattern specific content goes here end This one will enter BIST mode instead at the start: Pattern .create( mode : :bist ) do # Pattern specific content goes here end and this one would exit without resetting the device: Pattern .create( mode : :bist , reset : false ) do # Pattern specific content goes here end Note - The top-level is guaranteed to be called first and last for the startup and shutdown\n callbacks respectively. However the calling order of lower level startup/shutdown listeners is undefined, if\n you have multiple and care about the order you should designate one as the master which will be called by Origen, it\n should then co-ordinate calling any additional startup/shutdown methods as required. The Golden Rules for Building Maintainable Patterns Origen provides a framework in which you can build very complex patterns that remain\neasy to maintain, but as with any tool it is also possible to use it to create something\nwith which to hang yourself! In order to avoid going down a path that will lead to an unmaintainable mess, it is\nstrongly recommended that the following rules are observed: Patterns should not talk to the current tester object directly Patterns should not attempt to control pin states Patterns should not attempt to access registers directly Probably the most tempting one to break is the last one, however\ngenerally manipulating register states outside of the owning model is a sign of poor\napplication design and breaking the encapsulation that should be provided by a model\nrepresenting a silicon module.\nInstead the model’s controller should provide an external interface which would remain constant even if the\ninternal operation of a given operation changes significantly from one silicon revision to the next.\nSee the Controller guides for more. If the above rules are followed pattern source files should typically be very small and should\ngenerally only call a handful of methods on the target object(s), here are a few examples: # Pattern to measure the output of the Vreg module Pattern .create do $dut .vreg.measure end # Pattern to measure the output of the Vreg module for a specific setting Pattern .create do $dut .vreg.measure( setting : 12 ) end # Pattern to program a checkerboard and then read it Pattern .create do $dut .nvm.program( pattern : :ckbd ) $dut .nvm.read( pattern : :ckbd ) end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/custom/": {
    "title": "Custom Testers",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator Custom Testers Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/documenting/": {
    "title": "Documenting Patterns",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator Documenting Patterns Origen encourages an agile approach to documentation and pattern generation is\nno exception.\nTools are provided to create test patterns that are self-documenting and by taking\na little care you can produce very detailed (and of course 100% accurate) documentation\nof your test patterns for free. The pattern generation command has the following switches: origen g bistcom # Generate a regular pattern\norigen g bistcom --doc # Output documentation of that pattern to the terminal\norigen g bistcom --html # Generate pre-formatted HTML documentation for inclusion in a web page The following methods are available to control the documentation output from the pattern\ngenerator… Debug Documentation Comments that may help with debug of patterns on the tester can be injected into\nthe pattern via the cc method, as with all methods related to\npattern documentation this is globally available. cc \" Entering test mode now \" test.mode.write!( RAMBIST_MODE )\nreset! The method argument is a regular string and dynamic segments can be embedded and\nformatted using any regular Ruby. delay_cycles = 100 cc \" Wait for #{ delay_cycles } cycles for the mode to latch \" address = 0x12 cc \" Set the target address to: 0x%04X \" % address This will produce pattern output that looks like this: // Wait for 100 cycles for the mode to latch\n// Set the target address to 0x0012 c1 is an alias for cc . These low level comments will appear in the pattern but they will not be included\nwhen a document of the pattern is generated. A c2 method is available to elevate the importance of a subset of\nthese low level comments\nsuch that they will be included in generated documentation. cc \" You won't see me in the docs \" c1 \" Or me \" c2 \" But you will see me! \" Documenting Major Steps Major steps in the pattern can be highlighted using the ss method. ss \" Enter RAM BIST mode \" # A block form is also available ss do vdd_core = 1.7 cc \" Enter RAM BIST mode with the following options: \" cc \" Vdd core - #{ vdd_core } v \" end This will produce the following output in the pattern: // #######################################################################\n// # Enter RAM BIST mode\n// #######################################################################\n\n// #######################################################################\n// # Enter RAM BIST mode with the following options:\n// # Vdd core - 1.7v\n// ####################################################################### Any comments defined in this way are considered more important than the regular cc comments and they will be automatically included in the\ngenerated documentation. Documenting Structure When presenting documentation it is useful to know something about the structure\nof the pattern, this allows vectors to be grouped into sections like ‘startup’, \n‘shutdown’, etc. Such structure can be described using the pp method: pp \" Startup \" do $dut .enter_ram_bist_mode $dut .ram.configure_for_test end def enter_ram_bist_mode pp \" Enter RAM BIST mode \" do # Mode entry code here... end end This would produce comments in the pattern that look like this: // #######################################################################\n// # Startup\n// #######################################################################\n\n// #######################################################################\n// # Enter RAM BIST mode\n// ####################################################################### However this difference vs. the ss method is that information about\nthe structure has been provided - it can be determined that the enter RAM bist\nsection is a sub-section of the wider startup sequence. This comes into play when the pattern documentation is generated as HTML,\nnow we will see something like this (click to expand): Startup Enter RAM BIST mode # Some comments generated by the RAM BIST entry sequence Adding Annotations Sometimes it will be helpful to add some annotations to describe what sections\nof the pattern are doing, this can be done via the annotate method. Any annotations will not be output in the actual pattern but will be included\nin generated documentation. Here is the above example with some annotations added: pp \" Startup \" do annotate \" Perform startup operations that are common to all patterns. \" $dut .enter_ram_bist_mode $dut .ram.configure_for_test end def enter_ram_bist_mode pp \" Enter RAM BIST mode \" do annotate <<-END This is an example of a multi-line annotation. Anything you write here\n will be parsed as markdown, so you can do things like:\n\n * Create bullet\n * Lists\n\n ~~~ruby\n # Embed some code examples\n $dut.enter_ram_bist_mode\n ~~~\n\n Or create [links](http://origen.freescale.net) END # Mode entry code here... end end This would produce the following snippet of documentation: Startup Perform startup operations that are common to all patterns. Enter RAM BIST mode This is an example of a multi-line annotation. Anything you write here\nwill be parsed as markdown, so you can do things like: Create bullet Lists # Embed some code examples $dut .enter_ram_bist_mode Or create links # Some comments generated by the RAM BIST entry sequence Summarizing Long Sections Sometimes it is not necessary to list out every comment or operation when documenting \na pattern. For example if the pattern downloads some functional code to be executing\non the chip it is not really necessary to include the entire code download in the\npattern document. For these scenarios a snip method is available which will output the\ngiven number of documentation lines and then enter a message to indicate that\nthe remainder of the output has been snipped for efficiency. Here is an example of how to use it, here the comments generated by the contained\nsection will be limited to 10 lines: snip 10 do # Download some verbose LRE code here end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/introduction/": {
    "title": "Introduction",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator Introduction Origen was initially conceived to be a pattern generator and as you would\nexpect it provides\npowerful APIs to generate tester patterns from your device models.\nThese APIs endeavour to abstract as much of the underlying ATE API as possible\nso that quite often all that is required to switch ATE platforms is to change\nthe tester model instantiated by the environment. With Origen, an application can also easily create custom tester\ndrivers which (for example) can be used to generate patterns in a format that\ncan be run on\nthe bench (as a J-Link command file for example) or in a functional\nsimulation - basically generating your pattern as a Verilog stimulus file. Origen is a simulation-less pattern generation tool and it is therefore very\nquick and lightweight compared to more traditional simulation-based pattern generation\nworkflows.\nWhen combined with the growing number of quality Origen plugins that are available to provide common hardware (e.g. JTAG) and protocol drivers\n(e.g. ARM Debug, Nexus), the speed of pattern development that can be\nachieved with Origen is unrivaled. With a bit of practice you can literally go from\nnothing to a working pattern for a new application within 10 minutes. Use Simulations for What They Are Good At Simulations still have their place, after all they are the only way to get pre-silicon\nfeedback on whether a given pattern will actually work or not.\nAn Origen-based workflow can still make heavy use of simulations for pre-silicon\nvalidation of test IP, however the downsides of requiring a simulation to actually\ngenerate a pattern (workflow complexity, slow generation times) are removed. This leads to much quicker turn around of pattern changes, which means that they can be regenerated\nin real time while debugging on the tester. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/j750/": {
    "title": "J750 API",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator J750 API Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/name/": {
    "title": "Generating by Name",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator Generating by Name In a large application the number of pattern source files can grow very large, for example in the\nflagship Origen application we grew to having more than 1500 pattern source files \nat one time!\nIn such a case even if you follow the golden rules for building maintainable patterns the fact that there are so many of them becomes a maintenance concern by itself and\nworries start to creep in about whether all of the patterns really implement a given operation\nin exactly the same way. Even if you don’t have so many patterns it can still become tedious to have to manually\ncreate the pattern every time a new test is added or modified, wouldn’t it be nice if\nthe pattern just created itself?! With Origen this is possible as long as your patterns lend themselves to being fully described\nby a naming convention. In short if it is possible to uniquely describe your pattern behavior\nwith a name then it is possible to synthesize that pattern from that name - this is goal of\nsourceless pattern generation with Origen. This feature is particularly powerful when combined with the Origen program generator , since it means that\nyour test program flow file becomes the only place where you define a test and the program\ngenerator will output a list of required pattern names. This can then be passed to the pattern\ngenerator which can synthesize all of the patterns without needing to create any pattern\nsources at all.\nOnce you have invested some time in building a test program interface and sourceless\npattern capability you can get to the point where to create a new test all you need to do\nis add a single line to the test flow and you are done! That level of automation and\nefficiency is simply not possible from any other test engineering framework. Enabling Name-Based Generation This feature is enabled via the before_pattern_lookup callback which will be called immediately\nbefore Origen looks for a pattern source for the given pattern generation request.\nIf this method returns false then Origen will cease processing that pattern and will\nassume that the application has dealt with the request. If the method returns\nthe requested pattern name then the regular pattern lookup and generation flow\nwill proceed as normal. It is recommended that you create a dedicated class called a pattern dispatcher within\nyour application which will handle deciding whether or not a pattern request\ncan be synthesized without a source file and then if so handle the synthesis and\ngeneration. Add these lines to your application.rb file to engage a pattern dispatcher\n(where MyApp is your application’s namespace): # config/application.rb def before_pattern_lookup (requested_pattern) MyApp :: PatternDispatcher .new.dispatch_or_return(requested_pattern) end Then create an initial pattern dispatcher shell like this: # lib/my_app/pattern_dispatcher.rb module MyApp class PatternDispatcher def dispatch_or_return (requested_pattern)\n requested_pattern end end end This initial dispatcher simply returns the requested pattern name, therefore Origen will\nbehave as normal and look for a source file for every pattern request. Even if you adopt sourceless pattern generation for your application it is likely that\nyou will still want to support conventional generation as well - having the ability\nto quickly hack together a engineering pattern at short notice is something that is\nmost easily achieved by making a dedicated pattern source file. So the first question is what should be the default behavior - sourceless or lookup? If sourceless is the default then you can implement a convention where if a pattern\nname contains ‘custom’ then a source file will be expected. If lookup is the default\nthen you could have the opposite convention where ‘nosrc’ in the pattern name means\nthat it should be generated without a source. Let’s go with sourceless being the default, here is how to modify the dispatch_or_return method to do that: def dispatch_or_return (requested_pattern) # If the pattern name contains 'custom' just return the name to have Origen lookup a source file for it if requested_pattern =~ / custom / requested_pattern else generate(requested_pattern) false # Return false to Origen to prevent std pattern dispatch end end def generate (requested_pattern) # Logic to generate the pattern to be added here end Now you can see the influence of the pattern dispatcher for the first time, any requests\ncontaining ‘custom’ will be processed as normal and any requests without this will\ndo nothing. How to Generate a Pattern A pattern can be generated from within the dispatcher in much the same way as it is\ngenerated within a regular pattern source file. Here our generate method will now produce an empty pattern: def generate (requested_pattern) Pattern .create( name : requested_pattern) do # Logic to generate the pattern to be added here end end Within the Pattern.create block you can call the exact same methods\nthat you would use in a regular pattern source, the difference of course is that\nhere we want to dynamically create them based on the name rather than hard-coding\nthem for a specific pattern. By going this route you also have to currently pick up a bit more responsibility\nfor pre-processing the requested pattern name. For example via the regular\ndispatch mechanism Origen will clean up the name to remove things like a path,\nfile extension, and pre and post-fixes that may or may not be present. In other\nwords Origen allows you to very flexible over what name you request, for example\nthese are equivalent: origen g bistcom\norigen g output/p2/nvm_bistcom_debug.atp In due course the internal Origen methods may be exposed via an API, but for now\nyour pattern dispatcher will have to deal with it (if you want to continue to\nhave this flexibility). Here is an example method that you can use for this: def generate (requested_pattern)\n requested_pattern = clean_pattern_name(requested_pattern) Pattern .create( name : requested_pattern) do # Logic to generate the pattern to be added here end end def clean_pattern_name (name)\n name = Pathname .new(name).basename.to_s # Strip path name.sub!( / \\. .* / , \" \" ) # Strip any and all extensions name.sub!( / ^nvm_ / , \" \" ) # Strip prefix, this will unique to your app, here 'nvm_' is removed name.sub!( / _debug$ / , \" \" ) # Strip postfix, again unique to your app, here '_debug' occurring at the end is removed name end Now you should be able to create (albeit empty) patterns via your dispatcher in the\nsame way as via the regular generator. Renaming Your Patterns to Make Parsing Easier To generate patterns by name you obviously need to have a comprehensive naming convention\nfrom which the behavior of each pattern can be fully described, you may even have\nthis already in place. However what is easy for a human to parse from a naming convention is not necessarily\neasy for a computer.\nFor example your patterns may have the general format: <parameter set>_<operation>_<identifier>_<block> Here are a couple of examples: prb_pgm_ckbd_b0 # Program a checkerboard to block 0, using probe parameters\nft_pgm_ckbd_b0 # Program a checkerboard to block 0, using FT parameters That’s fine, but what if these are allowed: pgm_ckbd_b0 # Program a checkerboard to block 0, using default parameters\npgm_ckbd_20us_b0 # Program a checkerboard to block 0, using default parameters + 20us programming time Again easy enough to understand, but we have just introduced somethings that will be\ndifficult to interpret by our pattern dispatcher. Firstly how do we know if ‘pgm’\nis a reference to an operation or a parameter set? One initial way to deal with it is to say that unspecified defaults are not allowed,\nbut that would quickly get out of hand as it would mean that every pattern would need\nto declare every variable which is not realistic. So we need a way to unambiguously say\nfrom the pattern name what each field represents. Similarly in the 2nd example we have further qualified the program operation with ‘20us’,\nbut again this is going to add a lot of complexity to our parser - what does that field\nreally represent? Is it program time, settling time, something else? Once again attaching\nsomething to the field name is going to really help us out when it comes to parsing and\ngenerating the pattern. So how can we re-write these examples to make our lives easier. Well one of the existing\nfields already has a good example for us. In the patterns above we have ‘b0’ which has\nunwittingly created the convention that a block reference within a pattern will consist\nof ‘b’ followed by a number. This is exactly the kind of thing that we can deal with easily. So extending that convention to prefix each field with a short mnemonic describing what it\nrefers to we end up with: paraprb_oppgm_patckbd_b0 # Program a checkerboard to block 0, using probe parameters\nparaft_oppgm_patckbd_b0 # Program a checkerboard to block 0, using FT parameters\noppgm_patckbd_b0 # Program a checkerboard to block 0, using default parameters\noppgm_patckbd_tprog20_b0 # Program a checkerboard to block 0, using default parameters + 20us programming time So we have paid a penalty here with a pattern name that is a bit more verbose than it really\nneeds to be, but it is a small price to pay for being able to drop pattern sources\ncompletely and to end up with a relatively simple pattern dispatcher. Parsing the Pattern Name To create an automated pattern dispatcher you are going to have to get familiar with\nregular expressions (regexs). Providing a tutorial on this is beyond the scope of this guide, but\na Google search for ‘regular expression tutorial’ should yield many resources to learn\nfrom. The following website is highly recommended to keep close by while developing your\ndispatcher - www.rubular.com . Aside from having a quick reference\nguide to the Ruby regex syntax it has a live panel which you can paste in your pattern name\nand then experiment with the regex to ensure the correct thing is matched.\nBest of all you can even save a given regex setup and\npaste the link into into your code comments for future reference. The parsing methods you will need to implement are very much dependent on your application and\nnaming convention, however a good way to get started is to\ndefine a method to handle each field. This breaks down the parsing into manageable chunks\nand also gives you a convenient place to set defaults.\nHere are some examples\n(here assuming that the requested pattern\nhas been assigned to an instance variable by upstream code): # An example of a required field def operation if @requested_pattern =~ / (^|_)op( \\w +?)(_|$) / $2 else raise \" No operation was contained in pattern: #{ @requested_pattern } \" end end # An example of an optional field with a default def parameter_set if @requested_pattern =~ / (^|_)para( \\w +?)(_|$) / $2 else \" default \" # Use the 'default' parameter set if not specified end end # An example of an optional field that returns nil if not present, a default # may or may not be assigned later within the patgen logic def block if @requested_pattern =~ / (^|_)b( \\w +?)(_|$) / $2 end end No doubt the regex code may look a bit daunting at first and unfortunately regexs are\nunusual in that they tend to be easier to write than they are to read!\nHowever we have basically used the same regex in all of the above examples and most likely\nyou could parse your entire pattern name like that. Here is a walkthrough of how it works: string =~ // This is basic format of a regex, you can read this as\n \"does some section of the string match the rules inside //\". /(^|_)para(\\w+?)(_|$)/ This means the start of the string ( ^ ) or an underscore... /(^|_)para(\\w+?)(_|$)/ ...followed by the op code that we are trying to match. /(^|_)para(\\w+?)(_|$)/ Then we have the section that we want to capture. \\w means a\n word character, that is a letter, number or unfortunately an underscore.\n The + means one or more of the previous characters. Since the \\w rule includes underscores by default this will match as many\n occurences as possible, so it would continue matching through the next underscore\n and into the next field, this is called a 'greedy' match. To prevent this we\n add the ? which tells it to match as little as possible, sometimes\n called a 'lazy' match.\n This whole section is surrounded in parenthesis which means 'capture the values\n that correspond to this section'. /(^|_)para(\\w+?)(_|$)/ Finally stop at the end of the string ( $ ) or an underscore. Our regex contains 3 sets of parenthesis, the part of the string that matched this\nsection is available at the end via the variables $1 , $2 and $3 . The field we want to capture is in position two and therefore\nour parse methods return this. Here are links to see each of these in action and for you to experiment with: operation parameter_set block As a final optimization note, with ruby parameters can be used in regexs in the same\nway they can be used as strings, so actually we could abstract the regex portion of the\ncode to a method like this: def extract (op_code) if @requested_pattern =~ / (^|_) #{ op_code } ( \\w +?)(_|$) / $2 end end def operation extract( \" op \" ) || raise( \" No operation was contained in pattern: #{ @requested_pattern } \" ) end def parameter_set extract( \" para \" ) || \" default \" end def block extract( \" b \" ) end Putting it All Together Now that we can generate a list of build options from the requested name we can start to\ngenerate the pattern. One of the first jobs of the dispatcher is to generate the list of options\nthat should be passed into Pattern.create , in our example let’s say that\nthe parameter set option is passed into our startup method via Pattern.create . We can now do this by simply calling our parameter_set method: def generate (requested_pattern)\n requested_pattern = clean_pattern_name(requested_pattern) Pattern .create( name : requested_pattern, parameter_set : parameter_set) do # Logic to generate the pattern to be added here end end What happens inside the pattern block very much depends on your application patgen API\nand if you are creating this from scratch\nsome thought should be given to designing it to lend itself to pattern synthesis.\nIn the flagship Origen application where this technique was first developed the original\nAPI was not at all designed with this in mind. This led to an extremely complex pattern\ndispatcher being required to handle all of the corner cases. To make life simpler for pattern synthesis it is recommended that the API is kept very simple\nwith only a few methods being made available and all customization of the operation being\ndone via an options hash. So for example a good API to handle our program checkerboard example might be: Pattern .create( params : :ft ) do $dut .nvm.pgm( pattern : :ckbd , tprog : 20 , block : 0 ) end Which could then be synthesized via the following method: def generate (requested_pattern)\n requested_pattern = clean_pattern_name(requested_pattern) Pattern .create( name : requested_pattern, parameter_set : parameter_set) do $dut .nvm.send operation, pattern : pattern, tprog : tprog, block : block end end Even simpler would be: Pattern .create( params : :ft ) do $dut .nvm.execute( operation : :pgm , pattern : :ckbd , tprog : 20 , block : block) end And the equivalent synthesizer method: def generate (requested_pattern)\n requested_pattern = clean_pattern_name(requested_pattern) Pattern .create( name : requested_pattern, parameter_set : parameter_set) do $dut .nvm.execute operation : operation, pattern : pattern, tprog : tprog, block : block end end A clear pattern is starting to emerge now that for every supported option we have\na matching method of the same name in our dispatcher, so we can optimize this a bit: OPTIONS = %w( operation pattern tprog block ) def generate (requested_pattern)\n requested_pattern = clean_pattern_name(requested_pattern)\n options = {} OPTIONS .each do |option|\n options[ :option ] = self .send(option) end Pattern .create( name : requested_pattern, parameter_set : parameter_set) do $dut .nvm.execute(options) end end Now if we want to add support for a new option we just add it to the OPTIONS array and create the corresponding parse method. We can probably go one better. As we have seen the parser methods are all very similar, do we really need them? Not really as long as we are willing to defer default setting and error checking to our\nmodels (where it probably makes more sense anyway). Here is a complete pattern dispatcher in around 30 lines of code, where if you want to\nadd support for another field in the future just add it to the OPTIONS definition that maps the option name to the pattern name op code: # lib/my_app/pattern_dispatcher.rb module MyApp class PatternDispatcher OPTIONS = { operation : \" op \" , pattern : \" pat \" , tprog : \" tprog \" , block : \" b \" ,\n } def generate (requested_pattern) @requested_pattern = clean_pattern_name(requested_pattern)\n options = {} OPTIONS .each do |option, op_code|\n options[ :option ] = extract(op_code) end Pattern .create( name : @requested_pattern , parameter_set : extract( \" para \" )) do $dut .nvm.execute(options) end end def extract (op_code) if @requested_pattern =~ / (^|_) #{ op_code } ( \\w +?)(_|$) / $2 end end def dispatch_or_return (requested_pattern) # If the pattern name contains 'custom' just return the name to have Origen lookup a source file for it if requested_pattern =~ / custom / requested_pattern else generate(requested_pattern) false # Return false to Origen to prevent std pattern dispatch end end def clean_pattern_name (name)\n name = Pathname .new(name).basename.to_s # Strip path name.sub!( / \\. .* / , \" \" ) # Strip any and all extensions name.sub!( / ^nvm_ / , \" \" ) # Strip prefix, this will unique to your app, here 'nvm_' is removed name.sub!( / _debug$ / , \" \" ) # Strip postfix, again unique to your app, here '_debug' occurring at the end is removed name end end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/pins/": {
    "title": "Pins",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator Pins The control of pin states represents the lowest level of Origen’s pattern generation\nAPI. Generally for most modern applications you should need to do this very rarely\nand mainly when creating mode entry and reset sequences for your\ndevice.\nFor most applications a plugin such as the JTAG driver should be used to\nabstract much of the lower level details about the values to be applied to a given\npin by a given test vector.\nIf your application uses a proprietary interface then it is recommended that you\ncreate a dedicated class to implement the interface\nprotocol and to deal with all of the manipulation of pin states. Basic Concept All of Origen’s vector-based tester models will support a cycle method\nwhich will drive or expect the current values held by all pins for one clock cycle.\nIn other words the cycle method takes a snapshot of the current pin states and then\napplies them to the DUT. Origen’s pin API provides models that represent a DUT’s pins and pin groups\nand methods with which to manipulate their states between tester cycles. See the Pins section of\nthe Models guide for details and examples\nof how to add and manipulate pin states within your model logic. Recommended Architecture Here are the key components of the recommended architecture: All pins and aliases are defined within the top-level models only, the top-level model is the only object\nthat owns pins in the entire application for a given target setup. Functions should be added to the pins to represent the different functionality available\non the pins depending on the mode. The availability of the required functions is a contract between a given sub-model\nand the top-level, i.e. the NVM models and test logic assume that all top-level models will\nprovide functions named nvm_fail and nvm_done . Each model only refers to the pins using the name/function that it understands. The test block/plugin that is primarily responsible for a given test pattern\ncan still control the pin order of the created pattern by using the pin_pattern_order method. The above approach has the benefits of encapsulating all pin definitions within the top-level model, so\nthat a device’s TE could implement the details straight from the top-level DFT guide for example, while the lower level\nmodules can talk to the pins/signals that they know about. Here is an example of how to implement this scheme in a top-level SoC model: class MySoC include Origen :: TopLevel def initialize (options)\n instantiate_pins(options) end def instantiate_pins (options) # Common pins required by all to support mode entry sequences add_pin :tclk , reset : :drive_lo add_pin :trst , reset : :drive_hi add_pin :extal add_pin :xtal , reset : :drive_lo add_pin :tms add_pin :tdo add_pin :tdi add_pin :resetb add_pins :data , size : 8 # Add NVM BIST mode functions pin( :extal ).add_function :nvm_clk pin( :data )[ 2 ].add_function :nvm_fail pin( :data )[ 3 ].add_function :nvm_done pin( :data )[ 4 ].add_function :nvm_invoke # Add additional function groups here... end end Controlling the Pattern Pin Order As a test engineer for a specific test module you may want more importance to be given to some pins\nthan others, or to otherwise order them to make them most readable for debugging the target module. This can be achieved by calling the pin_pattern_order method: class NVM include Origen :: Model def initialize # Unspecified pins will appear in arbitrary order at the end pin_pattern_order :nvm_clk , :nvm_invoke , :nvm_done , :nvm_fail end end Aside from specifying the order of the pins this also specifies what the name should be, i.e. if a given\npin/pin group has multiple aliases then the one used to refer to the pin in the pin_pattern_order is that one that will appear in the generated pattern. By default any unspecified pins will appear in arbitrary order at the end. To include only the pins\nspecified then append the :only option at the end: # Only include these pins in the output pattern and in this order pin_pattern_order :nvm_clk , :nvm_invoke , :nvm_done , :nvm_fail , only : true Alternatively specific pins or pin groups can be excluded from appearing in the output file via\nthe pin_pattern_exclude method: # Don't include these pins in the pattern pin_pattern_exclude :porte , :portf An error will be raised if the same pin appears in both pin_pattern_order and pin_pattern_exclude . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/registers/": {
    "title": "Registers",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator Registers The majority of patterns are concerned with reading and writing to registers to make the\nDUT do something and consequently \nmore than 90% of your time developing an Origen test application should be concerned with\nwriting code at the register level. All test transaction drivers such as the ARM Debug driver are expected to support the basic\nOrigen register API. This allows the test engineer to develop code at register level and\nindependently of the underlying test communication protocol which can be easily changed\nto something else as required. Basic Concept See the Registers section of\nthe Models guide for details and examples\nof how to add and manipulate register states within your model logic. Interaction with the registers should be limited to the model’s controller - no one else should reach into a model to manipulate its register state (this is not prevented\nbut recommended), and the controllers should instead expose interface methods for the outside\nworld to use. Internally such methods will work by manipulating registers in a sequence. The read! and write! methods when called on a register (or bit) will\nautomatically fire off a request for the register to be written using the following\nrules: If the model or controller that owns the register implements a write_register method\nthen call this with the target register passed in as the argument Otherwise if the object that owns the register implements an owner method,\nthen see if the object that this returns provides a suitable write_register method If not then if a currently instantiated model includes the Origen::TopLevel module then see if it (or its controller) has a write_register method available If the request has still not been fulfilled then raise an error Read works in the same way except that it looks for a method called read_register . What this all means is that within a controller you will build your\ntest logic from methods that look like this: def measure_vref (setting= nil ) if setting\n ss \" Measure the Vref voltage for setting #{ setting } \" vref.level.write(setting) else ss \" Measure the default Vref voltage \" end vref.test_enable.write!( 1 ) end # From a pattern call like this: Pattern .create do $dut .nvm.measure_vref( 5 ) end The actual mechanism for how the registers are written is abstracted away from the\ntest logic itself and therefore the test logic is generally independent from the communication\nprotocol. This is a very powerful concept that allows plugins to be created that provide \ntest sequences for a specific silicon module and these can then be re-used on DUTs that\nemploy completely different register access protocols. Recommended Architecture This is the recommended architecture for modern Origen applications that will lend itself\nto working well within a plugin-based environment. Define registers in the child models that own them and create test methods to manipulate them\nin the controller: class NVM include Origen :: Model def initialize reg :vref , 0x0003 , size : 16 do |reg|\n reg.bit 15 , :test_enable reg.bit 7 .. 0 , :level end end end class NVMController include Origen :: Controller def measure_vref (setting= nil ) if setting\n ss \" Measure the Vref voltage for setting #{ setting } \" vref.level.write(setting) else ss \" Measure the default Vref voltage \" end vref.test_enable.write!( 1 ) end end Defer how to actually write the register to the top-level SoC controller and normally this would\nbe done via one of the available protocol plugins.\nHere for example is an SoC which will write the register via the Nexus protocol : class MySoC include Origen :: TopLevel # Indicate to Origen that this model represents a top-level device object end class MySoCController include Origen :: Controller include Nexus # Process register reads using the Nexus protocol def read_register (reg, options={})\n nexus.read_register(reg, options) end # As above for write requests def write_register (reg, options={})\n nexus.write_register(reg, options) end end And that is all that is required, Origen takes care of the hook up and the behind the scenes\ncommunication to make it all work. Another target may then instantiate a different SoC model which could use a completely different\nprotocol like ARM Debug , in which case the NVM test module would\nstill work although the generated pattern would look completely different. Bit Level Access All registers support bit level updates, we have seen an example of this already: vref.test_enable.write!( 1 ) What this will do is update the value held by the given bits and then send the parent\nregister object to the write_register method for processing.\nAll other bits in the register will maintain the state that they had prior to this\noperation commencing. Since it is not generally possible to update only a subset of bits on a device the entire\nregister will still be updated on silicon.\nHowever in the case of performing a bit-level read things get a bit more interesting. The equivalent read operation will update the data values of the bits in the same way, but\nit will also set a flag on those bits marking that they have been requested for read. vref.test_enable.read!( 1 ) The protocol driver can then look out for this flag when generating the readout vectors\nand only enable a compare on the vectors that correspond to the bits marked for read.\nGenerally this takes a lot of the cognitive overhead out of writing patterns since you\ncan mentally disregard the state of all bits except the ones that you care about. All standard Origen protocol plugins are expected to support this feature. The same is true for store (meaning capture the value on the tester) or overlay operations: # Capture the value of the level bits vref.level.store! # Dynamically overlay the value written to the level bits vref.level.overlay( \" vref_setting \" )\nvref.write! Writing a Driver Generally the code for an existing driver should be reviewed to see how to go about this,\nthe JTAG driver would be a good example to look at,\nbut here are some basic pointers on good driver design. All drivers should implement read and write register methods: def write_register (reg, options={}) end def read_register (reg, options={}) end The write methods are usually fairly simple, here is a basic example of how to do a parallel\nand a serial protocol write: # Writing on a parallel port, let's say we have a 16-bit register and the # data needs to be written on a pin group called data which is 8-bits def write_register (reg, options={})\n pin( :din ).drive( 1 ) # Let's say when this pin is high data is captured # Drive the data in MSB -> LSB order pins( :data ).drive!(reg[ 15 .. 8 ].data)\n pins( :data ).drive!(reg[ 7 .. 0 ].data)\n pin( :din ).drive( 0 ) # Turn off capture end # Writing on a serial port, same as above only this time the :data port is # only 1-bit wide def read_register (reg, options={})\n pin( :din ).drive( 1 ) # Let's say when this pin is high data is captured # Drive the data in MSB -> LSB order reg.shift_out_left do |bit|\n pin( :data ).drive!(bit.data) end pin( :din ).drive( 0 ) # Turn off capture end Read methods are usually a bit more involved to implement the bit-specific read and\ncapture operations.\nHere is a parallel and serial protocol example which supports bit-level read operations: # Reading on a parallel port, let's say we have a 16-bit register and the # data needs to be read on a pin group called data which is 8-bits def write_register (reg, options={})\n pin( :dout ).drive( 1 ) # Let's say when this pin is high data is presented # Compare the data in MSB 8 .times do |i|\n bit = reg.bit(i + 8 ) if bit.is_to_be_read?\n pins( :data )[i].assert(bit.data) else pins( :data )[i].dont_care end end $tester .cycle # Now the data in LSB 8 .times do |i|\n bit = reg.bit(i) if bit.is_to_be_read?\n pins( :data )[i].assert(bit.data) else pins( :data )[i].dont_care end end $tester .cycle\n\n pin( :dout ).drive( 0 ) # Turn off read out end # Reading on a serial port, same as above only this time the :data port is # only 1-bit wide def read_register (reg, options={})\n pin( :dout ).drive( 1 ) # Let's say when this pin is high data is presented # Drive the data in MSB -> LSB order reg.shift_out_left do |bit| if bit.is_to_be_read?\n pin( :data ).assert!(bit.data) else pin( :data ).dont_care! end end pin( :dout ).drive( 0 ) # Turn off read out end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/running/": {
    "title": "Running The PatGen",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator Running The PatGen The pattern generator is launched via the Origen generate command, see the command line\nhelp to get details of the most up to date options: origen generate -h As this is such a commonly used command it has a short cut alias: origen g -h The generator can be run on a single file: origen g pattern/ram/march.rb It can also be run without a path and by just supplying a name, Origen is also pretty flexible\nwith regards to file extensions and pre and post fixes and in most cases it should do a good\njob of finding the pattern that you want: origen g march It can also run on a whole directory: origen g pattern/ram Pattern list files can also be used, by convention these should be kept in the list directory\nand should have the extension .list : origen g list/production.list Here is an example of a list file: # List files can be commented like this\n# Simply list the name of the patterns that you would use on the command line\nmarch.rb\ndata_retention.rb\n# List files can also call other lists\nprobe.list By default the generated patterns will be put in output or whatever directory\nis returned by the config.output_directory attribute in application.rb . Submit to the LSF by appending -l and optionally interactively\nwait for completion: origen g list/production.list -l -w Regression Testing Every time Origen generates a pattern it will check to see if it has generated it before, and\nif so it will compare the current version to the previous version and alert if there is a\ndifference. This can be used to check for regressions when making changes that you don’t want\nto affect the output, or to verify that the change is what you intended in cases where you\nare intentionally modifying the output. The diff is a smart diff and will not care about any changes to comments, only about changes\nthat will affect the pattern’s operation. In the case of a difference being found Origen will automatically present you with the diff command\nto run if you want to view the change. To accept changes or to start tracking the differences in a pattern (or patterns) run the following command\nafter generating: origen save all Programmatically Launching the Generator If you start writing your own commands you may want\nto launch the generator from Ruby, do that as follows: Origen .app.runner.launch action : :generate , files : \" list/production.list \" This can be combined with Target Loops to run the\ngenerator for multiple targets. A generate job can also be posted to the LSF by supplying the same options that you would use\non the command line like this: Origen .lsf.submit_origen_job( \" g march \" ) Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/timing/": {
    "title": "Timing and Waiting",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator Timing and Waiting This guide gives an overview of some of the most common timing related\nmethods, but to get a complete overview of what is available consult\nthe OrigenTesters::Timing API . A timeset declaration is used to provide information to Origen about what\ntimeset to use for future test cycles and what period of time each\ncycle represents. Normally this would be initialized within the startup method before generating any\nvectors as shown below: class MySoCController include Origen :: Controller def startup (options) $tester .set_timeset( \" mode_entry \" , 40 ) end end The first argument is the name of the timeset, this should correspond to\nhow the timeset will be named within the test program, and the second argument\nis the cycle period in nano-seconds. This method also accepts a block in which case the contained vectors will generate\nwith the supplied timeset and subsequent vectors will return to the previous timeset\nautomatically. $tester .set_timeset( \" bist_50mhz \" , 20 ) do # Any cycles generated in here will use 20ns for the period end The arguments can also be supplied as a single array, or not at all. In the latter case\nthe existing timeset will simply be preserved. This is useful if you have timesets that\ncan be conditionally set based on the target. # Target 1 $dut .readout_timeset = [ \" readout \" , 120 ] # Target 2 $dut .readout_timeset = false # This code is compatible with both targets, in the first case the timeset will switch # over, in the second case the existing timeset will be preserved. $tester .set_timeset( $dut .readout_timeset) do # Generate readout vectors... end Creating a Timing Set Currently the creation of the timing set for a given test platform must be\ndone independently of Origen, however adding an Origen API for this is on the roadmap. Waiting All $tester models will support the following API to generate wait states\nin the test patterns. Wait for specific number of cycles: $tester .wait( cycles : 1000 ) Wait for a period of time: $tester .wait( time_in_us : 500 ) $tester .wait( time_in_ms : 10 ) Multiple times specified in different units will be added together, this can be useful\nif the delay is based on a complex calculation: # Wait for 500us + 100 cycles $tester .wait( time_in_us : 500 , cycles : 100 ) Waiting for an Event All testers provide an API for generating match loops, these can be used to\nmake the pattern wait dynamically for a pin-based or even a register-based\nevent. To do this enable the :match option and supply a block, within the block\ngenerate the vectors that will test if the condition has been met.\nAny time options passed in will be applied as a timeout, i.e. the maximum time to\nwait for the required condition to resolve. Here are some examples: # Wait for up to 1 second for the done bit to be set $tester .wait( match : true , time_in_s : 1 ) do reg( :status_reg ).bit( :done ).read!( 1 ) end # Wait for up to 1 second for the done pin to be set $tester .wait( match : true , time_in_s : 1 ) do pin( :done ).assert!( 1 ) end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/ultraflex/": {
    "title": "UltraFlex API",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator UltraFlex API Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/pattern/v93k/": {
    "title": "V93K API",
    "subtitle": "Pattern Generator",
    "body": "Pattern Generator V93K API Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/plugins/app/": {
    "title": "Config & Origen.app",
    "subtitle": "Plugins",
    "body": "Plugins Config & Origen.app Every Origen application and plugin has an object that represents it, this is returned by Origen.app and is essentially an instance of the class defined in config/application.rb . When calling Origen.app within plugin code some thought has to be given to\nwhich application you mean, do you mean the plugin itself or the top-level application\nthat it is plugged into? To deal with this ambiguity the following API exists which works the same as Origen.root : Origen .app # Returns the current top-level app instance Origen .app! # Returns the app instance associated with the code making the # call, typically use this to get a plugin's app instance Origen .app( :doc_helpers ) # Returns the app instance for the given plugin name Am I the Current Application or Plugin? A common use case for examining the application instance is to see if a plugin is\nrunning standalone (in its own development workspace) or if it is running fully deployed as a plugin\nto a wider application. The following code can be used in this case: if Origen .app!.current? # The plugin is running standalone in its own workspace (I am the current application) else # The plugin is running as a component in a parent application end A further question can arise if the plugin is found to be running as a component in a\nparent application: ‘am I the current plugin?’ To test for this: if Origen .app!.current_plugin? # Do something special when I am the current plugin else # Sigh, just another run-of-the-mill plugin end Overriding the Application Config Some config options have the ability to be overridden by the current plugin,\ne.g. config.pattern_prefix will be set by the plugin that owns the pattern\nand not the top-level application. See ATTRS_THAT_CURRENT_PLUGIN_CAN_OVERRIDE in the Configuration API for a complete list of the config options that fall into this category. If the current plugin does not provide a value for a given config option then the value\ndefined by the top-level application will be used instead. Typically a rich plugin which provides patterns and similar IP to an application will\ncontain logic like this in its config/application.rb : # If this app is running standalone then it supports multiple devices and so in that # case namespace the output by device type. However if running as a plugin then it # will be in a single device app, in that case put everything in the 'atd' directory config.output_directory do if current? # If app is running standalone (i.e. not as a plugin) \" #{ Origen .root } /output/ #{ dut.class } \" else \" #{ Origen .root } /output/atd \" end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/plugins/creating/": {
    "title": "Creating a Plugin",
    "subtitle": "Plugins",
    "body": "Plugins Creating a Plugin Origen plugins are essentially Origen applications themselves.\nFollow the standard instructions to Create a New Application and choose one of the available plugin templates rather than an application template. Understanding How Plugins are Loaded For the purposes of this guide let’s say we are creating a plugin called ATDTest and this would have a top-level lib file called lib/atd_test.rb . When a plugin is run from its own workspace, we would call this running in standalone or development\nmode, then it is loaded like any other Origen application.\nThe first thing Origen does in this case is to load the plugin’s gem bundle, defined in its Gemfile ,\nand then boot the plugin by loading config/boot.rb . Normally such a file will look like this: # config/boot.rb require ' atd_test ' So by default this simply loads the plugin’s top-level file which in this example is lib/atd_test.rb . However when the plugin is loaded as part of a parent application, neither the plugin’s Gemfile or\nits config/boot.rb file will be loaded.\nInstead the parent application’s Gemfile will be loaded, and this will contain\na reference to our plugin. The tool that evaluates the Gemfile, called Bundler , will\ninspect our plugin’s gemspec file (in this example atd_test.gemspec ) and\nit will ensure that any dependencies listed there are met. Once the gem bundle has been created\nit will then load our plugin’s top-level file, lib/atd_test.rb . The take away from this is that the following rules should be observed when creating plugins: Load all of your plugin’s code from it’s top-level file ( lib/atd_test.rb ), if that requires\nall of the lib code you wish to share with your users then they will not need to do anything except\nadd your plugin to their Gemfile . The plugin’s config/boot.rb file should only be used for loading any code which is for testing\nonly or for otherwise running your plugin within its own workspace environment. The plugin’s Gemfile should not be used. This should contain a line that calls gemspec which tells Bundler to refer to the plugin’s gemspec file instead, e.g. atd_test.gemspec . This\nprevents you from having to maintain the plugin’s gem dependencies in two separate locations. The plugin’s gemspec should be used to declare all of its gem dependencies as shown below. Note that plugins\nmust never specify an absolute version of gems in its runtime dependencies. # atd_test.gemspec # Declare any dependencies that the plugin will need when it is running within a parent application. # Never specify an absolute version since that can easily conflict with other plugins if they did the # same. Instead specify a range, normally just a minimum version that you need. spec.add_runtime_dependency \" origen_jtag \" , \" >= 1.1.0 \" # Declare any dependencies that the plugin need when running in standalone/development mode only, a # very common example is the documentation helpers plugin. This is only required to build the plugins # web pages, but it is not required at runtime. # Note that absolute version numbers are allowed here since this does not apply outside of this plugin. spec.add_development_dependency \" origen_doc_helpers \" Sharing Models and Other Lib Code The plugin’s lib directory will be automatically added to the Ruby load path\nno special consideration is required to expose lib code to the parent application.\nIn our example the parent application will be able to load\nany of our code like this: require ' atd_test/atd_16b ' However as noted above the plugin’s top-level file, lib/atd_test.rb will be automatically\nloaded, therefore it is the usual convention to have this file require everything else so that the parent\napplication does not need to manually require anything. Sharing Other IP To share source files, templates and commands the plugin must define config.shared in\nits config/application.rb file, here is an example that will share everything: config.shared = { :patterns => \" pattern \" , :templates => \" templates \" , :programs => \" program \" , :command_launcher => \" config/shared_commands.rb \" } Access can be restricted by specifying a sub-directory, or by simply\nremoving the given resource: # Only share a subset of patterns (those that live within the pattern/shared directory, those # in pattern/development for example would not be available to the host application) config.shared = { :patterns => \" pattern/shared \" , # :templates => \"templates\", # :programs => \"program\", # :command_launcher => \"config/shared_commands.rb\" } Sharing Templates The host application can reference a template from an added\nplugin by using the plugin’s name as a pointer to the\nshared template directory (the directory specified in the plugin’s config.shared[:templates] attribute),\nand then a relative path from there to the required template. For example the doc_helpers plugin contains a test flow layout template at templates/shared/test/_flow.md.erb , and an importing\napplication would reference this template via the path doc_helpers/test/_flow.md.erb . Sharing Pattern and Program Sources When test pattern and program directories are shared Origen will look within these for\nthe requests patterns/flows whenever the given plugin is designated as the\ncurrent plugin. See the Current Plugin for more detail on this. For example say our plugin is called atd_test and it provides a pattern\ncalled atd_ramp.rb , then\nit could be generated like this from the parent application workspace: origen pl atd_test\norigen g atd_ramp Alternatively you can override the current plugin at runtime like this, this is\nequivalent to the above: origen g atd_ramp --plugin atd_test Program generation source files work from exactly the same principles. Note that since there is currently no easy way to view a list of all patterns provided\nby a plugin, it is conventional for the plugin to provide custom commands to generate\na complete set of patterns, e.g. something like this: origen atd_test:prod_pats # Generate all production patterns from the ATD plugin\norigen atd_test:prod_prog # Generate the production test program from the ATD plugin Sharing Commands To share custom commands supply a path to a command definition/launcher file within the plugin\nas shown in the example above. This file works very similar to the way that custom commands are added to an application. Here is an example command launcher file from a real plugin, this adds a custom\ncommand, origen atd_test:j750 , to the host application and also extends the origen g command by adding an additional option to it. Note the use of Origen.root! and Origen.app! to refer to the plugin’s own root\nand application instance rather than that of the host application. Also note that the command has been called atd_test:j750 instead of just j750 , this is to ensure that there is no naming collision with commands\nthat could be added by other plugins.\nIn future Origen will automatically apply a plugin specific prefix to the commands like this,\nbut until then all plugin developers are expected to be good citizens and add this manually. # config/shared_commands.rb # The requested command is passed in here as @command case @command when \" atd_test:j750 \" require \" #{ Origen .root! } /lib/commands/j750 \" # Important to exit when a command has been fulfilled or else Origen core will try and execute it exit 0 # Add an additional option to the standard generate command, important to have no exit here when \" generate \" @application_options << [ \" --md5 \" , \" Apply an MD5 checksum to pattern names \" ] Origen .app!.md5 = true if ARGV .include?( \" --md5 \" ) # Always leave an else clause to allow control to fall back through to the Origen command handler. # You probably want to also add the command details to the help shown via 'origen -h', # you can do this bb adding the required text to @plugin_commands before handing control back to # Origen. else @plugin_commands << <<-EOT atd_test:j750 Generate the ATD test program for J750 EOT end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/plugins/current/": {
    "title": "Current Plugin",
    "subtitle": "Plugins",
    "body": "Plugins Current Plugin The current plugin is a concept that comes into play whenever a plugin provides pattern\nand test program sources to a parent application. The current plugin is selected in a similar way to the current target, either at \nruntime to set the current plugin for a given job only: origen g atd_ramp --plugin atd_test or the workspace default can be set via the origen pl command: origen pl atd_test Identifying a current plugin performs two main functions: Limits the search scope when dynamically searching for pattern sources and avoids\nambiguity over which pattern is being requested Selects which application callbacks and configuration context should be enabled The first function is fairly self explanatory and means that Origen will search for the requested\npattern only within the subset of all available patterns that are owned by the current plugin.\nThe second function warrants some more discussion… Application instances (as defined in config/application.rb) are automatically registered\nas listeners into Origen’s callback system and this\nis often used to implement pattern generation features like sourceless pattern generation . That works fine when an application is running standalone, but once it starts to\nincorporate many plugin instances who can all synthesize pattern sources then we have a\nproblem over which one to choose to fulfill a given request. Similarly there could be issues when\na 3rd party callback listener kicks in when generating a completely unrelated pattern. The selection of the current plugin therefore gives Origen some help by specifying what area\nof the wider application should be enabled when generating a particular pattern.\nIdeally a more automated system would be developed for this, and it may be in future, but for\nnow the current plugin concept solves the problem and doesn’t seem to be much of an hindrance to\nuse in practice. Aside from callbacks, the current plugin selection also selects which plugin’s configuration\noverrides should be applied to a given generation job, see the plugin configuration guide for some more discussion on this. Programmatically Setting the Current Plugin The current plugin can be set in Ruby code using the below API. Origen .app.plugins.current = :atd_test # Sets the default plugin Origen .app.plugins.temporary = :atd_test # Temporarily sets the current plugin (for this thread only) Origen .app.plugins.temporary = nil # Discard the temp plugin and set it back to the default Origen .app.plugins.current.name # Returns current plugin name A common usage pattern for modern ‘BOM’ style applications is to have a target corresponding to each\nmain pattern type, which typically will correspond to the main plugins that are providing pattern\nsources to the application. The current plugin can therefore be set in the target and then forgotten about, such that it\nwill automatically be set to the correct thing based on the current target: # target/atd.rb load \" #{ Origen .root } /target/dut.rb \" # Load and instantiate the DUT Origen .app.plugins.temporary = :atd_test # target/nvm.rb load \" #{ Origen .root } /target/dut.rb \" # Load and instantiate the DUT Origen .app.plugins.temporary = :nvm_test Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/plugins/development/": {
    "title": "Dev Considerations",
    "subtitle": "Plugins",
    "body": "Plugins Dev Considerations Here are some basic development considerations that all plugin developers should\nfollow: Use Semantic Versioning Use semantic versioning (e.g. v1.2.3) for the plugin application and\nrespect the conventions.\nSee semver.org for details on what is expected. The main takeaway is that breaking API changes are only allowed when changing the\nmajor version counter. In other words an application that depends on version\n1.1.0 of your plugin, should be able to run fine under version 1.99.0. Add Tests Consumers of the plugin should not have to keep their fingers crossed or\nextensively test at their end when pulling a new version of the plugin.\nThe plugin itself needs to take responsibility for ensuring that things don’t\nbreak between releases. Tests are most easily written using diffs - create some dummy patterns\nwithin the plugin application to fully exercise all methods, then make\nsure that the output remains consistent when making changes or adding new\nfeatures. Additionally unit tests can be created using the Ruby Test::Unit or RSpec\nlibraries (new Origen apps come pre-configured for the latter out the box). Origen core already does a good job of testing using both methods described above\nand can be consulted for examples. Use Namespaces The possibilities for naming clashes will increase as more Origen code is\nimported from shared plugins, therefore all plugins should be good\ncitizens and ensure that they don’t pollute the global namespace. All classes defined within a plugin should be contained within a module\nnamed after the plugin. See the section on namespacing here for more details - Naming Models Document as You Go Users of your plugin will appreciate good documentation, the easiest way\nto do this is to document your methods via useful descriptions as you\nwrite them. These descriptions can then be automatically extracted into API\ndocumentation later. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/plugins/environment/": {
    "title": "Dev Environment",
    "subtitle": "Plugins",
    "body": "Plugins Dev Environment Your plugin development environment may need to be setup slightly\ndifferently compared to when working on a standalone application. If the plugin can function and be fully tested standalone, then no special\nconsideration is required and it can be developed like a regular application.\nHowever in some cases you may need a receiving application to\nimport the plugin to allow its\nfunctionality to be fully evaluated and tested. In that case setup up two workspaces: one for the plugin and another to be the receiving application. Within the receiving application’s Gemfile , add a path reference to the plugin\nworkspace like this: # Gemfile gem \" atd_test \" , path : \" /proj/origen_dev/thao/blocks/atd_test \" The receiving application will now be using the plugin from the workspace in exactly the same\nway as it would if it was imported through the Ruby gems system. Origen will not allow the receiving application to be tagged when a path reference is active,\nso you don’t need to worry too much about forgetting to remove it! Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/plugins/importing/": {
    "title": "Using a Plugin",
    "subtitle": "Plugins",
    "body": "Plugins Using a Plugin Plugins are distributed as Ruby gems and are added to an application as described\nhere: Understanding Gems . All plugins should provide documentation that supplies the required\ndetails, here is an example - Origen JTAG Driver Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/plugins/introduction/": {
    "title": "Introduction",
    "subtitle": "Plugins",
    "body": "Plugins Introduction Origen enables easy and wide reaching code re-use via its Plugin system. The plugin system enables models, controllers, drivers and any other Origen-based IP\nto be shared between multiple\napplications while maintaining a single centralized point of ownership\nand development. The Plugins Directory can be consulted to\nreview what plugins are currently available for use by your application. Plugins allow any code from the lib directory, any templates,\nany pattern or program sources files, or any custom commands\nto be shared between applications. Therefore plugins can be constructed to share DUT models, test program\ninterfaces, documentation layouts, VB or C code snippets, entirely\nnew Origen commands, etc., etc. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/plugins/paths/": {
    "title": "Paths & Origen.root",
    "subtitle": "Plugins",
    "body": "Plugins Paths & Origen.root As you may know Origen.root can be used to make references\nto files and paths within Origen application code. In this simple example\nthe variable my_pattern_dir will be assigned to an absolute\npath to the application’s pattern directory regardless of where the workspace\nowner has installed the application: my_pattern_dir = \" #{ Origen .root } /pattern \" However things get a bit more complicated when writing a plugin, for example\nif the above code resides in a plugin do you mean the plugin’s pattern directory\nor the pattern directory of the importing application? By established conventions Origen.root always means the root of the\ncurrent application, so in the above example the variable will always be set\nto the top-level application’s pattern directory even if the code resides in\na plugin. Origen.root! What if you are writing a plugin and you do mean to reference somewhere\nwithin the plugin’s source files? In that case the method Origen.root! can be used instead. If the plugin\nis being run in a standalone manner then the path returned will be the same as that\nfrom the conventional Origen.root . However if the plugin is invoked through\na 3rd party application then it will return the path to the plugin’s source files instead of\nthose of the importing/top-level application. Here is a simple example to illustrate this: # Lives in a plugin called 'atd_test' module ATDTest class ATD16 def root Origen .root end def root! Origen .root! end end end # Lives in the top-level application class SoC def atd @atd ||= ATDTest :: ATD16 .new end def root Origen .root end def root! Origen .root! end end # Say the top-level application has been installed to /proj/c28/workspace1 $dut = SoC .new $dut .root # => \"/prog/c28/workspace1\" $dut .root! # => \"/prog/c28/workspace1\" $dut .atd.root # => \"/prog/c28/workspace1\" $dut .atd.root! # => \"/home/thao/.origen/gems/atd_test\" Origen.root(:plugin_name) Additionally within an application it is sometimes useful to be able to refer\nto a 3rd party plugin’s root directory. This can be done by supplying the name of the\nplugin to Origen.root . An example use case of where this is useful is if you want to re-open and extend\na class that is provided by a plugin: # Ensure the original is loaded require \" #{ Origen .root( :atd_test ) } /lib/atd_test/atd16 \" module ATDTest class ATD16 def my_additional_method puts \" hello \" end end end Origen.top Origen.top always returns the absolute path to the Origen core\ninstallation regardless of whether it is called by top-level application or plugin code. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/code/": {
    "title": "Dynamic Custom Code",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator Dynamic Custom Code A big advantage that the Origen program generator has over other\ntools is that even if you need to generate a test program file that is not\nofficially supported by the generator you can easily work around it \nby dropping down to a template for that specific section of the program. A nice offshoot of this capability is that any custom code in your\ntest program (such as custom Visual Basic or C++ code for example) can be\ndynamically generated via code templates. A Dynamic VB Example Generally using templates within the context of a test program is the same\nas using them in any other context and therefore the Compiler Guide should be consulted\nfor more details on the compiler syntax that should be used. For a tester oriented example here is a snippet of some VB code that has been\nmarked up with Origen compiler directives: NUM_VREGS = <%= $dut .vregs.size %> ' Now initialize DUT variables for each site\nFor lSite = 0 To lSiteCnt\n With oDUTData(lSite)\n Call .Clear\n% $dut.vregs.each do |vreg|\n Call .AddVreg( <%= vreg.nominal_level %> )\n% end\n End With\nNext So for a device with a 1.2V and a 3V regulator this would compile to: NUM_VREGS = 2\n\n' Now initialize DUT variables for each site\nFor lSite = 0 To lSiteCnt\n With oDUTData(lSite)\n Call .Clear\n Call .AddVreg(1.2)\n Call .AddVreg(3)\n End With\nNext Whereas for a device with only a single 1.2V regulator we would end up with: NUM_VREGS = 1\n\n' Now initialize DUT variables for each site\nFor lSite = 0 To lSiteCnt\n With oDUTData(lSite)\n Call .Clear\n Call .AddVreg(1.2)\n End With\nNext Building Dynamic Code Compiling any templates that form part of your test program can be co-ordinated\nwithin a Resources file by calling the compile method.\nAny option arguments passed in will be available within the options hash within the template. Resources .create do compile \" templates/j750/vreg_funcs.bas \" , max_vdd : 5 .V end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/custom/": {
    "title": "Creating Custom Testers",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator Creating Custom Testers Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/doc/": {
    "title": "Documenting the Program",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator Documenting the Program Origen allows test descriptions to be entered quickly and easily within the\ntest flow source file, enabling a test program document to be produced that is extremely\naccurate due to it being derived from the same source as the program itself. The application must also define a documentation interface in order to do the translation\nbetween the application-specific flow API and the Origen test program documentation back end -\nthis is the exact same principle as generating an interface for a specific ATE platform. Typically creating a documentation interface is much easier than creating an ATE platform\ninterface and is discussed later in this guide .\nNote that if you don’t initially have time to set up the documentation interface you should still\ntry and document the program as described here since the code it produces will still be\ncompatible with any tester interface. Then when time allows you can setup the documentation\ninterface with the hard part of actually describing the tests already done. The Documentation Helpers plugin provides off\nthe shelf test flow helpers to render such documentation metadata as a well formatted web document. Flow Markup Flow sections and individual tests should be documented like this: # A Test Sub Module # Test flow modules like this will collapse and nest when they are included in a parent # flow via the import command. The first line will be the name assigned to the collapsible # area, the rest of these comments will be shown when it expands. **It will be parsed for # markdown.** Flow .create do # Any comments in here will attach as a description to the next test func :measure_vreg , bin : 45 , vdd : min # This is a description of what this test does #- Prefixing the line with a '-' will cause it to be private, so this is how you would #- record some implementation detail that is of interest to engineers working on this #- flow, but which is not relevant to its overall operation func :vreg_func1 , bin : 50 # All comments can contain markdown, for example # # * A bulleted # * list func :vreg_func2 , bin : 55 , iload : 50 .uA end When generated against an appropriate documentation interface and passed to the Documentation Helpers plugin, this would generate a\nflow section like this (click to expand): A Test Sub Module Test flow modules like this will collapse and nest when they are included in a parent\n flow via the import command. The first line will be the name assigned to the collapsible\n area, the rest of these comments will be shown when it expands. It will be parsed for\n markdown. Test Number HBin SBin Attributes Description measure_vreg #45000 B45 Vdd : min Any comments in here will attach as a description to the next test vreg_func1 #50000 B50 This is a description of what this test does vreg_func2 #55000 B55 iload : 50E-06 All comments can contain markdown, for example A bulleted list Documenting Structure Tests can be grouped together by wrapping them with the pp helper, here are\nthe two functional tests grouped together with some description added about what the\ngroup contains: # A Test Sub Module # Test flow modules like this will collapse and nest when they are included in a parent # flow via the import command. The first line will be the name assigned to the collapsible # area, the rest of these comments will be shown when it expands. **It will be parsed for # markdown.** Flow .create do # Any comments in here will attach as a description to the next test func :measure_vreg , bin : 45 , vdd : min # Within flow sections should be marked like this (this is the same API to indicate # structure in pattern logic to). This text will appear when the collapsible area is # shown and will be parsed for markdown. pp \" Functional Tests \" do # This is a description of what this test does #- Prefixing the line with a '-' will cause it to be private, so this is how you would #- record some implementation detail that is of interest to engineers working on this #- flow, but which is not relevant to its overall operation func :vreg_func1 , bin : 50 # All comments can contain markdown, for example # # * A bulleted # * list func :vreg_func2 , bin : 55 , iload : 50 .uA end end The functional tests will now be nested in a collapsible group: A Test Sub Module Test flow modules like this will collapse and nest when they are included in a parent\n flow via the import command. The first line will be the name assigned to the collapsible\n area, the rest of these comments will be shown when it expands. It will be parsed for\n markdown. Test Number HBin SBin Attributes Description measure_vreg #45000 B45 Vdd : min Any comments in here will attach as a description to the next test Functional Tests Within flow sections should be marked like this (this is the same API to indicate\n structure in pattern logic to). This text will appear when the collapsible area is\n shown and will be parsed for markdown. Test Number HBin SBin Attributes Description vreg_func1 #50000 B50 This is a description of what this test does vreg_func2 #55000 B55 iload : 50E-06 All comments can contain markdown, for example A bulleted list Dynamic Documentation From Helpers Helper methods can be added to your interface to generate multiple tests or to otherwise dynamically generate a\nsection of the flow. Within these methods the cc method can be used to stage comments that will be attached to\nthe next test to be generated: def program_sequence cc \" Issue a pulse \" func :program_20us cc \" Do a verify \" func :read_margin0 end Creating A Documentation Interface A documentation interface can be thought of as an interface for a really simple tester which only has the\nconcept of a flow and a collection of tests. Here is the basic starting point for any documentation interface: class DocInterface include OrigenTesters :: Doc :: Generator # Add a test to the collection def add_test (name, options)\n tests.add(name, options) end # Add a flow entry def add_flow_entry (test, options)\n flow.test(test, options) end end As with any interface it is then required to create methods to translate your domain specific\nflow API into calls to these two key methods to add a test and a flow entry. Our example flow here has a func method, we might implement the handler for that like this: def func (name, options={})\n add_test(name, options)\n add_flow_entry(name, options) end Over and above that what happens next is very domain specific and depends if any processing\nor sanitizing of the options or names are required to produce an accurate document.\nSome domain specific examples from the simple flow in this guide would be: By default any options passed to the add_test method will be rendered into the\nattributes column. In our case we are supplying the bin as a flow line option and that will\nalready be displayed in the dedicated column when it is passed to the flow entry. To inhibit\nthe bin appearing in the test attributes we can screen the options like this: # Add a test to the collection def add_test (name, options) # Delete any keys that we don't want to assign to the instance, this keeps # the attributes column clean, flow control keys will be screened by Origen automatically [ :bin , :some , :other , :keys ,\n ].each { |k| options.delete(k) }\n tests.add(name, options) end As noted in the above comment any keys related to flow control will be automatically screened and handled by Origen (doc helpers knows how to display this\ninformation to). Another convention from the above example was that we did not supply a test number and it was\nautomatically set to a multiple of the bin number,\nwe can handle that like this: # Add a flow entry def add_flow_entry (test, options)\n options = sanitize_flow_options(options)\n flow.test(test, options) end def sanitize_flow_options (options) # If the number has not been set in the flow then set it to a multiple of the bin, if present options[ :number ] ||= options[ :bin ] ? options[ :bin ] * 1000 : nil options end Note that many of the methods involved in processing the test options such as the sanitize_flow_options method here would be common to all\ninterfaces and therefore should not need special handling specifically for documentation.\nRather you\nshould create a common module that gets included into all interfaces to handle the non-tester-platform\nspecific concerns like these. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/flowapi/": {
    "title": "Managing Flow Control",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator Managing Flow Control The runtime flow control of a test program is an area that can be particularly messy: Need to deal with different and often obscure vendor APIs It can be very hard to decipher both the intention and the actual behavior\nduring code reviews It is easy to make mistakes Mistakes can be costly - there have been many customer quality\nincidents in the past from missed test caused by errors in flow control To deal with these problems Origen provides a simple and intuitive API\nto describe runtime flow logic: Generates legal and battle-tested code Takes care of cross-platform implementation Makes flow control easy to review Covers over gaps or weaknesses in the vendor APIs Conditional tests fall into two categories: Those that will run based on the flow execution environment. For example based on\nthe job selected at runtime or on some enable flag that can be set by the user at\nruntime. Those that will only run based on the outcome of another test - i.e. execute a given\ntest based on whether a previous test passed, failed or ran at all. Execution Based on the Runtime Environment The following methods are available to describe these cases: if_enable / unless_enable - Run the test if a flow runtime option is/is not enabled at runtime if_job / unless_job - Run based on the current job (P1, FR, QC, etc) Here are some examples of how to apply these methods to single tests: # Run this test to characterize the vreg, only if the 'vreg_cz' flag has been enabled para :vreg_meas , softbin : 107 , cz : true , if_enable : \" vreg_cz \" # Apply HVST to the vreg module, unless the 'skip_hvst' flag has been enabled func :vreg_hvst , softbin : 101 , hv : 10 .V, vdd : :max , unless_enable : \" skip_hvst \" # Run this test only at cold para :vreg_meas , softbin : 105 , lo : 1.12 , hi : 1.34 V , if_job : \" FC \" For an IG-XL based tester this would generate code like this: # Label Job Enable Test\n vreg_cz Characterize vreg_meas char 107\n skip_hvst goto VREG_LABEL_1\n Test vreg_hvst_max 101\nVREG_LABEL_1 nop \n FC Test vreg_meas 105 The unless “skip_hvst” is enabled is a good example of where Origen patches around\nweaknesses in the underlying vendor API - IG-XL doesn’t provide a native !enabled\ncontrol, however you can write your flow as if it does and Origen will generate\nthe equivalent logic. Execution Based on a Previous Test The following methods are available to describe these cases: if_ran / unless_ran - Run only if a previous test did or did not run if_failed (unless_passed) - Run only if a previous test failed (site specific) if_passed (unless_failed) - Run only if a previous test passed (site specific) All of these methods require you to provide the ID of the previous test on which\nthe conditional execution will depend.\nThis ID must be assigned by you in the flow line of the previous test by adding\nand id key like this: para :vreg_meas , softbin : 105 , lo : 1.12 , hi : 1.34 , id : :vreg_meas_1 The ID can be any value you like as long as it is unique, Origen will raise an error\nif any duplicate IDs are encountered. On the dependent tests the API is similar to the previous examples except the ID\nof the previous test is given in place of the enable flag or job name.\nHere are some examples: para :vreg_meas , softbin : 105 , lo : 1.12 , hi : 1.34 , id : :vreg_meas_1 # Automatically characterize the vreg if the measurement fails para :vreg_meas , softbin : 107 , cz : true , if_failed : :vreg_meas_1 # Then bin out bin_out softbin : 105 , if_failed : :vreg_meas_1 # Check if the HVST has already been run on this device func :rd_vreg_hvst_passcode , softbin : 50 , vdd : :nom , id : :vreg_hvst_done # If not run it func :vreg_hvst , softbin : 101 , hv : 10 .V, vdd : :max , unless_passed : :vreg_hvst_done # And program the flag for next time func :pgm_vreg_hvst_passcode , softbin : 51 , vdd : :nom , unless_passed : :vreg_hvst_done For an IG-XL based tester this would generate code like this: # Test Result Condition\nTest vreg_meas None vreg_meas_1_FAILED \nCharacterize vreg_meas char Fail flag-true vreg_meas_1_FAILED\nSet-Device 105 flag-true vreg_meas_1_FAILED \nTest rd_vreg_hvst_passcode None vreg_hvst_done_PASSED \nTest vreg_hvst Fail flag-true vreg_hvst_done_PASSED\nTest pgm_vreg_hvst_passcode Fail flag-true vreg_hvst_done_PASSED Origen automatically takes care of setting up all of the tests in the relationship: The parent tests in the relationship are automatically set to continue on fail Flag(s) will be set to indicate whether the parent test passed or failed Conditional execution flags are set on all dependent tests Controlling the Execution of a Group of Tests All of the flow control methods have a block form which will apply the\ncondition to all tests within the block. The previous example could be more clearly written using the block form: para :vreg_meas , softbin : 105 , lo : 1.12 , hi : 1.34 , id : :vreg_meas_1 if_failed :vreg_meas_1 do # Automatically characterize the vreg if the measurement fails para :vreg_meas , softbin : 107 , cz : true # Then bin out bin_out softbin : 105 end # Check if the HVST has already been run on this device func :rd_vreg_hvst_passcode , softbin : 50 , vdd : :nom , id : :vreg_hvst_done unless_passed :vreg_hvst_done do # If not run it func :vreg_hvst , softbin : 101 , hv : 10 .V, vdd : :max # And program the flag for next time func :pgm_vreg_hvst_passcode , softbin : 51 , vdd : :nom end This will generate the exact same code as before. A very useful pattern is to split your code into small re-usable snippets\nand then wrap the import with these flow control methods to apply conditional\nexecution.\nFor example here the ‘FH’ job requirement will be applied to all tests\nimported from the vreg component: # Only run the vreg tests at hot if_job \" FH \" do import \" components/vreg \" end Skipping a Section An additional method skip is available to skip over a section, this\nwould normally be qualified by one of the other flow control methods: # Don't bother running the hot vreg flow if the device already received it at probe func :rd_hot_sort2_passcode , softbin : 50 , vdd : :nom , id : :hot_sort2_done skip if_passed : :hot_sort2_done do if_job \" FH \" do import \" components/vreg \" end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/flows/": {
    "title": "Creating Flows",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator Creating Flows The test flow is where you describe everything about what your test program\nmust do: The tests it must run The conditions applied by these tests Test limits Bin and test numbers Conditional test execution and other flow control Notes about the reason for running or the methodology behind each test When writing your flow file you should try and distill down the amount of information\nto the bare minimum, the goal here is to write as little as possible yet still\ncapture the details about what makes each test unique. When describing each test the syntax and naming conventions are entirely\nup to you and based on your knowledge about the application domain and the\ntype and variety of tests that you need to generate.\nIt will be the job of the interface (which you will write later) to translate\nthis description into method calls to the generation API for the target platform. Your First Flow File By convention all flow files should reside in the “program” directory within\nthe application top-level directory. Create the file “program/probe.rb” as shown below: # program/probe.rb Flow .create do end The above represents all of the officially required syntax to define a flow, what\ngoes inside is now completely down to the needs of the application. When creating a flow like this it is often useful to supply some context about\nthe environment in which it will run. For example we have indicated via the name that this\nis a flow intended to run at probe, we can also note this in the code: # program/probe.rb Flow .create( environment : :probe ) do end Again the naming of the terms :environment and :probe are\ncompletely arbitrary, you may want to note some details about the temperature, parallelism\nor other details which may be useful to you when it comes to actually generating\nthe flow for a given ATE platform.\nOr not. Don’t worry about this too much right now, in practice it is probably best to\njust add things like this as you find that you need them. The main thing for now is just to\nappreciate that you can pass some details about the execution environment of the given\nflow to the interface via this mechanism. Specifying Numbers Origen extends Ruby to add the following methods which are very helpful\nwhen specifying test conditions: 3 .A # => 3 3 .mA # => 0.003 3 .uA # => 0.000003 3 .nA # => 0.000000003 3 .pA # => 0.000000000003 3 .V # => 3 3 .mV # => 0.003 # => etc 3 .Hz # => 3 3 .kHz # => 3000 3 .MHz # => 3000000 Adding Some Tests So let’s say we are writing a test for a voltage regulator module, we have a functional\ntest and then two parametric tests that we wish to run - one that simply tests the\noutput and one that tests the output under load.\nLet’s start with this: # program/probe.rb Flow .create( environment : :probe ) do log \" Vreg test module \" func :vreg_functional , pattern : \" vreg/functional \" , vdd : :min , bin : 5 , softbin : 101 , tnum : 101000 func :vreg_functional , pattern : \" vreg/functional \" , vdd : :max , bin : 5 , softbin : 101 , tnum : 101001 para :vreg_meas , pattern : \" vreg/meas \" , vdd : :min , bin : 5 , softbin : 105 , tnum : 105000 , lo : 1.12 , hi : 1.34 para :vreg_meas , pattern : \" vreg/meas \" , vdd : :max , bin : 5 , softbin : 105 , tnum : 105001 , lo : 1.12 , hi : 1.34 para :vreg_meas , pattern : \" vreg/meas \" , vdd : :min , bin : 5 , softbin : 105 , tnum : 105002 , load : 5 .mA, lo : 1.10 , hi : 1.34 para :vreg_meas , pattern : \" vreg/meas \" , vdd : :max , bin : 5 , softbin : 105 , tnum : 105003 , load : 5 .mA, lo : 1.12 , hi : 1.34 end This is a good start, we have something that resembles a test flow and we have gone with the\ngeneral convention that a flow line is structured like this: <function> <name>, <attributes> function - The main function of a particular test, here we have gone with the categories\n‘log’, ‘func(tional)’ and ‘para(metric)’. You may wish to have other categories based on your domain.\nFor example in some NVM applications we have ‘program’, ‘read’, ‘erase’, ‘measure’, ‘bitmap’,\nand so on. Each of these functions correspond to the methods that you will need to implement\nin your interface later. name - Almost every test will need a name and so we make this a mandatory argument. attributes - There then follows a free-format list of attributes, use these to describe\nthe test and especially including anything that makes the test unique, such as the load\nattribute which has been used above. As mentioned previously this choice of convention is just that, a personal choice, however\nthis is the convention that is currently used in the flagship Origen applications that are\ncurrently driving the development of the framework.\nAs the Origen program generator matures and the number of applications using it grows, it is\npossible that alternative and better conventions will begin to emerge.\nIf you come across a better approach then please come and tell us about via the Origen community channels ,\nhowever we will stick with this one for now. Eliminate Anything that can be Inferred Remember that the goal here is to be as concise as possible, since the more concise you\nare at this level then the more you can automate later. This eliminates duplication and\nredundancy, reduces the amount of code you need to write to add a new test later, and the\nmore that can be generated the less chance there is for human error. There are a few opportunities for simplification that we can consider at this point: The pattern field seems redundant - it very closely mirrors what has been assigned to the\ntest name, therefore we can infer the pattern name without explicitly declaring it. It is generally\na good approach to name the test after the pattern if you normally have one pattern per test. The bin number also looks to be redundant, it is always 5. In a case like this what\nwe can do is set a default of 5 within the interface, then if it is not declared for a specific\ntest it will be 5, but we can always override it for a specific test. The tnum attribute seems to follow the general rule that it is the softbin number * 1000\nand then a counter. Anything that is the result of a function based on other\nattributes is ripe for elimination. With those optimizations applied we end up with: # program/probe.rb Flow .create( environment : :probe ) do log \" Vreg test module \" func :vreg_functional , vdd : :min , softbin : 101 func :vreg_functional , vdd : :max , softbin : 101 para :vreg_meas , vdd : :min , softbin : 105 , lo : 1.12 , hi : 1.34 para :vreg_meas , vdd : :max , softbin : 105 , lo : 1.12 , hi : 1.34 para :vreg_meas , vdd : :min , softbin : 105 , load : 5 .mA, lo : 1.10 , hi : 1.34 para :vreg_meas , vdd : :max , softbin : 105 , load : 5 .mA, lo : 1.12 , hi : 1.34 end Finally we seem to always be running our tests at min vdd and then max vdd, so again\nthere seems to be a convention that we could choose to implement by default. One issue we\nhave is that the loaded test has a different limit between min and max, so this a\ngood example of one case where we would override the default. So switching to the convention that each test will execute at min and max vdd unless otherwise\nspecified, our final flow is: # program/probe.rb Flow .create( environment : :probe ) do log \" Vreg test module \" func :vreg_functional , softbin : 101 para :vreg_meas , softbin : 105 , lo : 1.12 , hi : 1.34 V para :vreg_meas , vdd : :min , softbin : 105 , load : 5 .mA, lo : 1.10 , hi : 1.34 para :vreg_meas , vdd : :max , softbin : 105 , load : 5 .mA, lo : 1.12 , hi : 1.34 end That very clearly and concisely describes what the flow must do. Also by establishing\nconventions and eliminating redundancy we have made it really easy for us to add\na new test in the future. Flow Control See the next section for details on run-time flow control. For build-time flow control you have complete access to the current target objects if you\nneed to conditionally build some tests. Lets say we have two DUT designs, and one of them has a bug which means that the\nvreg load test will not work properly. Let’s say its a problem with the pad connection\nsuch that the vreg works ok but it just can’t be tested via an external load.\nOur models to represent this situation would look something like this: # lib/dut_1.rb class DUT1 include Origen :: Model end # lib/dut_2.rb class DUT2 < DUT include Origen :: Model bug :vreg_pad end DUT1 .new.has_bug?( :vreg_pad ) # => false DUT2 .new.has_bug?( :vreg_pad ) # => true There are two ways that we could build the flow to ensure that DUT2 can still give a bin 1 - either\nskip the loaded test completely, or else don’t care its result.\nHere is an example of both: # program/probe.rb Flow .create( environment : :probe ) do log \" Vreg test module \" func :vreg_functional , softbin : 101 para :vreg_meas , softbin : 105 , lo : 1.12 , hi : 1.34 # Don't build this test if the target DUT has the bug unless $dut .has_bug?( :vreg_pad )\n para :vreg_meas , vdd : :min , softbin : 105 , load : 5 .mA, lo : 1.10 , hi : 1.34 end # Continue on fail if the target DUT has the bug para :vreg_meas , vdd : :max , softbin : 105 , load : 5 .mA, lo : 1.12 , hi : 1.34 , continue : $dut .has_bug?( :vreg_pad ) end Re-usable Flow Snippets It is ofter useful to extract sections of a flow into a sub-module, so that it can be re-used\nand parameterized.\nIn our case let’s say that we have a new DUT on the horizon which has two vreg instances, so\nlet’s extract this suite of vreg tests to a module so that we can instantiate two of them in\nour flow. All sub flow file names must begin with “_”, this is what tells Origen that it is a sub-flow and\nnot a top-level flow.\nThe sub-flow syntax is virtually identical to the regular flow syntax except that a hash of\noptions are passed in which will contain any arguments passed in by the caller when they\ninstantiate the sub-flow. Let’s convert our flow to a sub-flow in file “_vreg.rb”: # program/_vreg.rb Flow .create do |options|\n\n log \" Vreg test module \" func :vreg_functional , softbin : 101 para :vreg_meas , softbin : 105 , lo : 1.12 , hi : 1.34 # Don't build this test if the target DUT has the bug unless $dut .has_bug?( :vreg_pad )\n para :vreg_meas , vdd : :min , softbin : 105 , load : 5 .mA, lo : 1.10 , hi : 1.34 end # Continue on fail if the target DUT has the bug para :vreg_meas , vdd : :max , softbin : 105 , load : 5 .mA, lo : 1.12 , hi : 1.34 , continue : $dut .has_bug?( :vreg_pad ) end Not much has changed so far - the environment option has been removed from the Flow.create definition since that is more of a top-level concern, and the options have been added. There are a couple of opportunities for improvement here: The flow allows the loaded tests to be skipped, however it would be better if the sub-flow\ndid not define the conditions under which they should be skipped - that decision should be\nmade by to the top-level. If this test is going to be instantiated multiple times it will need some kind of index\nto target the test at vreg 0 or vreg 1. Here is the flow with these modifications: # program/_vreg.rb Flow .create do |options| # These are the option defaults that will be used unless specified by the caller options = { include_loaded_output_tests : true , index : 0 ,\n }.merge(options)\n\n log \" Vreg test module \" func :vreg_functional , softbin : 101 , index : options[ :index ]\n\n para :vreg_meas , softbin : 105 , lo : 1.12 , hi : 1.34 , index : options[ :index ] if options[ :include_loaded_output_tests ]\n\n para :vreg_meas , vdd : :min , softbin : 105 , load : 5 .mA, lo : 1.10 , hi : 1.34 , index : options[ :index ]\n\n para :vreg_meas , vdd : :max , softbin : 105 , load : 5 .mA, lo : 1.12 , hi : 1.34 , index : options[ :index ] end end For now we have not really committed to how the indexed tests will be generated, but we have\npassed the information along to the interface. Most likely when it comes to generating the\npattern name within the interface we will just append the index to the name. So the original top-level flow is now really simple: # program/probe.rb Flow .create( environment : :probe ) do import \" vreg \" , include_loaded_output_tests : ! $dut .has_bug?( :vreg_pad ) end The path argument supplied to the import method can be either a relative path from the\ncurrent file (as it is above), for example \"../components/vreg\" , or an\nabsolute path such as \"#{Origen.root}/program/components/vreg\" . In both cases\nthe underscore prefix is not required. The original reason for doing this was to add support for testing multiple\nvreg instances. To support such a case let’s say that our DUT model will implement a\nmethod called vregs which will return one or more vreg models wrapped\nin an array. Our final flow is: # program/probe.rb Flow .create( environment : :probe ) do $dut .vregs.each_with_index do |vreg, i|\n\n import \" vreg \" , include_loaded_output_tests : ! $dut .has_bug?( :vreg_pad ), index : i end end Documenting Tests All of the test attributes will be available later when it comes to generating documentation\nof the test program, so there is no need to document them manually.\nHowever in some cases it will also be useful to include some\ntext describing perhaps how the test works, or why it is being done.\nSuch information can be added via regular Ruby comments immediately before the given\ntest. Origen will extract these later when it comes to generating documentation. The comments will be parsed as Markdown so this can be used to make things like bulleted lists or tables. Here is our vreg test suite with some example documentation added: # program/_vreg.rb Flow .create do |options| # These are the option defaults that will be used unless specified by the caller options = { include_loaded_output_tests : true , index : 0 ,\n }.merge(options)\n\n log \" Vreg test module \" # This test verifies that the following things work: # # * The vreg can be disabled # * The trim register can be written to and read from func :vreg_functional , softbin : 101 , index : options[ :index ] # Measure the output of the vreg under no load, this is a simple # test to catch any gross defects that prevent the vreg from working para :vreg_meas , softbin : 105 , lo : 1.12 , hi : 1.34 , index : options[ :index ] if options[ :include_loaded_output_tests ] # Measure the output of the vreg under the given load, this is approximately # equivalent to 1.5x the maximum load anticipated in a customer application. para :vreg_meas , vdd : :min , softbin : 105 , load : 5 .mA, lo : 1.10 , hi : 1.34 , index : options[ :index ] # As above para :vreg_meas , vdd : :max , softbin : 105 , load : 5 .mA, lo : 1.12 , hi : 1.34 , index : options[ :index ] end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/generating/": {
    "title": "Running the ProgGen",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator Running the ProgGen The program generator is launched via the Origen generate command, see the command line\nhelp to get details of the most up to date options: origen program -h As this is such a commonly used command it has a short cut alias: origen p -h The generator can be run on a single file: origen p program/probe/sort1.rb or it can be run on a whole directory: origen p program/probe Program list files can also be used, by convention these should be kept in the list directory\nand should have the extension .list : origen p list/program/production.list Here is an example of a list file: # List files can be commented like this\n# Simply list the name of the files that you would use on the command line\nprogram/probe/sort1.rb\nprogram/probe/sort2.rb\n# List files can also call other lists\nft.list The generated files will be put in whatever directory\nis returned by the config.test_program_output_directory attribute in application.rb . Submit to the LSF by appending -l and optionally interactively\nwait for completion: origen p list/program/production.list -l -w Regression Testing Everytime Origen generates a file it will check to see if it has generated it before, and\nif so it will compare the current version to the previous version and alert if there is a\ndifference. This can be used to check for regressions when making changes that you don’t want\nto affect the output, or to verify that the change is what you intended in cases where you\nare intentionally modifying the output. The diff is a smart diff and will not care about any changes to comments, only about changes\nthat will affect the file’s operation. In the case of a difference being found Origen will automatically present you with the diff command\nto run if you want to view the change. To accept changes or to start tracking the differences in a file (or files) run the following command\nafter generating: origen save all Programatically Launching the Generator If you start writing your own commands you may want\nto launch the generator from Ruby, do that as follows: Origen .app.runner.launch action : :program , files : \" list/program/production.list \" This can be combined with Target Loops to run the\ngenerator for multiple targets. A generate job can also be posted to the LSF by supplying the same options that you would use\non the command line like this: Origen .lsf.submit_origen_job( \" p program/probe/sort1.rb \" ) Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/interface/": {
    "title": "Creating an Interface",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator Creating an Interface To re-cap the purpose of an interface is to translate your behavioral\ndescription of the test flow into a test program for a specific ATE\nplatform.\nThis step is where most of the work comes in and interfaces can grow to\nbe quite large pieces of code depending on the complexity of your flow. An interface is a regular Ruby class which would be created in your lib\ndirectory.\nContinuing with the vreg example and assuming that all of our code was namespaced in the Vreg module,\nwe could create an initial interface like this: # lib/vreg/interface.rb module Vreg class Interface include OrigenTesters :: ProgramGenerators # The methods called by the flow files will be implemented here end end Required Methods For an interface to run it must implement all of the methods that will be called\nby your flow.\nIt is also customary to create an initialize method that will capture any options\nthat are passed in to Flow.create (such as declaring the environment\nas probe in our flow example). Here is an interface shell to handle the test flow that we created in the previous\nsection: # lib/vreg/interface.rb module Vreg class Interface include OrigenTesters :: ProgramGenerators # Add a regular attribute to our interface to allow us to query the # execution environment attr_reader :environment # Any options passed to Flow.create can be captured here and assigned # to instance variables which can be used later to modify the output from # your other interface methods. def initialize (options={})\n options = { environment : :ft , # Set the environment to FT unless otherwise specified }.merge(options) @environment = options[ :environment ] end # Record the given message to the datalog def log (msg, options={}) end # Create a functional test and call it from the flow def func (name, options={}) end # Create a parametric test and call it from the flow def para (name, options={}) end end end Note that you do not need to define methods to handle the Flow Control API , the included generator\nmodule will already take care of those. At this point you can now generate your flow for the first time to make sure\nthat there are no methods missing: origen p path/to/your/flow.rb All being well this should run cleanly without actually generating any of your tests,\nif you get some errors your should be able to work out what methods need to be added to\nyour interface from the error messages. The contents of these methods will be discussed in the following platform-specific\nsection of the test program guide. Avoiding Duplicate Tests The astute reader may at this point note that the intention of the above methods\nis to both generate a test and to add it to the flow. Well how do we avoid duplicate\ntests from being generated if the same method is called multiple times within the same flow? The answer is that you don’t need to worry about this, Origen will take care of suppressing\nduplicate entries in things like a test instance or a test pattern file, depending on the\nneeds of the target platform.\nSo your interface does not need to keep track of details like whether a test has previously\nbeen generated or not. Just generate all the resources required to run a particular test\nevery time that your method is called and Origen will take care of optimizing it. When assessing whether or not a test already exists Origen does not simply just look at the\nname, all of the attributes of a particular test are considered as well. If a test of the\nsame name already exists but with different attributes then Origen will create a new test\nand apply a version of ‘_v1’ to the original test and ‘_v2’ to the new one. The flow will\ncall the correct version at the correct place as you would expect. Generally you should keep an eye on what is being generated and if you start to see\n‘v1’ or ‘v2’ tests being generated then it is a sign that your test naming\nconvention is not including some detail that is required to uniquely identify each test.\nSo while the program generated will be functionally correct, it will not be obvious to\na user of the test program what the difference is between ‘test_v1’ and ‘test_v2’.\nFor example say that your test name does not include the vdd, yet your flow generates the same\ntest to run at min, nom and max vdd. In that case Origen will generate these as versions\n1, 2 and 3.\nAdding the vdd to you test names would resolve this problem and the program would now\ninclude tests called ‘test_min’, ‘test_nom’ and ‘test_max’ which is much more\ndescriptive. If you are not comfortable with this approach for some reason and would prefer separate\ncontrol over test generation and flow insertion then Origen also supports a\na more traditional workflow where you can generate a library of tests and then call them\nfrom a separate flow definition.\nHow to do that is discussed in the Resources section.\nHowever the combined test generation and flow insertion is the recommended way and\nfully leverages Origen’s unique ability to completely generate a new test from adding a single\nline to the test flow (once you have an interface already setup). Additional Methods The interface can also define whatever additional methods it needs to help implement\nthe main flow API.\nIn this example, let’s just add the following method to help us generate the full\ntest names: # lib/vreg/interface.rb def namer (basename, options={})\n name = basename if options[ :vdd ] # In our world let's have the convention that if the vdd is not included in # the name then it is nominal, otherwise it will be in the name unless options[ :vdd ] == :nom name = \" #{ name } _ #{ options[ :vdd ] } \" end end name end In reality some interfaces can get quite complex, and breaking the code down to additional\nRuby class or modules is common. Re-using Interface Methods The interface, or portions of it, can be easily extracted to a plugin\nfor future use in another application. See the Origen Plugins section for details on how to do this. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/introduction/": {
    "title": "Introduction",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator Introduction Origen provides a powerful object-oriented test program generator which has a\nunique architecture which fully separates an application’s test flow logic\nfrom its implementation on a given test platform. This architecture offers many advantages but most notably: It is extremely efficient. Adding additional tests is very quick after you have\ninitially bootstrapped your program generator, in many cases only requiring\none line to be added to your source code. It keeps you sane. As test flows and programs get larger and larger it really\nhelps to be able to use object-oriented programming techniques to keep\neverything organized. It eliminates bugs. The architecture encourages you to write the least amount of\ncode possible to create a new test, this maximizes the re-use of working code\nand reduces the number of moving parts and opportunities for bugs to occur. It supports multi-platform and documentation. The same test flow source file\ncan be used to generate the program on different platforms, including\ncreating documentation of the test program. Dynamic custom code is supported. Custom VB/C++ code can be compiled through\nOrigen, this eliminates the need to keep DUT configuration information in your\ntest program code - write it to support a single device, then modify it later\nto work with another configuration with Origen. Architecture An overview of the program generator architecture is shown below: Origen provides a rich generator for each supported platform, this takes care of\nall formatting concerns and tries to automate some details of the platform API which\ncan be particularly error prone - for example flow control logic. The application then provides a Flow file which contains a behavioural description\nof each test and the order that they should be executed in. Note that there should be no consideration given to the underlying platform implementation\nof the test at this level , the job of the flow is to describe the electrical\nproperties of each test and pattern dependencies, but should not worry about things\nlike test instances, interpose functions, test methods, etc. The application must then provide an interface which has\nthe job of translating the flow definition to the one or more of the target test platform APIs.\nFor example the interface may say “ok when the flow asks\nfor a functional test then create a new patset, create a new functional test instance\nwhich will reference that patset, setup the instance based on the electrical\nproperties of the test, and then finally add an entry in the flow sheet”. In this way the tedium of having to create a test instance, then a pattern set, then\na flow entry, then go back to the test instance because you named the pattern set\nwrong, etc, etc…is eliminated along with many opportunities for errors. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/j750/": {
    "title": "J750 API",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator J750 API Be sure to read and understand the guide to Creating an Interface before\nreading this section.\nThis guide will describe the API to generate J750/IG-XL test program \ncomponents from within an interface file. To re-cap this is the shell required to implement an interface: # lib/vreg/interface.rb module Vreg class Interface include OrigenTesters :: ProgramGenerators # An example method that can be called from your test flow to generate a functional test def func (name, options={}) # If your interface supports multiple platforms, add conditional logic like this, if you # only ever want to support one platform then you don't need this if tester.j750? # Functional test implementation for J750 elsif tester.v93k? # Functional test implementation for V93K end end end end The OrigenTesters::ProgramGenerators will provide the interface\nwith access to all of the platform generator APIs for the platforms that it supports. If your interface supports multiple platforms then add conditional logic to separate\nthem as shown above. Creating a Test Instance When generating a J750 program most of the effort is in generating the test\ninstances. To start with the basic method of creating and decorating test instance\nobjects will be discussed and then at the end of this section some recommendations\nwill be given on how to structure your test instance generation methods. The method test_instances returns an instance of OrigenTesters::IGXLBasedTester::J750::TestInstances which provides additional\nmethods to generate new test instances.\nThe API should be consulted for the most up to date information on the methods available. A new test instance can be instantiated like this: test_instances.add( :vreg_func , :functional ) This one line of code does a lot of things: Creates a new test instance sheet if one doesn’t exist already Instantiates a new test instance object Sets its name to ‘vreg_func’ Applies the default attributes for a J750 functional test instance\n(basically the same attributes that would be present when you added a new functional\ntest instance within IG-XL) Adds the new test instance to the test instance sheet If you were to add that line and generate your program you would now get\na test instance sheet generated with a single functional test instance in it\ncalled ‘vreg_func’. Not bad. Convenience methods exist where you can call a method named after the type of the test instance,\nthis is equivalent: test_instances.functional( :vreg_func ) You will of course want to decorate your new test instance with attributes that are specific\nto your application, to do that you simply assign the returned instance to a variable and\nthen you can programmatically set the attributes that you want.\nFor example: ins = test_instances.functional( :vreg_func )\nins.ac_category = \" Spec \" ins.ac_selector = \" Default \" ins.time_sets = \" Tim \" ins.pin_levels = \" Lvl \" The name of these methods is the underscored (to align with general Ruby conventions)\nversion of the name in the IG-XL columns headers and they should hopefully be very\nintuitive. Note that you don’t need to do anything here to save or push the instance into the sheet,\nthis will all be done automatically. Attributes can also be passed in when instantiating the new instance, this is equivalent\nif you prefer: ins = test_instances.functional :vreg_func , ac_category : \" Spec \" , ac_selector : \" Default \" , time_sets : \" Tim \" , pin_levels : \" Lvl \" Instance Type Specific Attributes Additional methods will be available depending on the instance type that you\nspecified.\nFor example in our functional instance we can set the pattern and call a pre-test\ninterpose function like this: ins.pattern = \" vreg_functional \" ins.pre_test_func = \" someInterposeFunc \" Again the method names should hopefully be intuitive and should correspond to\nthe IG-XL names. To see what the method names are called refer to the TEST_INSTANCE_ALIASES constant\ndefinition at the top of the J750 TestInstance API . Supported Test Instance Types Currently supported test instance types are (although check the API for the latest\ninformation): functional board_pmu (bpmu) pin_pmu (ppmu) other empty If you need a different type you can still call the add method, the difference in the\nreturned instance for an unrecognized type is: The instance will be completely empty and all attributes will need to be\nadded by your application code. The named attribute methods will not be available. The latter means that instead of using convenience methods to set the attributes you\nwill need to use argX format instead, where argX corresponds to the column name\nin IG-XL. So the previous example of adding a pattern and interpose function call to our functional\ninstance could be re-written as shown below: ins.arg0 = \" vreg_functional \" ins.arg3 = \" someInterposeFunc \" You would also need to configure the basic attributes such as the template type and name.\nTo get an idea of what is required refer to the TEST_INSTANCE_DEFAULTS constant\ndefinition near the top of the J750 TestInstance API . If you do find yourself in this situation please get in touch via the community channels and\nwe can quickly work with you to add the new instance type to Origen, then the names attribute\nmethods will be available for everyone. What Are the Defaults? Generally the test instance defaults should match exactly what you get from IG-XL (that is\nthe intention at least). To see what the defaults are for a given test instance type refer to the TEST_INSTANCE_DEFAULTS constant\ndefinition near the top of the J750 TestInstance API . Helper Methods A number of helper methods are available to make test instance generation easier. A good example is setting the current range of a parametric test instance where the value\nstored in the IG-XL workbook is not at all intuitive and bears little resemblance to the numeric\nrange value that it represents.\nA set_irange method is available to help, here are some examples: ins.set_irange( :smart )\nins.set_irange( ua : 2 )\nins.set_irange( 2 .uA) # Same as above ins.set_irange( ma : 200 )\nins.set_irange( 0.2 ) # Same as above ins.set_irange( a : 0.2 ) # Same as above A useful pattern when using this method is just to set the range to the test upper\nspec limit, Origen will then take care of rounding this to the correct range. See the J750 TestInstance API for details on the currently available helper methods. If you have a good helper method in your application that you think would be a\nuseful addition to Origen please do create a pull request with the additions to the Origen Testers plugin . Avoiding Duplicate Test Instances Your interface does not need to keep track of duplicate instances, Origen will automatically\nget rid of them.\nSee the discussion “Avoiding Duplicate Tests” in the Creating an Interface guide. A Note on Test Instance Groups IG-XL has the concept of a test instance group, that is a group of test instances that\nyou can call from a single line in the test flow. However the syntax for this in the test instance\nsheet does not lend itself to easy generation - \nthat is a test instance with the same name as an existing one will be treated as a group if\nthey occur next to each other, whereas it will be a validation error if they are apart.\nThis poses some problems for Origen when it comes to test instance generation - how does it\nknow when the instance your application has requested is a duplicate that should be screened\nvs. an intentional generation of a group? To avoid pushing responsibility of duplicate tracking to the application there is a dedicated\nmethod for generating groups. Any instances generated within the given block of code will\nbe treated as a group: test_instances.group( \" vreg_func_all \" ) do |group| $dut .vregs.each_with_index do |vreg, i|\n test_instances.functional( \" vreg_func \" ) end end See the group method API for more details and examples. Structuring Your Instance Methods As mentioned at the start the vast majority of your J750 interface code will be concerned\nwith generating test instances, so it pays to spend a bit of time up front thinking about\nhow to organize this code into a maintainable architecture. The following techniques have proved to be useful in organizing the test instance generation\nfor some very large and complex test flows. Create Base Instances Add methods to create base test instances, that is\ntest instances which contains all of the attributes that every instance in your\napplication will have. def base_instance (name, type, options={})\n ins = test_instances.add(name, type)\n ins.dc_category = \" VREG \" if options[ :vdd ]\n ins.dc_selector = options[ :vdd ].to_s.capitalize # If :min, :max for example else ins.dc_selector = \" Typ \" end ins.ac_category = \" Spec \" ins.ac_selector = \" Default \" ins.time_sets = \" Tim \" ins.pin_levels = \" Lvl \" ins # Remember to return the newly created instance object to the caller end def func (name, options={})\n ins = base_instance(name, :functional , options) # Additional functional specific configuration here end This pattern can be extended to provide additional methods like “base_functional_instance”, \n“base_bpmu_instance” and so on. Use Decorator Methods A decorator method is a method that decorates (or adds to) a test instance with specific\nfunctionality.\nFor example in the flagship Origen application, some of our functional test instances required match\nloop support while others did not, so we created a decorator that we could call to add\nthis feature: def add_match (ins)\n ins.post_test_f = \" MatchBinFails \" ins.pat_flag_f = \" MatchLoopPatFlagFunc \" ins.set_wait_flags :a end def func (name, options={})\n ins = base_instance(name, :functional , options)\n ins.add_match(ins) if some_logic_to_gate_this end Split Your Application Instances into Logical Groups In the flagship application we found it best to conceptually split our test instance\ngenerators by application-specific types rather than by sticking to the IG-XL types\nlike functional, BPMU, PPMU, etc. It is hard to give a universal example here since this area is so application specific,\nbut to hopefully give you some food for thought… In the flagship application we had a lot of parametric tests and initially we went down the\npath of having an instance generation method for all BPMU tests and one for all PPMU tests.\nHowever within those groups some of the tests were very different and it led to a\nlot of complexity within those methods. When we took a step back and looked at our application our tests were not really split into\n2 types, rather they were comprised of 4 types - a high-voltage measurement, a high-voltage\ncalibration, a low-voltage measurement and a low-voltage calibration.\nWhen we continued this process through our test flow as a whole we ended up with 14 different\ntest classifications and we then added a method dedicated to generating the test instance\nfor each one. You should probably not go down this path initially, but once you get a feel for the\ngeneration process and if your interface is starting to get complex, then this is a step\nto consider. Creating a Pattern Entry The hard part is over, creating pattern sets and groups is trivial by comparison to\ncreating test instances.\nA similar API is provided to generate pattern resources in your test program and a nice\nby product is that Origen will keep track of the referenced patterns and will produce a required\nlist of patterns at the end (which you can then pass to the pattern generator). As with test instance generation Origen will deal with the suppression of duplicates in all\ncases. To add a pattern set call as follows: patsets.add( \" vreg_func_pset \" , pattern : \" patterns/VREG/vreg_func.PAT \" ) Multiple patterns can be specified by passing an array as the 2nd argument: patsets.add( \" vreg_func_pset \" , [{ pattern : \" patterns/VREG/vreg_func.PAT \" },\n { pattern : \" patterns/VREG/vreg_global_subs.PAT \" , start_label : \" subr \" }\n ]) Creating pattern groups is identical, just substitute patsets with patgroups . Normally you would create a dedicated method for creating pattern sets to avoid\nduplication, something like this: def add_patset (name)\n patsets.add( \" #{ name } _pset \" , pattern : \" patterns/VREG/ #{ name } .PAT \" ) end The pattern set or group object can be assigned to the pattern attribute of a test\ninstance directly: def func (name, options={})\n ins = test_instances.functional(name)\n ins.pattern = add_patset(name) end If you just want to add a pattern reference outside of a pattern set or group then\nadd it to the referenced_patterns array to ensure that it gets added\nto the list of required patterns that is output from the program generation process: referenced_patterns << \" some_vreg_pattern \" Creating a Flow Entry Within your interface the flow method will return an instance of\nthe J750 flow generator which provides methods for adding tests and other entries\nto your test flow. See the API for full details. So for example to enter a log print statement in the flow you can call: flow.logprint \" Start of the vreg test section \" Going back to the earlier example from the Creating Flows guide we had this in our flow: log \" Vreg test module \" This is probably the simplest method to implement in our interface: def log (msg)\n flow.logprint(msg) end The most common call will be to the test method which will insert a call\nto a test instance in the flow. Note that it is recommended that you pass all options from the test flow into any flow methods,\nthis ensures that any flow control logic will get implemented . Here is a complete interface method for the first time that will generate a test instance,\nadd a pattern set reference to it, and now finally call the instance from the\ntest flow: def func (name, options={})\n ins = test_instances.functional(name)\n ins.pattern = add_patset(name)\n flow.test(ins, options) end The object returned from flow.test is an instance of OrigenTesters::IGXLBasedTester::J750::FlowLine and this does provide a few methods that may be of use. However in general most of the\nmethods are there to support flow control and it is not recommended that you use these\ndirectly, rather use the flow control API to\ndo this. However it is recommended that you look at the TESTER_FLOWLINE_ATTRS , ALIASES ,\nand DEFAULTS definitions as this will tell you what the generator calls the IG-XL attributes. For example you can\nsee that the test number attribute is called tnum and that this is also aliased\nto 'number' . This means that you can set this attribute via this style (which is most useful\nfor passing attributes through directly from the flow file): flow.test(ins, tnum : 10000 ) Or it can also be set via a method call: flow_line = flow.test(ins)\nflow_line.tnum = 10000 It is recommended that you create a dedicated method for flow insertion as this gives you\na single place to implement defaults and to perform any translation between what the flow has\ncalled an attribute and what the J750 generator would call it: def add_flow_entry (ins, options) # Defaults options = { bin : 5 , tname : options[ :tname ] || options[ :name ] || ins.name,\n }.merge(options) # Some translations options[ :softbin ] = options[ :sbin ] if options[ :sbin ] # Add the flow entry flow_line = flow.test(ins, options) # Some final decoration flow_line.continue_on_fail if options[ :continue ]\n\n flow_line end Here is an example interface method using this add to flow method: def func (name, options={})\n ins = test_instances.functional(name, options)\n ins.pattern = add_patset(name)\n add_flow_entry(ins, options) end Finally you may on occasion wish to call a test from your flow where the instance\nis not available - maybe the instance is generated by another test module for example.\nIn this case the :instance_not_available option can be set to true to prevent Origen from trying to match up the flow with an instance object. flow.test( \" POR_INSTANCE \" , instance_not_available : true ) What About My DC Specs? Other IG-XL sheets do not currently have generators available, although that is likely\nto change in the future. For now though the existing Origen-based applications have found that the other sheets tend\nto be simple enough that they can be easily handled via a template-based approach. To create a template simply build the sheet in IG-XL, export it to ASCII and this becomes\nyour initial template, then add Ruby snippets as required to make parts of it dynamic. See the Dynamic Custom Code guide for more details\non how to compile a template automatically during a program generation process. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/philosophy/": {
    "title": "Philosophy",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator Philosophy Documentation of a test program is important to allow non-test-engineering stakeholders\nto understand what is in a given program, or what a given bin number refers to.\nSo Origen fully embraces the notion that test programs should be documented, that\nthis documentation should not have an opportunity to be wrong, and that no one\nshould have to waste their time manually trying to keep a document and the program\nin sync. However many tools in this area approach this\nproblem by trying to turn documentation into a test program.\nOrigen turns this problem on its head and unashamedly asserts that the test program\nitself is the true source of authority as to what it does, and that documentation\nis the follower instead of the leader. This approach has the following advantages: Test programs are large and complex, who really wants to write the whole thing\nout manually? It is much more efficient (and less error prone) to write it in code,\nthen we can use subroutines, variables, object-orientation, meta-programming (code\nthat generates other code) and any other programming\ntechniques to eliminate duplication and opportunities for error. Document first approaches are always constrained by the fact that some tests are\nmore complicated than others. In a recent industry conference a leading document-first\ngenerator stated that typically it could handle 80% of tests, for the other 20%\nyou were on your own. With Origen’s approach 100% of your tests will be generated. The Chicken and the Egg Problem One problem with the Origen approach is how do you bootstrap a new program, intuitively\nyou may want to document it first. This problem can be solved via the following workflow: The Flow file syntax is designed to be as simple and human-readable as possible,\nand it is self contained and can exist long before any interfaces are ever written.\nTherefore it you know enough to be able to write a document of a flow, then you\nknow enough to be able to write an Origen flow file for that flow. Nonetheless some early stakeholders may want to get involved in the definition \nbut won’t feel comfortable with the code layer. In this case it is recommended\nthat you immediately setup a documentation interface (these are trivially simple\nand will probably eventually come from free with Origen), and begin generating\ndocumentation of the flow from day 1. Definition can continue as required by iterating on the flow file, all the while\nthe documentation stays in sync. When it comes to finally implementing the flow the test engineering team will\ncreate the interface which will turn it into a real test program. An alternative approach is to have a short-lived hand-written document that is used\nto get the team up to the first release of the test program. At that point authority\nshould switch to the program itself and a ticketing system should be used to iterate on\nthe program… How Do I Specify a Program Change if I Don’t Know How to Code? The underlying program application should use a ticketing system.\nAny non-test-engineering stake holders can review the documentation to see what the test program\ncurrently does, then if they want it to do something else they will raise a ticket\nrequesting it. Once the change has been implemented the ticket can be closed and the documentation\nwill automatically pick up the change. This workflow is much easier to monitor and track status vs. the alternative approach where\nthe non-technical stakeholder release new versions of a document and the TE has the job of trying\nto keep the program in sync. But I already have a document containing a lot of my test details! As the flow file is written in Ruby, it is perfectly feasible to build higher level structures\nsuch as an importer, or even a spreadsheet-based interface on top of this. The early users of the Origen test program generator have not had a need for such an approach,\nhowever this is definitely an area where the community could start\nto build new features. Shouldn’t a Program Generator build me a complete test? It’s Origen’s job to provide a solid generation platform, however it deliberately does not\ntry to dictate how a functional/parametric/bitmap/ATD ramp/etc. test should be set up.\nFirstly the scope of such an effort is too large, but secondly the Origen developers do\nnot necessarily have the knowledge required to dictate what is the best practice\nin a lot of these areas. However the idea of eliminating the interface layer is appealing and the good news is\nthat it is achievable. The Origen Plugins feature provides a way\nfor Origen code to be easily packaged into a re-usable plugin and shared between projects. So for\nexample, an ATD interface module could be written and then anyone wishing to create ATD\ntests, could import this into their application and completely bypass the interface\ncreation step altogether. Just call the interface methods from the flow file and you will get a\nguaranteed working (and hopefully efficient!) ATD test. If you are a test expert in a given area, and you are using Origen to generate your program,\nthen we would encourage you to share your expertize by making your test setups available\nas an Origen plugin. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/resources/": {
    "title": "Additional Resources",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator Additional Resources When generating a complete test program it may be necessary to build some components\nthat don’t naturally fall out of the regular flow generation.\nSome examples of this might be: Creating a test which does not have a flow entry, but perhaps you want to keep it\navailable in your program for engineering use. Creating a test program sheet or file that is not supported by an Origen generator,\ne.g. the IG-XL DC Specs sheet does not currently have a generator. Creating custom VB, C++ or similar code to support your tests. All of these goals can be fulfilled by using a Resources file. Resources files are\nvery similar to the Flow files that we have already seen, the main difference is that\nany flow entries generated within a Resources file will automatically be inhibited. This makes generating tests and their resources (e.g. pattern sets, etc.) without a flow\nentry extremely easy - just use the same code that you would normally use in the Flow\nfile and you will automatically get everything needed for the test without the flow\nentry. Resource files are syntactically equivalent to Flow files except that all references to Flow are replaced by Resources : # program/probe_resources.rb Resources .create do end So for example without changing our interface at all we can drop some of our previous\nFlow code into the resources file (flow specific attributes such as bin numbers can\nbe removed): # program/probe_resources.rb Resources .create do func :vreg_functional para :vreg_meas , lo : 1.12 , hi : 1.34 end This would generate the same program as before but with no flow entries for the generated\ntests. Parameterizable sub-resource files can be created in exactly the same way as sub-flow files. Compiling Templates Another common use case for a Resources file is to co-ordinate the compilation of template\nfiles. See the Compiler section for details on\nhow to create templates. A compile method is available with a Resources file to invoke and customize\nthe compilation of a specific file. Any arguments passed in will be accessible within the\ntemplate via its options method. # program/common_resources.rb Resources .create do compile \" templates/j750/DCSpecs.txt \" , max_vdd : 5 .V\n\n compile \" templates/j750/GlobalSpecs.txt \" , vreg_period : 40 .ns end Separating Test Generation from Flow Generation As discussed previously a conventional Origen program generation flow would be to generate\nboth the flow and the tests from a single flow file. However it is also possible to\ngenerate the program in a more traditional way where the test and flow generation are\nseparated. To do this use Resources files to generate the tests and all of their dependencies. This\nwould look very much like the flow file examples we have seen so far, the main difference\nwould be that each test would only ever appear once (although if you did generate duplicates\nby accident Origen would still take care of it). Then to define the flow you would have Flow files that called interface methods to insert\nflow entries only.\nThis flow file would be a simplified version of what we have seen so far since the\nattributes of the test are no longer required.\nFor example you might make a new interface method called ‘test’ which calls a test\nin the flow - at flow level there is no longer any conceptual difference between\na parametric test and a functional test and so they can all use the same method.\nHere is a previous example that only contains the flow concerns (includes ‘cz’ and\n‘bin_out’ methods since these are also flow level concerns): Flow .create do test :vreg_meas , softbin : 105 , id : :vreg_meas_1 if_failed :vreg_meas_1 do # Automatically characterize the vreg if the measurement fails cz :vreg_meas , softbin : 107 # Then bin out bin_out softbin : 105 end # Check if the HVST has already been run on this device test :rd_vreg_hvst_passcode , softbin : 50 , id : :vreg_hvst_done unless_passed :vreg_hvst_done do # If not run it test :vreg_hvst , softbin : 101 # And program the flag for next time test :pgm_vreg_hvst_passcode , softbin : 51 end end If you want to use the same methods in the Resources and Flow files you can use the resources_mode? method within your interface to control when the flow\nor the tests should be generated. This method will return true if the interface method\nhas been called from a Resources file: # lib/vreg/interface.rb # Create a functional test and call it from the flow def func (name, options={})\n name = namer(name, options) if resources_mode? # generate the test else # generate the flow entry end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/ultraflex/": {
    "title": "UltraFLEX API",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator UltraFLEX API Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/program/v93k/": {
    "title": "V93K API",
    "subtitle": "Test Program Generator",
    "body": "Test Program Generator V93K API Sorry, Documentation Fail Unfortunately this guide has not been written yet, but it is an area that is on our road map. Please comment below to let us know that you were looking for it, this will help us to prioritize which\nsections to write next. If you need help on this item in the meantime, please ask a question in the Origen forum . Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/environment/": {
    "title": "Environment",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Environment All environments are defined by files that reside in the environment directory.\nEnvironments are regular Ruby files and they should be simply named: <identifier>.rb In a test engineering application where the environment is used to select the target test platform,\nthey are normally named after the tester, e.g. environment\n|-- j750.rb\n|-- uflex.rb\n|-- v93k.rb\n`-- jlink.rb Creating an Environment To create a new environment, simply create the file containing whatever Ruby code you need.\nThey are usually very concise and in a test engineering application would normally only instantiate the\ntarget tester driver, here are some examples: # environment/j750.rb $tester = OrigenTesters :: J750 .new # environment/v93k.rb $tester = OrigenTesters :: V93K .new # environment/jlink.rb $tester = OrigenDebuggers :: JLink .new If the given driver supports configuration options, then you may have some variations\nfor a given platform - e.g. j750_probe.rb to configure the driver slightly differently\nfor generating probe test patterns: # environment/j750_probe.rb $tester = OrigenTesters :: J750 .new $tester .available_power_supplies = 64 Setting a Default Environment A default environment can be defined that will be used withing a new workspace unless the user\nspecifies otherwise. This is not required and should only be added if it makes sense within the\ncontext of the application - i.e. you may choose not to have a default to avoid the situation where the user\nbuilds something without really understanding what configuration they are targeting. A default is specified by creating an environment file called environment/default.rb ,\ntypically this is a symbolic link to another environment file: ln -s environment/j750.rb environment/default.rb Getting and Setting the Environment The current environment for a given application workspace can be queried by running the origen environment command, or origen e for short, this will show\nyou the content of the current environment file: > origen e\n\nCurrent environment: j750.rb\n**********************************************************************\n $tester = OrigenTesters::J750.new\n********************************************************************** The environment can be changed by running the same command and supplying the desired environment: > origen e environment/j750.rb\n\n> origen e v93k As shown above, a full path or any snippet which is enough to uniquely identify one of the available\nenvironment files is sufficient. Additionally all Origen commands allow an override to be supplied at runtime: > origen g my_pattern -e jlink Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/global/": {
    "title": "Global Setup",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Global Setup Origen re-loads the runtime environment immediately before every pattern, test program or compile\njob.\nTherefore both the target and environment files can be used to set some global state that\nwill later be applied to all patterns or similar. Note that you cannot actually generate any output from the target or environment, that will only\nhappen from within the pattern, program or template source files. However what you\ncan do is setup some initial state within your models to influence what will\nbe generated by the source files later. In other words any changes that you make to the models after instantiating them\nwill persist into the remainder of the generation flow.\nIt is not recommended to put a lot of logic into target files, but when used\nresponsibly this can be a useful addition to your tool box. Origen Configuration The target and environment files can also be used \nto override any Origen configuration settings that would otherwise be specified in\nthe config/application.rb file. An example might be to set up product-specific LSF strings for utilization tracking: # target/eagle_1.rb $dut = MyApp :: Eagle .new( version : 1 ) Origen .config.lsf.project = \" eagle.te \" # target/falcon_1.rb $dut = MyApp :: Falcon .new( version : 1 ) Origen .config.lsf.project = \" falcon.te \" Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/introduction/": {
    "title": "Introduction",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Introduction Typically an Origen application will contain source code to generate IP that can be\napplied to many different products, and/or which can run on many different test platforms.\nIt is the job of the target and the environment to setup the runtime conditions that will\ndefine what combination of product and tester platform will be targeted by the\ngenerated output. The target is normally used to define the product side of the runtime environment, with one\ntarget file existing for every product/device that the application supports.\nTarget files are usually very short and normally just instantiate the model of the target\ndevice, assigning it to the global variable $dut . For test engineering applications, the test platform selection is usually handled by environment\nfiles. These are very similar to target files and there is usually one per supported test\nplatform. Each environment will typically instantiate the target tester model/driver, assigning it\nto the global variable $tester .\nFor non-test engineering applications, the environment layer can either be omitted or\nelse it can be used to define whatever other global state makes sense to be applied across\nmultiple device targets. Additionally, Origen has the concept of an operating mode and this can be considered a\nthird component of the runtime environment. How the Runtime Environment is Applied Before compiling any template, or generating any pattern, test program or other source file,\nOrigen will do the following: Apply the active mode Execute the active environment file Execute the active target file This means that the active environment can override the active mode, and that the active target can\noverride both the mode and the environment. This sequence will be repeated between jobs if multiple\nfiles are being compiled/generated by a given Origen thread of execution (each source files is an individual job).\nThis prevents model state from a previous job from carrying over to the next one and ensures that the\noutput is never affected by generation order. This sequence of reloading the mode, environment and target is generally referred to as \n \"reloading the target\".\n No API exists within Origen to reload only one of these component, so anytime you see a reference\n to the target being re-loaded it means that all three of the runtime environment components will be\n refreshed. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/loadorder/": {
    "title": "Load Order",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Load Order The number of global objects instantiated by a runtime environment should be kept to a minimum,\nhowever even the most basic of setups is likely to instantiate both a $dut and a $tester object. It is important that the initialization of each of these objects does not depend on the other\nto avoid introducing a dependency on the order in which they must be instantiated.\nSuch a dependency is fine when the application is young and the number of configurations is small, but as\nit grows this can become painful to manage and hard to anticipate when new engineers\ncome onto the team. Nonetheless it is very likely that sooner or later the case will arise where an object\nmust be initially configured differently depending on what tester platform it is\nrunning on, or on what top-level device object it has been integrated into. So how to do that initial configuration without introducing an instantiation\norder dependency? The answer is to use an on_create method to complete any initialization\noperations that depend on other objects. Using on_create on_create is an Origen callback\nand the callback guide should be consulted \nfor background information and for details on how to setup your model to use callbacks. Whenever Origen loads a runtime environment it will automatically call the on_create methods of any objects that have just come into being at the end of loading the target/environment files. It is therefore guaranteed that on_create will be run before any\noperations are invoked on the model outside of the target/environment files and it should be though of\nas similar to the standard Ruby initialize method but with the guarantee\nthat all runtime objects already exist by the time it is called. Here are some examples of cases where on_create should be used in\npreference to initialize : # In the $dut model def initialize # This would be creating an instantiation order dependency by doing this here, # i.e. $tester must exist before the $dut # $tester.do_something end def on_create # But not here $tester .do_something end # In a model that is not $dut def initialize # This would be creating an instantiation order dependency by doing this here, # i.e. $dut must exist before this model # if $dut.test_pin_muxed_with_reset? # add_pin_alias :test, :reset # else # add_pin :test # end end def on_create # But not here if $dut .test_pin_muxed_with_reset?\n add_pin_alias :test , :reset else add_pin :test end end Any Downside to Using on_create Instead of initialize? Not really. Using initialize for object construction/initialization is perhaps preferable in some\nsense since it is a standard Ruby method and therefore clearer for someone new to Origen\nto understand how the model is initially being configured. However generally anything that can be done in initialize can be safely\nmoved to on_create and the eventual state of the model instantiated by the\nruntime environment files will be identical. One major difference is that parameter options cannot be passed into on_create from the target, whereas options can be passed into the initialize method.\nSuch parameter dependent cases can still be moved to on_create but the\noptions will need to be saved by the initialize method. def initialize (options={}) @intial_options = options end def on_create if @intial_options [ :uti ] $tester .do_something end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/mode/": {
    "title": "Mode",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Mode Origen supports the following operating modes: Production - To be used whenever generating output destined for production use. Debug - To be used whenever developing an application. Simulation - To be used whenever generating output destined for a simulation. The default operation mode is production , and in this mode Origen will enforce the following\nrestrictions: Origen will not run if there are modified files within the environment workspace (i.e. edits that are not checked in) Origen will not run if plugins are imported from a local path reference Both debug and simulation modes remove these restrictions and are essentially the same\nas far as Origen is concerned. However plugin and application developers may implement\ndifferent behavior if the output is targeting simulation rather than real silicon. Note that the origen new command for creating a new application will make it\n look as though debug is the default mode, but this is just to make life convenient for the new\n application developer who is obviously about to go on and develop the new app. If the new\n app was cloned to a new workspace by another user, \n then it would come up in production mode. Getting and Setting the Mode The current default mode for a given application workspace can be queried by running the origen mode command, or origen m for short: > origen m\n\ndebug The mode can be changed by running the same command and supplying the desired mode: > origen m production\n\n> origen m debug\n\n> origen m simulation Any shortcut which provides enough detail to uniquely identify one of the available modes can be used: > origen m sim Additionally all Origen commands allow an override to be supplied at runtime. Aside from overriding\nthe current default mode, this will also override any mode setting applied by the current environment\nor target: > origen g my_pattern -m simulation Programmatically Getting and Setting the Mode Origen.mode returns an object representing the current mode ,\nthis provides the following API for sniffing the mode at runtime: Origen .mode.production? # => false Origen .mode.debug? # => true Origen .mode.simulation? # => false Note that simulation is also considered a debug mode, the API will respond as follows\nif simulation mode is set: Origen .mode.production? # => false Origen .mode.debug? # => true Origen .mode.simulation? # => true For example this API can be used to create simulation workarounds if required: if Origen .mode.simulation? # Generate something that is more simulation-friendly else # Generate a pattern construct which works on the tester, but doesn't simulate well end The mode can be set like this: Origen .mode = :production Origen .mode = :debug Origen .mode = :simulation Note that the mode can be frozen in which case the above will have no effect. If the mode\n is supplied via a --mode option to the current command, then it will be automatically frozen\n to allow it to override any mode assignment made by the target or environment files via the\n above API. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/production/": {
    "title": "Production Targets",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Production Targets The following concerns may arise when releasing your application to 3rd parties\nwho will then go on to use it to generate production grade IP: Your application may support many different devices and targets, however only\na subset of these may be considered production ready at a given release\npoint. When lots of targets are available how do we ensure that the user picks the\ncorrect one? This is certainly an area where Origen has scope for further improvement, but for\nnow the following system works adequately and is being used today in large-scale\nproduction applications… Select the Target by Maskset Number Establish the convention with your user base that when generating IP for production\nthe target must always be selected by providing the maskset number (including\nthe revision). So for example someone using an application to generate production IP for a device\nwith maskset 1M79X should select the target like this: origen t 1m79x This keeps things simple for the end user and removes the need for them to\nchoose a target. Mapping Masksets to Targets To enable the above feature a map must be added to your config/application.rb file like this: # config/application.rb config.production_targets = { \" 0m79x \" => \" eagle_0 \" , \" 0n30d \" => \" falcon_0 \" , \" 1n92a \" => \" osprey_1 \" ,\n} Now whenever a maskset number is entered as a target the above table will be referred\nto automatically to select the actual target file. If giving the user a choice over the actual target to use is unavoidable, the number\nof options can be reduced by mapping a given maskset to multiple targets: # config/application.rb config.production_targets = { \" 0m79x \" => [ \" eagle_0_func \" , \" eagle_0_bist \" ], \" 0n30d \" => \" falcon_0 \" , \" 1n92a \" => \" osprey_1 \" ,\n} Now a user selecting 0M79X will be presented with a message showing the two options\nand will be asked to choose one of them. Although not generally recommended, it is also possible to map multiple maskset numbers\nto the same target: # config/application.rb config.production_targets = { \" 0m79x \" => [ \" eagle_0_func \" , \" eagle_0_bist \" ], \" 0n30d \" => \" falcon_0 \" , \" 1n30d \" => \" falcon_0 \" , \" 1n92a \" => \" osprey_1 \" ,\n} Finally if a specific target(s) is not supported for a given release it can be easily disabled\nby commenting out the relevant line(s): # config/application.rb config.production_targets = { \" 0m79x \" => [ \" eagle_0_func \" , \" eagle_0_bist \" ], # \"0n30d\" => \"falcon_0\", # \"1n30d\" => \"falcon_0\", \" 1n92a \" => \" osprey_1 \" ,\n} Now any requests to select target 0N30D or 1N30D will give a not found error. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/programming/": {
    "title": "Programming",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Programming This guide discusses how to programmatically change the target, note that this will also\nreload the environment as discussed here: How the Runtime Environment is Applied If you start writing your own commands you may want to programmatically define or manipulate the target. A single target should always be loaded by using the following method, it\ncan be called again to later switch to a different target: Origen .load_target( \" falcon_1 \" ) To load the default target, or to reload the current target, call the same method\nwith no argument: Origen .load_target Warning - \n If you browse the API you may see some similar methods described for loading\n the target, however these should be avoided. The above method is the intended\n public API and will ensure that all dependencies are setup correctly. With the above warning in mind the Origen::Application::Target API can be consulted to see what additional methods are available to work with\nthe target,\nan instance of that class is available via Origen.target . For example to get the name of the current target: Origen .target.name # => \"falcon_1\" Configurable Targets Any options passed into the Origen.load_target method can be accessed\nfrom within the target and used to customize it by the caller. For example here is a target where the device version is left for the caller\nto specify: # target/falcon.rb $dut = MyApp :: Falcon .new( version : options[ :version ]) This would be used like this: Origen .load_target( \" falcon \" , version : 1 ) $dut .version # => 1 Origen .load_target( \" falcon \" , version : 2 ) $dut .version # => 2 Target Loops Target loops (where some code is repeated for a collection of targets) are\nvery common and Origen provides some dedicated helpers for this. The Origen.target.loop method is the most useful in a\ncommand situation and is designed to\ngenerate a loop based on the value of a :target key in an\noptions hash. This option can contain the name of a target or an array\ncontaining multiple names, and if none are present it will fall back to the\ndefault target following the normal conventions. It is therefore ideally suited to creating a command where the user can\nsupply one or more targets and could be used like this: opt_parser = OptionParser .new do |opts|\n opts.on( \" -t \" , \" --target NAME1,NAME2,NAME3 \" , Array , \" Override the default target, NAME can be a full path or a fragment of a target name \" ) { |t| options[ :target ] = t } end opt_parser.parse! ARGV Origen .target.loop(options) do |options| # The current target is already loaded, the name of the current target has been substituted into options[:target] puts \" The name of the current target is: #{ options[ :target ] } \" # Implement your command logic here... end The above would work with any of the following inputs: # Execute for the current default target\norigen my_command \n\n# Execute for a single specific target\norigen my_command -t falcon \n\n# Execute for multiple specific targets\norigen my_command -t falcon,eagle Production Target Loops If your application has defined a production target map then some additional methods are available to loop on that: Origen .target.each_production do |maskset| # Do something for each maskset line defined in the map end Origen .target.each_unique_production do |masksets| # Do something for each unique target defined in the map end The latter will only execute for unique target files, so if the same file is used\nby multiple maskset numbers it will only be looped once and the masksets argument\nwill be an array containing all maskset numbers that use that target. Forcing Debug Mode All of the above looping methods accept an option to force all targets to debug mode,\nthis can be useful depending on the purpose of your command, but should obviously\nbe avoided in cases where the command is concerned with generating production IP. Origen .target.each_production force_debug : true do |maskset| # As above except Origen is running in debug mode regardless of the mode defined by the environment end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/target/": {
    "title": "Target",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Target All targets are defined by files that reside in the target directory.\nTargets are regular Ruby files and they should be simply named: <identifier>.rb Normally the target is used to select the target device and they are simply named after\nthe device that they instantiate, e.g. target\n|-- eagle.rb\n|-- falcon.rb\n|-- vulture.rb\n`-- osprey.rb Creating a Target To create a new target, simply create the file containing whatever Ruby code you need.\nThey are usually very concise and normally only instantiate the\ntarget device model, here are some examples: # target/eagle.rb $dut = MyApp :: Eagle .new # target/falcon.rb $tester = MyApp :: Falcon .new A common variation on this theme is to have different targets for different versions of\nthe device that are available, or perhaps to configure the model differently for different\ntypes of test: # target/eagle_1.rb $dut = MyApp :: Eagle .new( version : 1 ) # target/eagle_2.rb $dut = MyApp :: Eagle .new( version : 2 ) # target/falcon_func.rb $dut = MyApp :: Falcon .new( configuration : :func ) # target/falcon_bist.rb $dut = MyApp :: Falcon .new( configuration : :bist ) Setting a Default Target A default target can be defined that will be used withing a new workspace unless the user\nspecifies otherwise. This is not required and should only be added if it makes sense within the\ncontext of the application - i.e. you may choose not to have a default to avoid the situation where the user\nbuilds something without really understanding what configuration they are targeting. A default is specified by creating a target file called target/default.rb ,\ntypically this is a symbolic link to another target file: ln -s target/falcon_bist.rb target/default.rb Getting and Setting the Target The current target for a given application workspace can be queried by running the origen target command, or origen t for short, this will show\nyou the content of the current target file: > origen t\n\nCurrent target: falcon_bist.rb\n**********************************************************************\n $dut = MyApp::Falcon.new(configuration: :bist)\n********************************************************************** The target can be changed by running the same command and supplying the desired target: > origen t target/falcon_func.rb\n\n> origen t falcon_bist As shown above, a full path or any snippet which is enough to uniquely identify one of the available\ntarget files is sufficient. Additionally all Origen commands allow an override to be supplied at runtime: > origen g my_pattern -t eagle_2 Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/app/": {
    "title": "Creating a New App",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Creating a New App Once you have installed Origen, you should\nfind that you now have access to an ‘origen’ executable from anywhere. Run origen from the command line and you should see this: Usage: origen COMMAND [ARGS]\n\nThe following commands are available:\n new Create a new Origen application or plugin. \"origen new my_app\" creates a\n new origen application workspace in \"./my_app\"\n interactive Start an interactive Origen console (short-cut alias: \"i\"), this is just\n IRB with the 'origen' lib loaded automatically\n fetch Automatically creates the workspace for the requested plugin and\n populates the latest version of the plugin (short-cut alias: \"f\")\n\nMany commands can be run with -h (or --help) for more information. Because you are currently outside of an Origen application, there is a reduced set\nof commands available. The origen new command should be used to generate a new application. Running the New Application Command To create a new application run the command like below and answer the questions\nat the command prompt: origen new my_app_name The new application will be custom built depending on your answers to the\nquestions and it should need no additional configuration to get started. You can immediately start adding your application specific logic to the lib directory. Documenting Your Application All new applications come with a pre-built framework for creating web-based\ndocumentation of your application - just like the page that you are currently\nreading. To build the initial example documents: origen web compile -a Then just follow the instructions to point your browser to the address that\nis output from the above command. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/commit/": {
    "title": "The Initial Commit",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen The Initial Commit Origen applications should be configured with details of the revision control\nrepository that they will be checked into, this will enable the following features: A release command which will tag and perform common post-release tasks. A common project-level history will be maintained, regardless of the underlying system used. An API for programmatic control of the revision control system, this provides\napplication and plugin developers with a common API to call regardless of the underlying system that\na given application uses - Revision Control API . A common command, origen rc to provide a common interface for application users to\nperform basic revision control operations regardless of their proficiency with the underlying system. Supported Systems Origen currently supports integration with the following revision control tools: Git DesignSync We would like to add support for Subversion and any other commonly used systems. If you have knowledge\nof how an additional target revision control system works and you would like to be involved in developing\nand piloting a driver for it, please get in touch via the community channels . Having said that, the Origen core team recommends using Git, even if you have had little or no\nexperience of it so far.\nIt has significant advantages and is fast becoming the de facto standard revision control tool used\nin software engineering. Initial Configuration Configuration information for your application resides in config/application.rb and an initial version of this file will have been created for you. This file contains a lot of configuration options which you should find fairly well commented.\nThe option that defines the revision control system is called rc_url and it should\nbe set as follows. For Git: # config/application.rb # Example for Github config.rc_url = \" git@github.com:myaccount/myapp.git \" # Example for Atlassian Stash config.rc_url = \" ssh://git@sw-stash.mycompany.net/myproject/myapp.git \" For DesignSync: # config/application.rb config.rc_url = \" sync://sync-1234:1234/myproject/myapp \" Setting Your Name and Email Origen will maintain a history log for your application at doc/history . The name of the person who did each release will be recorded\nif Origen can work out who you are (your name will also included within generated pattern headers\nand similar). Setting up your username and email in Git is the recommend way, even if you don’t actually\nuse Git for the given application.\nYou can set these details by executing the following commands: git config --global user.name \"John Doe\"\ngit config --global user.email johndoe@example.com If you don’t have Git available then alternatively you can set the following environment\nvariables: ORIGEN_NAME = \"John Doe\"\nORIGEN_EMAIL = \"johndoe@example.com\" You can test whether your changes have been picked up by opening an Origen console ( origen i )\nand running the following: User .current.name # => \"John Doe\" User .current.email # => \"johndoe@example.com\" An alternative path to determining your details could be via your company’s employee directory\nsystem. Origen’s company configuration settings allows\nthe credentials for an LDAP system to be entered, and this approach is used within NXP\nto identify the current user. We are not sure if the current support for this within Origen is\ngeneric enough to apply to other companies or not, please get in touch if\nyou are interested to help further develop and pilot this system for use within your company. Commit and Tag With your repository and user details setup, we can now do an initial commit and tag. Warning! - \n When executing this command pay attention to the prompts and confirm that\n the target repository reference exists and is correct. cd myapp\n\norigen rc init We are now ready to tag, to do this simply execute the following command and\nfollow the prompts: origen rc tag At this point Origen will send an email to your application’s maillist to notify them of the new release. History Your commit history will be saved in your history file which by default lives\nat doc/history . The content of that file is automatically formatted for future presentation on a web\npage, the Origen Release Notes are simply the Origen\ncore history file converted to HTML. When writing your release notes you can use markdown to control how they will be presented when they are later converted to HTML. You can also pre-write your release notes by writing them to release_note.txt in the top level of your application directory - \nrun origen rc tag -h for more details. Universal Revision Control Command Once your application has been committed for the first time you can then use the origen rc command to work with your revision control system (or you can\nof course continue to use it directly if you prefer). See origen rc -h for details of the available commands. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/company/": {
    "title": "Company Customization",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Company Customization A mechanism is provided to customize the Origen installation to a particular\ncompany. The main customization options that this currently provides are: An internal gem server. This can be used to distribute private Origen plugins\nwithin your company. When this is defined any new Origen applications that are created\nwill automatically come configured to read from your server in addition to rubygems.org. Integration with your company’s email delivery system, allowing your applications to\neasily send transactional email to their users. Integration with your company’s LDAP user authentication system. This API may not be\ngeneric enough yet, but it is used within NXP and we are keen to work\nwith anyone who wants to pilot it within another company. How The Configuration System Works Whenever an application is invoked, one of the first things that Origen will do is search\nfor a company configuration file called origen_site_config.yml . Starting from the application directory, the file system will be checked for the presence\nof any valid configuration files within the application’s root directory, and then in any of its parent\ndirectories until it hits the file system root directory. It will then check for a configuration file within the directory where Ruby is installed,\nand then again recursively through any of its parent directories. If multiple files are found then they will all be applied, with highest priority given\nto the files that are found first - i.e. those located closest to the current application. So for example, if everyone in your company uses a common Ruby installation, then you can put a config\nfile somewhere in Ruby’s directory and it will be globally applied. Alternatively, if all of your users have their workspaces underneath /proj or\nsimilar, then /proj/origen_site_config.yml may be a good place to put it.\nThis also provides a mechanism for per-project or even per-application overrides by\nadding additional config files higher up the tree. Creating the Configuration File To create a config file simple copy the default configuration from Origen core and edit it as required. The values present in this default file are the ones that will be applied by default in\nan installation where no custom configs are present. Testing the Configuration File To test if your configuration values are being applied, open a console within an\nOrigen application: origen i You can then query the current live values via the following API, where the method names\ncorrespond directly to the attribute names in the config file: Origen .site_config.gem_server # => nil Origen .site_config.gem_manage_bundler # => true Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/core/": {
    "title": "Core concepts",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Core concepts There are some core concepts and terminology that should be understood up front in order for\nthe rest of the documentation to make sense. Origen Application An ‘Origen Application’ is an engineering application of some sort that has been built using the Origen\nplatform. Origen Core ‘Origen Core’ refers to the Origen platform itself.\nAlthough different applications may be using different versions of Origen core at any one time,\nit does follow a single thread of development and the latest version should be able to support\nany Origen application. Origen core (or one of its plugins) should take care of all of the common tasks that are not application\nspecific. This means that an application developer should spend most of their time working\non things are unique to their particular application domain, and not worrying about how to open a file for\nwriting, or what the vector format for a given ATE is. APIs The term API stands for ‘Application Programming Interface’, which basically means a set of methods\nthat are exposed to the application to allow an engineer to programatically tell Origen what to do or build. Origen provides various APIs for different functions such as to describe the registers within a model,\nto generate pattern vectors, to build web pages, etc. Plugins The Origen platform provides a plugin system that allows 3rd parties to develop additional APIs to\nsupplement those provided by Origen core.\nThe Origen core team maintain a collection of important plugins which are considered extensions of\nOrigen core, but anyone in the community can create and share a plugin. Application owners can control what versions of what plugins are used in their application. Origen also has a mechanism for companies to maintain an internal plugin repository so that its plugin\nsystem can be used to internally distribute proprietary code such as test blocks for a given silicon\ntechnology. Ruby Ruby is the programming language that has been used to create Origen, all Origen applications are\nalso written in Ruby. Anatomy of an Origen Application An Origen application is comprised of the following main components: Models Models are the foundation of an Origen application and encapsulate all meta-data about the silicon\nobject that they represent.\nThis can include but is not limited to: registers and bits, pins, and specs. \nModels can also instantiate other models, thereby allowing a full hierarchical representation of the target\ndevice to be constructed. The models also track state (while generating a test pattern for example), with the register and pin\nobjects behaving much like their silicon counterparts. Controllers Controllers are a concept used in test engineering applications, where each model is assigned\na controller that will be responsible for defining APIs to perform pattern operations based on the\ngiven model. For example, the controller for a analog-to-digital converter (ATD) model might define a ‘convert’\nmethod. This method would define\nthe sequence of register transactions that are required to do an ATD conversion. A ‘method’ by the way, is simply a function that is associated with a given object in a object-oriented\nprogramming language. Drivers Drivers, is the term generally used to refer to objects that control a protocol (e.g. JTAG) or some\npiece of non-silicon hardware like a tester for example. There is no dedicated Driver class in Origen and these will usually be constructed from the same\nOrigen APIs as used for Models and Controllers. Indeed the drivers could well be composed of a model\nof the associated hardware and a controller for it. Target While your application could define many different models for different silicon products, the\nonly one that matters at any one time is the one that you are targeting - that is the one that the\ngiven output should be compatible with or represent. An application can have many targets where each one is responsible for instantiating a model (or models)\nthat represent a single runtime condition or context that Origen should apply when\ngenerating content. In test engineering applications, it is usual for the target to instantiate a single top-level\nmodel called $dut , representing the device under test. Generally the term ‘target’ is used to refer to the current combination of target + environment… Environment The environment can be thought of as a higher level target, which is used to define runtime setup that can\nbe used in conjunction with many different targets. In test engineering applications, it is usual to use the environment to instantiate the target\ntest platform, normally this is assigned to the global variable $tester . Templates Origen has two main ways of generating dynamic ASCII output, the first is via the use of templates.\nThis is the most flexible way of generating dynamic content - the application provides a template\nfile which has been marked up with where dynamic content should go, Origen will then process it\nwithin the context of the current target to generate a target specific version. Origen does not care about what the template represents and it could be anything from design IP, to\nweb pages, to tool configuration files. Sources The second way of generating content is via APIs. In this case the generated content comes from\ncalling Origen methods via Ruby code, rather than from compiling a pre-written template.\nFor example, when creating a test\npattern the act of writing a register can be expressed via an API - $dut.myreg.write!(0x5) -\nwhich will then be translated into the necessary vector stream by Origen. The files which co-ordinate the APIs to build a specific output are called source files. For test engineering applications, source files are used to describe patterns and test flows, though\nOrigen does also support a source-less approach to pattern generation based on the pattern name. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/gems/": {
    "title": "Understanding Gems",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Understanding Gems Ruby gems is the de facto standard package manager used by the Ruby community. This allows Ruby code\nto be packaged up so that it can be used throughout the community while being maintained from a single source. RubyGems.org provides free, centralized hosting for these gems and anyone\ncan create a new gem and upload it there. The job of a dependency manager is to resolve the gem version requirements\nof all gems used within an application (an application can depend on a gem, which may itself depend on\nother gems), so that they will all have access to a runtime environment containing the correct versions\nof the gems that they need.\nAt the time of writing, the Ruby gems system does not provide dependency management and this roll is\nfulfilled by a 3rd party tool called Bundler (though it is planned for Bundler to be integrated into Ruby\ngems in future). Origen and all of its plugins are distributed as Ruby gems and Bundler is used for the dependency\nmanagement. This guide will teach you how to use Ruby gems within your applications, tell you what you need to\nknow about using Bundler within the context of an Origen application, and give you an appreciation for\nhow the Origen runtime environment works. Specifying Gems Every Origen application has a file named Gemfile in its root directory, this is where\nthe gem dependencies for the given application will be specified. Here is an example Gemfile: source ' https://rubygems.org ' gem ' origen ' , ' >= 0.5 ' gem ' origen_debuggers ' gem ' roo ' gem ' origen_testers ' , path : ' /path/to/local/origen_testers ' gem ' origen_jtag ' , git : ' https://github.com/Origen-SDK/origen_jtag.git ' , ref : ' ad323f ' Points to note on the above: The source line specifies the gem library where the gems are hosted, in the Ruby community every\ngem is hosted on rubygems.org. Multiple sources can be used, and in practice for an Origen application this\nmeans that you can also add a company internal gem server to host private Origen plugins ( see below ). The origen gem import line shows how you can specify a dependency on a specific (or in this case minimum)\nversion of a given gem. See this section section of the RubyGems.org documentation for details on how to specify version numbers within a semantic\nversioning system. The origen_debuggers and roo lines show how to add Origen plugins and non-Origen\ngems to your application - the process is identical. Note that with no version specifier the latest production\nversion will be fetched when your gem bundle is built. The origen_testers line shows how to use a local copy of a given gem/plugin, this allows you\nto make changes to the given gem to add a feature or fix a bug, and then try it out within your application.\nOrigen will not allow execution with a path reference in production mode, since it is an inherently a non-reproducible\nenvironment for the future. Git references can also be used, here to pick up a specific commit of the origen_jtag gem direct from its repository. This can be used to pick up a pre-release version of a gem that contains\na specific feature or bug fix that you need immediately. The Gemfile system is provided by Bundler and the Bundler guide on Gemfiles can be consulted for more information. Importing Gems Origen takes care of setting up Bundler so that it will work in the common corporate scenario where the\nuser does not have the root access required to install the gems to the system Ruby installation.\nTo ensure that Bundler is properly configured, it is critical that an Origen command is run first in\na new application workspace, before any attempts are made to run Bundler directly. A common way of doing this is simply to run the origen -v command upon first setting\nup a new application workspace. This command will invoke Bundler with the required configuration\nautomatically and all of the required gems will be installed to ~/.origen/gems . Unfortunately Origen has not yet managed to completely wrap Bundler and sometimes there will be a\nneed to invoke it directly.\nThis usually occurs when you have changed the version requirements of a particular gem within\nyour Gemfile. Once you have changed the requirement you should run: bundle update <gem_name> This will tell Bundler to update the version of the given gem, but leave the versions of everything else\nas they are. Sometimes however the new version of the given gem will itself require a new version of\nsome other dependent gem, in that case you will get an error and you can try running this command\nto resolve it: bundle If you still have an error, then updating the complete bundle will resolve it: bundle update Note that this will fetch the latest version of every gem in your bundle that has an open-ended\nversion dependency. This can result in more changes to your environment than you really want/need\nand is therefore usually best kept as a last resort. Company Internal Gems As experience with Origen grows, you will begin to start creating your own plugins/gems, many of\nwhich will contain company proprietary IP that you will not want to release via the open source\ncommunity.\nTherefore a way of privately hosting these gems is required. An easy way of doing this initially is to use Git as the revision control tool for your plugins,\nthen you can use Git references within your Gemfiles as discussed above. A better solution though, is to setup a gem server within your company intranet, and we recommend this server .\nYou will likely need to work with your IT department to get this setup and maintained. When it is available, simply update your Gemfiles with the additional server like this: source ' https://rubygems.org ' source ' http://gems.mycompany.net:9292 ' gem ' origen ' gem ' private_test_block ' #... At that point you should also update your company’s Origen configuration with the details of the new server, in that way the origen new command will automatically\nconfigure your new applications with the required source reference in the Gemfiles. Gemfile.lock A file called Gemfile.lock will be created by Bundler in the application’s top-level\ndirectory and this should be checked into the revision control system. The purpose of this file is to record the absolute versions of all gems that are currently\nused by the given application. This means that when another developer, or one of your application’s\nusers, checks out a given version of your application into a new workspace, then the exact same\ngem versions will be used as when it was originally tested and checked in. This means that it safe (and in fact recommend) to leave the gem versions largely unspecified by your Gemfile,\nas it does not mean that different user environments will be running different gem versions. Executables If your gems provide command line executables that you wish to run, then these need to be invoked through\nBundler to make them run within the context of the application’s gem environment (bundle).\nSay for example that a given gem provides an executable called clean , then to run this from your\napplication’s command line you should do: bundle exec clean This applies to the origen executable too, however as this is cumbersome to write and\neasy to forget, Origen employs some tricks that will enforce this wrapping automatically, so Origen\ncan always be invoked with just: origen <command> Bundler will build wrapped executables within an application’s lbin directory, these\ncan be invoked directly without the need for the bundle exec prefix, so for example the clean executable could be correctly invoked by running: ./lbin/clean This is arguably easier to write than bundle exec , but it can still be easy to forget. Therefore\nif your application has a need to run 3rd party executables a lot, then it is recommend to add\nthe application’s lbin directory to your path so that you can simply run: clean System Origen It was noted in the Origen installation guide that the base Origen version installed to your system Ruby does not really matter, and it does not need to\nbe updated to the latest version of Origen on a regular basis. This is because the base Origen is only used to either create a new Origen application, or to initially\nboot an Origen command within an existing application. In both cases, the version used to initially boot\nOrigen is unimportant. In the case of creating a new application, Origen will always pull in the latest and greatest application generator\nand this is not statically linked to the version of Origen that is being executed to build the new app.\nSimilarly, when running an Origen application the thread will immediately switch over to run the version\nof Origen specified in the Gemfile instead of the system version. This system therefore ensures that application owners are in control of what version of Origen is used by\nthe users of their application, however neither the application owner or their users need permissions to\nupdate the system Ruby installation in order to achieve the required runtime environment.\nThey simply checkout the version of the given application that they want, and then Origen/Bundler\ntakes care of guaranteeing that the runtime environment is the correct one. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/installing/": {
    "title": "How to Install",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen How to Install Origen can be installed on Linux or Windows, this guide refers to the Linux installation. If running on windows is of interest then please see this guide instead: How to Install Origen on Windows Background Origen is distributed as a Ruby gem, which is the Ruby language’s package manager. Installation of Origen consists of the following steps: Install Pre-Requisites Install Ruby Install Origen Customize your installation (optional) Install Pre-Requisites To install Ruby, your system will need a C compiler and the Make utility. Installation of this\nwill vary depending on your particular Linux distribution, but for example on Ubuntu\nthe required build environment can be installed by running: sudo apt-get install build-essential It is also recommend to install a recent version (2.x) of Git, if you don’t know how to\ndo that, google for “how to install Git on <your distribution>“ . Install Ruby Origen requires a minimum Ruby version of 2.1.0 , you can install this or the latest version. If you are working from a personal Linux box (or VM), or if you want to install Ruby for\nyourself only, we recommend that you install it via rbenv and follow these installation instructions . This will install Ruby to your home directory and will not require you to have root access. If you are working from a corporate environment where a central Ruby installation will\nbe used by many users, we recommend that you follow the instructions on the official Ruby installation guide . Most likely building from source will be the most appropriate choice in this case, especially\nif dealing with an older Linux distribution, since the version available from your system’s\npackage manager will probably be quite old. If you have any particular problems installing Ruby, please use this discussion thread so that we can build up a record of common problems and solutions. Install Origen Once you have Ruby successfully installed, Origen can be installed very easily via: gem install origen --no-rdoc --no-ri You can then verify Origen availability by running origen -v at which point you should see something like this: Origen: 0.7.21 Congratulations, Origen is now installed! Note that the version of Origen that is installed to your Ruby installation does not need to\nbe kept up to date with the latest version of Origen. You can now consider your Ruby environment\nto be frozen for the foreseeable future. See the section on Understanding Gems for details on\nwhy that is. A Note on Nokogiri A common problem with the final step of installing Origen is to run into problems installing\na gem called Nokogiri (which is one of Origen’s dependencies). Generally the more recent your Linux distribution is, the less likely you are to have problems\nwith this. It is beyond the scope of this document to deal with likely causes and solutions, however if\nyou do run into problems google should yield plenty of hits of similar cases and hopefully\nwith guidelines on how to fix it. You can also report problems via this Origen forum thread on Nokogiri Installation Issues and we will do our best to provide help, or you can actually just comment below… Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/installwin/": {
    "title": "How to Install (Windows)",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen How to Install (Windows) Origen can be installed on Linux or Windows, this guide refers to the Windows installation. The lack of a package manager in windows makes it harder to install various packages from the command line. We recommend using chocolatey ; an open source windows package manager. You can imagine chocolatey to be somewhat like apt-get or other package managers on Linux, but built with Windows in mind. This guide will use chocolatey as the package manager to: Install Ruby Install Ruby-Dependencies Install Ruby-Development-Kit Install RubyGems Install RubyGems-SSL-workaround Install Utilities Note: Origen installation has been tested on Windows 7 only at this time, but we don’t think the installation process will be any different. An active internet connection is required before proceeding. If running on Linux is of interest then please see this guide instead: How to Install Origen on Linux Background Origen is distributed as a Ruby gem, which is the Ruby language’s package manager. Installation of Origen consists of the following steps: Install Ruby Install Ruby-Dependencies Install Origen Install Chocolatey All commands mentioned below need to be typed in the command prompt running as an administrator Start → run → cmd runas /user:Administrator if the above command does not work, please follow the solution here 1. Chocolatey To install the package manager (chocolatey), please type the text below in the command prompt (running as administrator) @powershell -NoProfile -ExecutionPolicy Bypass -Command \"iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin Install Ruby With the package manager installed, Installing Ruby is a breeze. Just type the following in the command prompt window (running as administrator) cinst ruby -y --force This should install Ruby v2.1.6 (latest supported by the package manager as of writing this guide) If the package manager upgrades to the latest version (v2.2.3), it will install that latest version instead. Please check the ruby version and make a note of it. We will need it later for the RubyGems workaround. ruby -v You might need to close the command prompt and open a new one after installing Ruby for ruby -v to work. Once the installer finishes, please close the current window and open a new one (as administrator) Install Ruby-Dependencies Install Ruby-Development-Kit In the new window, type the following cinst ruby2.devkit -y --force Install RubyGems In the same window, now type cinst rubygems -y --force Install RubyGems-SSL-workaround The latest version of Rubygems (that we installed above) is currently broken on Windows.\nHowever, there is a workaround that has been developed and it involves a series of steps.\nThe workaround also depends on which version of Ruby has been installed. The following commands will perform all the steps required for the workaround. If Ruby version installed is v2.1.X @powershell (new-object System.Net.WebClient).DownloadFile('https://github.com/rubygems/rubygems/releases/download/v2.0.15/rubygems-update-2.0.15.gem','C: ubygems-update-2.0.15.gem') && gem install --local C: ubygems-update-2.0.15.gem && update_rubygems --no-ri --no-rdoc && gem uninstall rubygems-update -x If Ruby version installed is v2.2.X @powershell (new-object System.Net.WebClient).DownloadFile('https://github.com/rubygems/rubygems/releases/download/v2.2.3/rubygems-update-2.2.3.gem’,'C: ubygems-update-2.2.3.gem') && gem install --local C: ubygems-update-2.2.3.gem && update_rubygems --no-ri --no-rdoc && gem uninstall rubygems-update -x Once the command finishes, please check the gem version installed by typing gem --version The Gem version should be v2.0.15 for Ruby v2.1.X or v2.2.3 for Ruby v2.2.X Before attempting to install the Origen gem, please confirm that the DevKit has been installed successfully and that it has successfully detected the ruby installation. Please follow the steps below: - open C:\\Tools\\DevKit\\config.yml in your favorite editor and type the path to your ruby installation directory \n (see image below for example). config.yml: - Open a command prompt window and type the following:\n - cd C:\\Tools\\DevKit\\\n - ruby dk.rb install commands: Install Origen Origen is available as a packaged gem and can be easily installed by typing: gem install origen --no-ri --no-rdoc *this can take several minutes to finish without updating the screen, so please be patient You can then verify Origen availability by running origen -v at which point you should see something like this: Origen: 0.7.21 Congratulations, Origen is now installed! Note that the version of Origen that is installed to your Ruby installation does not need to\nbe kept up to date with the latest version of Origen. You can now consider your Ruby environment\nto be frozen for the foreseeable future. See the section on Understanding Gems for details on\nwhy that is. Install Utilities It is also recommend to install a recent version (2.x) of Git We can do that easily now by typing cinst git -y This will install Git v2.5.2 (latest version available as of writing this guide) Optional: We recommend that you also install the following utilities for a more UNIX like experience on windows. UnxUtils (cinst unxutils -y) ConsoleZ (cinst consoleZ -y) Console2 (download from http://sourceforge.net/projects/console/) Video For your convenience, you can also watch the installation process in the video below. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/introduction/": {
    "title": "Introduction",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Introduction Welcome to the Origen guides! The Origen platform is written in Ruby\nand following this documentation will take you from a complete beginner to an\nOrigen expert. This site is focussed specifically on the Origen API, but for background on Ruby the\ninternet is your friend.\nRuby is very popular for web development and as such it is extremely easy to Google\nfor solutions to any Ruby-related problems that you may come across, or to find\ntutorials from which to learn. The official Ruby website contains a quick tutorial on Ruby to get you started: Ruby in 20 Minutes Previous engineers who have learned Ruby have recommend the following resources: Learn Ruby at rubymonk.com Learn Ruby at codeacademy.com Ruby for Newbies Video Tutorials Ruby Koans If you want to use regular expressions in your code the following website is invaluable: Regular Expression Editor Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/plugins/": {
    "title": null,
    "subtitle": null,
    "body": ""
  },
  "/release_notes/": {
    "title": null,
    "subtitle": null,
    "body": ""
  },
  "/videos/1-pattern-in-20-minutes/": {
    "title": "Create a Semiconductor ATE Pattern in 20 Minutes",
    "subtitle": "Videos",
    "body": "Videos Create a Semiconductor ATE Pattern in 20 Minutes Learn how to build a basic IP model and then use this to create a single-source pattern to target multiple ATEs and devices. Code Comments References Full source code on Github Defining registers Controllers Common tester API Code IP Model and Controller # lib/atd_test/atd.rb module ATDTest class ATD include Origen :: Model def initialize (options = {})\n instantiate_registers(options) end def instantiate_registers (options = {})\n reg :sc1 , 0x0 , size : 32 do |reg|\n reg.bit 7 , :coco , access : :ro reg.bit 6 , :aien reg.bit 5 , :diff reg.bit 4 .. 0 , :adch end reg :r , 0x10 , size : 32 do |reg|\n reg.bit 15 .. 0 , :d end end end end # lib/atd_test/atd_controller.rb module ATDTest class ATDController include Origen :: Controller def convert (channel)\n ss \" Performing an ATD conversion on channel #{ channel } \" sc1.adch.write!(channel)\n tester.wait time_in_us : 100 sc1.coco.assert!( 1 )\n r.d # Return the result bits end end end Test Pattern # pattern/atd_convert_ch10.rb Pattern .create do result = dut.atd0.convert( 10 )\n result.store! end Device Models and Controllers # lib/atd_test/falcon.rb module ATDTest class Falcon include Origen :: TopLevel def initialize (options = {})\n instantiate_pins(options)\n instantiate_registers(options)\n instantiate_sub_blocks(options) end def instantiate_pins (options = {})\n add_pin :tclk add_pin :tdi add_pin :tdo add_pin :tms add_pin :resetb add_pins :port_a , size : 8 end def instantiate_registers (options = {}) end def instantiate_sub_blocks (options = {})\n sub_block :atd , instances : 2 , class_name : ' ATD ' , base_address : [ 0x1000_0000 , 0x1000_1000 ] end end end # lib/atd_test/falcon_controller.rb module ATDTest class FalconController include Origen :: Controller include OrigenNexus # Hook the Nexus module into the register API, any register read # requests will use the Nexus by default def read_register (reg, options = {})\n nexus.read_register(reg, options) end # As above for write requests def write_register (reg, options = {})\n nexus.write_register(reg, options) end def startup (options)\n pp ' Enter test mode ' do tester.set_timeset( ' func_25mhz ' , 40 ) # Where 40 is the period in ns pin( :tclk ).drive!( 1 )\n pin( :resetb ).drive!( 1 )\n nexus.jtag.write_ir( 0x5 , size : 8 )\n nexus.jtag.write_dr( 0x25 , size : 16 )\n tester.wait time_in_us : 100 end end def shutdown (options)\n pp ' Reset the device ' do pin( :resetb ).drive!( 0 )\n pin( :tclk ).drive!( 0 ) end end end end # lib/atd_test/eagle.rb module ATDTest class Eagle include Origen :: TopLevel def initialize (options = {})\n instantiate_pins(options)\n instantiate_registers(options)\n instantiate_sub_blocks(options) end def instantiate_pins (options = {})\n add_pin :swd_clk add_pin :swd_dio add_pin :tclk add_pin :resetb add_pins :port_a , size : 8 end def instantiate_registers (options = {}) end def instantiate_sub_blocks (options = {})\n sub_block :atd , instances : 2 , class_name : ' ATD ' end end end # lib/atd_test/eagle_controller.rb module ATDTest class EagleController include Origen :: Controller include OrigenARMDebug include OrigenSWD def read_register (reg, options = {})\n arm_debug.read_register(reg, options) end # As above for write requests def write_register (reg, options = {})\n arm_debug.write_register(reg, options) end def startup (options)\n pp ' Enter test mode ' do tester.set_timeset( ' func_25mhz ' , 40 ) # Where 40 is the period in ns pin( :tclk ).drive!( 1 )\n pin( :resetb ).drive!( 1 )\n tester.wait time_in_us : 100 end end def shutdown (options)\n pp ' Reset the device ' do pin( :resetb ).drive!( 0 )\n pin( :tclk ).drive!( 0 ) end end end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/videos/2-model-data-import/": {
    "title": "Model Data Import and Documentation",
    "subtitle": "Videos",
    "body": "Videos Model Data Import and Documentation Learn how to import register data in IP-XACT format into a model and then generate a documentation view of it. Code Comments References Full source code on Github Cross Origen plugin Documentation Helpers plugin Example Model Documentation Callbacks Code Application Integration # lib/atd_test/atd.rb module ATDTest class ATD include Origen :: Model include CrossOrigen def initialize (options = {})\n cr_import( path : \" #{ Origen .root } /ipxact/atd.xml \" ) end end end # config/application.rb def after_web_site_compile (options) # Build the model documentation OrigenDocHelpers .generate_model_docs layout : \" #{ Origen .root } /templates/web/layouts/_basic.html.erb \" , tab : :model do |d|\n d.page model : $dut end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/videos/3-the-compiler/": {
    "title": "The Compiler",
    "subtitle": "Videos",
    "body": "Videos The Compiler Introduction to some basic features of the Origen compiler. Code Comments References Full source code on Github Compiler Guide Code Templates # templates/demo/_layout.txt.erb\nThis is the header <%= yield %> This is the footer # templates/demo/_sub_example.txt.erb\nHello from the sub template!\n\nThe value of argx is: <%= options[ :argx ] %> # templates/demo/example1.txt.erb\n% render \"layout.txt\" do\n\nHello from template example 1\n\n10 + 10 = 20\n\n% # This is a Ruby comment, it will not appear in the output\n\n% 10.times do |i|\nThis is loop <%= i %> % end\n\n% if 10 == 20\nThis is the true case\n% else \nThis is the false case\n% end <%= render \" templates/demo/sub_example.txt \" , argx : 100 %> % dut.atd0.regs.each do |name, reg| <%= name %> % end\n\n% end # templates/demo/example2.txt.erb <%= render \" templates/demo/sub_example.txt \" , argx : 200 %> Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/videos/4-create-header/": {
    "title": "Using the Compiler to Create a C Header",
    "subtitle": "Videos",
    "body": "Videos Using the Compiler to Create a C Header Shows a real world example of using the Origen compiler to create a C header file view of a model. Code Comments References Full source code on Github Compiler Guide Code Templates # templates/demo/atd.h.erb\n\n/* ============================================================================\n =============================== Module: ATD ================================\n ============================================================================ */\n\n% dut.atd0.regs.each do |name, reg| \ntypedef union ATD_ <%= name.to_s.upcase %> _union_tag { /* <%= reg.description.first %> */\n vuint32_t R;\n struct {\n% reg.named_bits(include_spacers: true).each do |bit_name, bits|\n% if bit_name\n vuint32_t <%= \" #{ bit_name.to_s.upcase } : #{ bits.size } ; \" .ljust( 30 ) %> /* <%= bits.description.first %> */\n% else \n vuint32_t <%= \" #{ bit_name.to_s.upcase } : #{ bits.size } ; \" .ljust( 30 ) %> % end \n% end \n } B;\n} ATD_ <%= name.to_s.upcase %> _tag;\n\n% end\n\nstruct ATD_tag {\n% dut.atd0.regs.each do |name, reg| <%= \" ATD_ #{ name.to_s.upcase } _tag #{ name.to_s.upcase } ; \" .ljust( 30 ) %> /* <%= reg.description.first %> */\n% end \n};\n\n% dut.atds.each_with_index do |atd, i|\n#define ATD_ <%= i %> (*(volatile struct ATD_tag *) <%= atd.base_address.to_hex %> UL)\n% end\n\n/* ATD */\n% dut.atds.each_with_index do |atd, i|\n% dut.atd0.regs.each do |name, reg| \n#define <%= \" ATD_ #{ i } _ #{ name.to_s.upcase } \" .ljust( 20 ) + \" ATD_ #{ i } . #{ name.to_s.upcase } .R \" .ljust( 20 ) %> /* <%= reg.description.first %> */\n% end\n\n% end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/videos/5-create-program-flow/": {
    "title": "Create a Test Program Flow for Multiple ATEs",
    "subtitle": "Videos",
    "body": "Videos Create a Test Program Flow for Multiple ATEs How to use the Origen Testers flow API to create complex test flow logic that can re-target to any platform. Code Comments References Full source code on Github Test Program Generator Guide Code # program/sort1.rb Flow .create do # This test will do something # # * Some bullets # * About this test test :test_a , bin : 3 , softbin : 100 , number : 1000 test :test_b , bin : 3 , softbin : 101 , number : 1010 , id : :test1 test :test_c , if_failed : :test1 if_job :p1 do test :p1_test1 , id : :p11 test :p1_test2 , id : :p12 test :p1_test3 , if_all_failed : [ :p11 , :p12 ]\n if_enable :bitmap do test :bitmap_test end end if_job :p2 do test :p2_test1 , id : :p21 test :p2_test2 , id : :p22 test :p2_test3 , if_any_passed : [ :p21 , :p22 ] end group \" 200Mhz Tests \" , id : :g200 do test :test200_1 test :test200_2 test :test200_3 end group \" 100Mhz Tests \" , if_failed : :g200 , id : :g100 do test :test100_1 , bin : 5 test :test100_2 , bin : 5 test :test100_3 , bin : 5 end if_job :p2 do import \" atd_tests \" , instances : 4 end pass 2 , if_ran : :g100 pass 1 end # program/_atd_tests.rb Flow .create do |options|\n\n options[ :instances ].times do |i|\n test \" atd_ramp_ #{ i } \" end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/videos/6-create-program-tests/": {
    "title": "Creating the Tests for a Test Program",
    "subtitle": "Videos",
    "body": "Videos Creating the Tests for a Test Program How to use the Origen Testers APIs to create tests for Teradyne and Advantest platforms Code Comments References Full source code on Github Test Program Generator Guide Origen Testers Release Notes Test Suite API ACTml API DCTml API Code # lib/atd_test/test_program/interface.rb module ATDTest module TestProgram class Interface include OrigenTesters :: ProgramGenerators def func (name, options={})\n name = test_name(name, options) # Create the test if tester.j750?\n ins = test_instances.functional(name) else ins = test_suites.add(name, options)\n ins.test_method = test_methods.ac_tml.functional_test(options) end apply_conditions(ins, options) # Create the pattern set entry pname = pattern_name(name, options) if tester.j750?\n patset_name = \" #{ name } _pset \" pat = patsets.add(patset_name, pattern : \" patterns/ATD/ #{ pname } .PAT \" )\n ins.pattern = patset_name else ins.pattern = pname end # Insert the test into the flow test(ins, options) end def para (name, options={})\n name = test_name(name, options) # Create the test if tester.j750?\n ins = test_instances.ppmu(name, options) else ins = test_suites.add(name, options)\n ins.test_method = test_methods.dc_tml.general_pmu(options) end apply_conditions(ins, options) # Create the pattern set entry if tester.j750?\n patset_name = \" #{ name } _pset \" pat = patsets.add(patset_name, pattern : \" patterns/ATD/ #{ pattern_name(name, options) } .PAT \" )\n ins.pattern = patset_name else end # Insert the test into the flow test(ins, options) end def apply_conditions (ins, options={}) if tester.j750?\n ins.ac_category = \" Spec \" ins.ac_selector = \" Default \" ins.dc_category = \" Spec \" if options[ :vdd ] if options[ :vdd ] == :max ins.dc_selector = \" Max \" elsif options[ :vdd ] == :min ins.dc_selector = \" Min \" elsif options[ :vdd ] == :nom ins.dc_selector = \" Default \" else fail \" Unknown vdd selector: #{ options[ :vdd ] } \" end else ins.dc_selector = \" Default \" end ins.time_sets = \" Tim \" ins.pin_levels = \" Lvl \" else ins.level_equation = 14 ins.level_spec = 1 ins.level_set = 1 end end def test_name (name, options={}) \" atd_ #{ name } \" end def pattern_name (name, options={}) \" #{ name } _pattern \" end end end end # program/sort1.rb Flow .create interface : \" ATDTest::TestProgram::Interface \" do # This func will do something # # * Some bullets # * About this test func :test_a , bin : 3 , softbin : 100 , number : 1000 , vdd : :max func :test_b , bin : 3 , softbin : 101 , number : 1010 , id : :test1 func :test_c , if_failed : :test1 func :test_d if_job :p1 do para :p1_test1 , id : :p11 , lo_limit : 10 .mV, hi_limit : 20 .mV\n func :p1_test2 , id : :p12 func :p1_test3 , if_all_failed : [ :p11 , :p12 ]\n if_enable :bitmap do func :bitmap_test end end if_job :p2 do func :p2_test1 , id : :p21 , vdd : :min func :p2_test2 , id : :p22 func :p2_test3 , if_any_passed : [ :p21 , :p22 ] end group \" 200Mhz Tests \" , id : :g200 do func :test200_1 func :test200_2 func :test200_3 end group \" 100Mhz Tests \" , if_failed : :g200 , id : :g100 do func :test100_1 , bin : 5 func :test100_2 , bin : 5 func :test100_3 , bin : 5 end if_job :p2 do import \" atd_tests \" , instances : 4 end pass 2 , if_ran : :g100 pass 1 end # program/_atd_tests.rb Flow .create do |options|\n\n options[ :instances ].times do |i|\n func \" atd_ramp_ #{ i } \" end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  }
}