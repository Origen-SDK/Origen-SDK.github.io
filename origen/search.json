{
  "/community/": {
    "title": null,
    "subtitle": null,
    "body": ""
  },
  "/guides/runtime/environment/": {
    "title": "Environment",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Environment All environments are defined by files that reside in the directory.\nEnvironments are regular Ruby files and they should be simply named: environment <identifier>.rb In a test engineering application where the environment is used to select the target test platform,\nthey are normally named after the tester, e.g. environment\n|-- j750.rb\n|-- uflex.rb\n|-- v93k.rb\n`-- jlink.rb Creating an Environment To create a new environment, simply create the file containing whatever Ruby code you need.\nThey are usually very concise and in a test engineering application would normally only instantiate the\ntarget tester driver, here are some examples: :: .new # environment/j750.rb = $tester OrigenTesters J750 # environment/v93k.rb = $tester OrigenTesters :: .new V93K # environment/jlink.rb $tester = OrigenDebuggers :: .new JLink If the given driver supports configuration options, then you may have some variations\nfor a given platform - e.g. to configure the driver slightly differently\nfor generating probe test patterns: j750_probe.rb # environment/j750_probe.rb = $tester :: OrigenTesters .new J750 .available_power_supplies = $tester 64 Setting a Default Environment A default environment can be defined that will be used withing a new workspace unless the user\nspecifies otherwise. This is not required and should only be added if it makes sense within the\ncontext of the application - i.e. you may choose not to have a default to avoid the situation where the user\nbuilds something without really understanding what configuration they are targeting. A default is specified by creating an environment file called environment/default.rb ,\ntypically this is a symbolic link to another environment file: ln -s environment/j750.rb environment/default.rb Getting and Setting the Environment The current environment for a given application workspace can be queried by running the origen environment command, or for short, this will show\nyou the content of the current environment file: origen e > origen e\n\nCurrent environment: j750.rb\n**********************************************************************\n $tester = OrigenTesters::J750.new\n********************************************************************** The environment can be changed by running the same command and supplying the desired environment: > origen e environment/j750.rb\n\n> origen e v93k As shown above, a full path or any snippet which is enough to uniquely identify one of the available\nenvironment files is sufficient. Additionally all Origen commands allow an override to be supplied at runtime: > origen g my_pattern -e jlink Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/global/": {
    "title": "Global Setup",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Global Setup Origen re-loads the runtime environment immediately before every pattern, test program or compile\njob.\nTherefore both the target and environment files can be used to set some global state that\nwill later be applied to all patterns or similar. Note that you cannot actually generate any output from the target or environment, that will only\nhappen from within the pattern, program or template source files. However what you\ncan do is setup some initial state within your models to influence what will\nbe generated by the source files later. In other words any changes that you make to the models after instantiating them\nwill persist into the remainder of the generation flow.\nIt is not recommended to put a lot of logic into target files, but when used\nresponsibly this can be a useful addition to your tool box. Origen Configuration The target and environment files can also be used \nto override any Origen configuration settings that would otherwise be specified in\nthe config/application.rb file. An example might be to set up product-specific LSF strings for utilization tracking: # target/eagle_1.rb = :: $dut MyApp .new( Eagle : version ) 1 Origen .config.lsf.project = \" eagle.te \" # target/falcon_1.rb = $dut MyApp :: .new( Falcon version : ) 1 Origen .config.lsf.project = \" falcon.te \" Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/introduction/": {
    "title": "Introduction",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Introduction Typically an Origen application will contain source code to generate IP that can be\napplied to many different products, and/or which can run on many different test platforms.\nIt is the job of the and the target environment to setup the runtime conditions that will\ndefine what combination of product and tester platform will be targeted by the\ngenerated output. The target is normally used to define the product side of the runtime environment, with one\ntarget file existing for every product/device that the application supports.\nTarget files are usually very short and normally just instantiate the model of the target\ndevice, assigning it to the global variable $dut . For test engineering applications, the test platform selection is usually handled by environment\nfiles. These are very similar to target files and there is usually one per supported test\nplatform. Each environment will typically instantiate the target tester model/driver, assigning it\nto the global variable $tester .\nFor non-test engineering applications, the environment layer can either be omitted or\nelse it can be used to define whatever other global state makes sense to be applied across\nmultiple device targets. Additionally, Origen has the concept of an operating mode and this can be considered a\nthird component of the runtime environment. How the Runtime Environment is Applied Before compiling any template, or generating any pattern, test program or other source file,\nOrigen will do the following: Apply the active mode Execute the active environment file Execute the active target file This means that the active environment can override the active mode, and that the active target can\noverride both the mode and the environment. This sequence will be repeated between jobs if multiple\nfiles are being compiled/generated by a given Origen thread of execution (each source files is an individual job).\nThis prevents model state from a previous job from carrying over to the next one and ensures that the\noutput is never affected by generation order. This sequence of reloading the mode, environment and target is generally referred to as \n \"reloading the target\".\n No API exists within Origen to reload only one of these component, so anytime you see a reference\n to the target being re-loaded it means that all three of the runtime environment components will be\n refreshed. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/loadorder/": {
    "title": "Load Order",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Load Order The number of global objects instantiated by a runtime environment should be kept to a minimum,\nhowever even the most basic of setups is likely to instantiate both a and a $dut $tester object. It is important that the initialization of each of these objects does not depend on the other\nto avoid introducing a dependency on the order in which they must be instantiated.\nSuch a dependency is fine when the application is young and the number of configurations is small, but as\nit grows this can become painful to manage and hard to anticipate when new engineers\ncome onto the team. Nonetheless it is very likely that sooner or later the case will arise where an object\nmust be initially configured differently depending on what tester platform it is\nrunning on, or on what top-level device object it has been integrated into. So how to do that initial configuration without introducing an instantiation\norder dependency? The answer is to use an method to complete any initialization\noperations that depend on other objects. on_create Using on_create on_create is an Origen callback\nand the should be consulted \nfor background information and for details on how to setup your model to use callbacks. callback guide Whenever Origen loads a runtime environment it will automatically call the methods of any objects that have just come into being at the end of loading the target/environment files. on_create It is therefore guaranteed that on_create will be run before any\noperations are invoked on the model outside of the target/environment files and it should be though of\nas similar to the standard Ruby initialize method but with the guarantee\nthat all runtime objects already exist by the time it is called. Here are some examples of cases where on_create should be used in\npreference to : initialize # In the $dut model def initialize # This would be creating an instantiation order dependency by doing this here, # i.e. $tester must exist before the $dut # $tester.do_something end def on_create # But not here .do_something $tester end # In a model that is not $dut def initialize # This would be creating an instantiation order dependency by doing this here, # i.e. $dut must exist before this model # if $dut.test_pin_muxed_with_reset? # add_pin_alias :test, :reset # else # add_pin :test # end end def on_create # But not here if .test_pin_muxed_with_reset?\n add_pin_alias $dut :test , :reset else add_pin :test end end Any Downside to Using on_create Instead of initialize? Not really. Using initialize for object construction/initialization is perhaps preferable in some\nsense since it is a standard Ruby method and therefore clearer for someone new to Origen\nto understand how the model is initially being configured. However generally anything that can be done in can be safely\nmoved to initialize and the eventual state of the model instantiated by the\nruntime environment files will be identical. on_create One major difference is that parameter options cannot be passed into from the target, whereas options can be passed into the on_create initialize method.\nSuch parameter dependent cases can still be moved to on_create but the\noptions will need to be saved by the method. initialize def initialize = options (options={}) @intial_options end def on_create if @intial_options [ :uti ] .do_something $tester end end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/mode/": {
    "title": "Mode",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Mode Origen supports the following operating modes: Production - To be used whenever generating output destined for production use. - To be used whenever developing an application. Debug Simulation - To be used whenever generating output destined for a simulation. The default operation mode is production , and in this mode Origen will enforce the following\nrestrictions: Origen will not run if there are modified files within the environment workspace (i.e. edits that are not checked in) Origen will not run if plugins are imported from a local path reference Both debug and modes remove these restrictions and are essentially the same\nas far as Origen is concerned. However plugin and application developers may implement\ndifferent behavior if the output is targeting simulation rather than real silicon. simulation Note that the command for creating a new application will make it\n look as though origen new debug is the default mode, but this is just to make life convenient for the new\n application developer who is obviously about to go on and develop the new app. If the new\n app was cloned to a new workspace by another user, \n then it would come up in mode. production Getting and Setting the Mode The current default mode for a given application workspace can be queried by running the command, or origen mode for short: origen m > origen m\n\ndebug The mode can be changed by running the same command and supplying the desired mode: > origen m production\n\n> origen m debug\n\n> origen m simulation Any shortcut which provides enough detail to uniquely identify one of the available modes can be used: > origen m sim Additionally all Origen commands allow an override to be supplied at runtime. Aside from overriding\nthe current default mode, this will also override any mode setting applied by the current environment\nor target: > origen g my_pattern -m simulation Programmatically Getting and Setting the Mode returns an Origen.mode object representing the current mode ,\nthis provides the following API for sniffing the mode at runtime: .mode.production? Origen # => false Origen .mode.debug? # => true Origen .mode.simulation? # => false Note that is also considered a simulation mode, the API will respond as follows\nif debug mode is set: simulation .mode.production? Origen # => false Origen .mode.debug? # => true Origen .mode.simulation? # => true For example this API can be used to create simulation workarounds if required: if Origen .mode.simulation? # Generate something that is more simulation-friendly else # Generate a pattern construct which works on the tester, but doesn't simulate well end The mode can be set like this: .mode = Origen :production Origen .mode = Origen :debug .mode = :simulation Note that the mode can be frozen in which case the above will have no effect. If the mode\n is supplied via a option to the current command, then it will be automatically frozen\n to allow it to override any mode assignment made by the target or environment files via the\n above API. --mode Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/production/": {
    "title": "Production Targets",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Production Targets The following concerns may arise when releasing your application to 3rd parties\nwho will then go on to use it to generate production grade IP: Your application may support many different devices and targets, however only\na subset of these may be considered production ready at a given release\npoint. When lots of targets are available how do we ensure that the user picks the\ncorrect one? This is certainly an area where Origen has scope for further improvement, but for\nnow the following system works adequately and is being used today in large-scale\nproduction applications… Select the Target by Maskset Number Establish the convention with your user base that when generating IP for production\nthe target must always be selected by providing the maskset number (including\nthe revision). So for example someone using an application to generate production IP for a device\nwith maskset 1M79X should select the target like this: origen t 1m79x This keeps things simple for the end user and removes the need for them to\nchoose a target. Mapping Masksets to Targets To enable the above feature a map must be added to your config/application.rb file like this: # config/application.rb config.production_targets = { \" 0m79x \" => \" , eagle_0 \" => \" \" \" 0n30d , falcon_0 \" \" => \" 1n92a ,\n} \" osprey_1 \" Now whenever a maskset number is entered as a target the above table will be referred\nto automatically to select the actual target file. If giving the user a choice over the actual target to use is unavoidable, the number\nof options can be reduced by mapping a given maskset to multiple targets: config.production_targets = { \" # config/application.rb => [ \" \" \" 0m79x eagle_0_func \" , eagle_0_bist \" ], \" => 0n30d \" \" falcon_0 \" , 1n92a \" => \" \" ,\n} osprey_1 \" Now a user selecting 0M79X will be presented with a message showing the two options\nand will be asked to choose one of them. Although not generally recommended, it is also possible to map multiple maskset numbers\nto the same target: # config/application.rb config.production_targets = { 0m79x => [ \" \" eagle_0_func \" , \" \" eagle_0_bist ], \" \" => 0n30d \" \" , falcon_0 \" => \" 1n30d \" , \" falcon_0 \" \" 1n92a \" => \" osprey_1 ,\n} \" Finally if a specific target(s) is not supported for a given release it can be easily disabled\nby commenting out the relevant line(s): config.production_targets = { # config/application.rb \" => [ 0m79x \" \" , eagle_0_func \" \" eagle_0_bist \" ], # \"0n30d\" => \"falcon_0\", # \"1n30d\" => \"falcon_0\", \" => 1n92a \" \" ,\n} osprey_1 \" Now any requests to select target 0N30D or 1N30D will give a not found error. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/programming/": {
    "title": "Programming",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Programming This guide discusses how to programmatically change the target, note that this will also\nreload the environment as discussed here: How the Runtime Environment is Applied If you start you may want to programmatically define or manipulate the target. writing your own commands A single target should always be loaded by using the following method, it\ncan be called again to later switch to a different target: .load_target( Origen \" ) falcon_1 \" Warning - \n If you browse the API you may see some similar methods described for loading\n the target, however these should be avoided. The above method is the intended\n public API and will ensure that all dependencies are setup correctly. With the above warning in mind the can be consulted to see what additional methods are available to work with\nthe target,\nan instance of that class is available via Origen::Application::Target API Origen.target . For example to get the name of the current target: Origen .target.name # => \"falcon_1\" Configurable Targets Any options passed into the Origen.load_target method can be accessed\nfrom within the target and used to customize it by the caller. For example here is a target where the device version is left for the caller\nto specify: :: $dut = # target/falcon.rb MyApp Falcon .new( version : options[ ]) :version This would be used like this: Origen .load_target( , \" : version ) falcon \" 1 $dut .version # => 1 .load_target( \" , version Origen falcon \" : ) 2 .version $dut # => 2 Target Loops Target loops (where some code is repeated for a collection of targets) are\nvery common and Origen provides some dedicated helpers for this. The method is the most useful in a\ncommand situation and is designed to\ngenerate a loop based on the value of a Origen.target.loop :target key in an\noptions hash. This option can contain the name of a target or an array\ncontaining multiple names, and if none are present it will fall back to the\ndefault target following the normal conventions. It is therefore ideally suited to creating a command where the user can\nsupply one or more targets and could be used like this: opt_parser = .new OptionParser do |opts|\n opts.on( , \" -t \" , --target NAME1,NAME2,NAME3 ] = t } \" \" , Array \" Override the default target, NAME can be a full path or a fragment of a target name \" ) { |t| options[ :target opt_parser.parse! .target.loop(options) end ARGV Origen |options| do # The current target is already loaded, the name of the current target has been substituted into options[:target] puts \" The name of the current target is: #{ options[ } ] :target \" # Implement your command logic here... end The above would work with any of the following inputs: # Execute for the current default target\norigen my_command \n\n# Execute for a single specific target\norigen my_command -t falcon \n\n# Execute for multiple specific targets\norigen my_command -t falcon,eagle Production Target Loops If your application has defined a then some additional methods are available to loop on that: production target map .target.each_production Origen do |maskset| # Do something for each maskset line defined in the map end .target.each_unique_production Origen |masksets| do # Do something for each unique target defined in the map end The latter will only execute for unique target files, so if the same file is used\nby multiple maskset numbers it will only be looped once and the masksets argument\nwill be an array containing all maskset numbers that use that target. Forcing Debug Mode All of the above looping methods accept an option to force all targets to debug mode,\nthis can be useful depending on the purpose of your command, but should obviously\nbe avoided in cases where the command is concerned with generating production IP. Origen .target.each_production force_debug : true do |maskset| # As above except Origen is running in debug mode regardless of the mode defined by the environment end Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/runtime/target/": {
    "title": "Target",
    "subtitle": "Runtime Environment",
    "body": "Runtime Environment Target All targets are defined by files that reside in the directory.\nTargets are regular Ruby files and they should be simply named: target <identifier>.rb Normally the target is used to select the target device and they are simply named after\nthe device that they instantiate, e.g. target\n|-- eagle.rb\n|-- falcon.rb\n|-- vulture.rb\n`-- osprey.rb Creating a Target To create a new target, simply create the file containing whatever Ruby code you need.\nThey are usually very concise and normally only instantiate the\ntarget device model, here are some examples: # target/eagle.rb = :: $dut MyApp .new Eagle # target/falcon.rb = $tester :: MyApp .new Falcon A common variation on this theme is to have different targets for different versions of\nthe device that are available, or perhaps to configure the model differently for different\ntypes of test: # target/eagle_1.rb = $dut MyApp :: .new( Eagle : version 1 ) # target/eagle_2.rb $dut = MyApp :: Eagle .new( version : 2 ) # target/falcon_func.rb = MyApp $dut :: .new( Falcon : configuration :func ) # target/falcon_bist.rb = $dut MyApp :: .new( Falcon : configuration :bist ) Setting a Default Target A default target can be defined that will be used withing a new workspace unless the user\nspecifies otherwise. This is not required and should only be added if it makes sense within the\ncontext of the application - i.e. you may choose not to have a default to avoid the situation where the user\nbuilds something without really understanding what configuration they are targeting. A default is specified by creating a target file called target/default.rb ,\ntypically this is a symbolic link to another target file: ln -s target/falcon_bist.rb target/default.rb Getting and Setting the Target The current target for a given application workspace can be queried by running the command, or origen target for short, this will show\nyou the content of the current target file: origen t > origen t\n\nCurrent target: falcon_bist.rb\n**********************************************************************\n $dut = MyApp::Falcon.new(configuration: :bist)\n********************************************************************** The target can be changed by running the same command and supplying the desired target: > origen t target/falcon_func.rb\n\n> origen t falcon_bist As shown above, a full path or any snippet which is enough to uniquely identify one of the available\ntarget files is sufficient. Additionally all Origen commands allow an override to be supplied at runtime: > origen g my_pattern -t eagle_2 Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/app/": {
    "title": "Creating a New App",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Creating a New App Once you have installed Origen, you should\nfind that you now have access to an ‘origen’ executable from anywhere. Run from the command line and you should see this: origen Usage: origen COMMAND [ARGS]\n\nThe following commands are available:\n new Create a new Origen application or plugin. \"origen new my_app\" creates a\n new origen application workspace in \"./my_app\"\n interactive Start an interactive Origen console (short-cut alias: \"i\"), this is just\n IRB with the 'origen' lib loaded automatically\n fetch Automatically creates the workspace for the requested plugin and\n populates the latest version of the plugin (short-cut alias: \"f\")\n\nMany commands can be run with -h (or --help) for more information. Because you are currently outside of an Origen application, there is a reduced set\nof commands available. The origen new command should be used to generate a new application. Running the New Application Command To create a new application run the command like below and answer the questions\nat the command prompt: origen new my_app_name The new application will be custom built depending on your answers to the\nquestions and it should need no additional configuration to get started. You can immediately start adding your application specific logic to the directory. lib Documenting Your Application All new applications come with a pre-built framework for creating web-based\ndocumentation of your application - just like the page that you are currently\nreading. To build the initial example documents: origen web compile -a Then just follow the instructions to point your browser to the address that\nis output from the above command. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/commit/": {
    "title": "The Initial Commit",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen The Initial Commit Origen applications should be configured with details of the revision control\nrepository that they will be checked into, this will enable the following features: A release command which will tag and perform common post-release tasks. A common project-level history will be maintained, regardless of the underlying system used. An API for programmatic control of the revision control system, this provides\napplication and plugin developers with a common API to call regardless of the underlying system that\na given application uses - . Revision Control API A common command, origen rc to provide a common interface for application users to\nperform basic revision control operations regardless of their proficiency with the underlying system. Supported Systems Origen currently supports integration with the following revision control tools: Git DesignSync We would like to add support for Subversion and any other commonly used systems. If you have knowledge\nof how an additional target revision control system works and you would like to be involved in developing\nand piloting a driver for it, please get in touch via the . community channels Having said that, the Origen core team recommends using Git, even if you have had little or no\nexperience of it so far.\nIt has significant advantages and is fast becoming the de facto standard revision control tool used\nin software engineering. Initial Configuration Configuration information for your application resides in config/application.rb and an initial version of this file will have been created for you. This file contains a lot of configuration options which you should find fairly well commented.\nThe option that defines the revision control system is called rc_url and it should\nbe set as follows. For Git: config.rc_url = # config/application.rb # Example for Github \" git@github.com:myaccount/myapp.git \" # Example for Atlassian Stash config.rc_url = \" ssh://git@sw-stash.mycompany.net/myproject/myapp.git \" For DesignSync: config.rc_url = # config/application.rb \" sync://sync-1234:1234/myproject/myapp \" Setting Your Name and Email Origen will maintain a history log for your application at doc/history . The name of the person who did each release will be recorded\nif Origen can work out who you are (your name will also included within generated pattern headers\nand similar). Setting up your username and email in Git is the recommend way, even if you don’t actually\nuse Git for the given application.\nYou can set these details by executing the following commands: git config --global user.name \"John Doe\"\ngit config --global user.email johndoe@example.com If you don’t have Git available then alternatively you can set the following environment\nvariables: ORIGEN_NAME = \"John Doe\"\nORIGEN_EMAIL = \"johndoe@example.com\" You can test whether your changes have been picked up by opening an Origen console ( )\nand running the following: origen i .current.name User # => \"John Doe\" .current.email User # => \"johndoe@example.com\" An alternative path to determining your details could be via your company’s employee directory\nsystem. Origen’s company configuration settings allows\nthe credentials for an LDAP system to be entered, and this approach is used within Freescale\nto identify the current user. We are not sure if the current support for this within Origen is\ngeneric enough to apply to other companies or not, please if\nyou are interested to help further develop and pilot this system for use within your company. get in touch Commit and Tag With your repository and user details setup, we can now do an initial commit and tag. Warning! - \n When executing this command pay attention to the prompts and confirm that\n the target repository reference exists and is correct. cd myapp\n\norigen rc init We are now ready to tag, to do this simply execute the following command and\nfollow the prompts: origen rc tag At this point Origen would normally have emailed you and your application’s subscribers to\nnotify them of the new release, however we are still working on how this subscription system\nshould work in the open source world. Expect it to be available within the coming months. History Your commit history will be saved in your history file which by default lives\nat doc/history . The content of that file is automatically formatted for future presentation on a web\npage, the Origen are simply the Origen\ncore history file converted to HTML. Release Notes When writing your release notes you can use markdown to control how they will be presented when they are later converted to HTML. You can also pre-write your release notes by writing them to in the top level of your application directory - \nrun release_note.txt origen rc tag -h for more details. Universal Revision Control Command Once your application has been committed for the first time you can then use the command to work with your revision control system (or you can\nof course continue to use it directly if you prefer). origen rc See for details of the available commands. origen rc -h Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/company/": {
    "title": "Company Customization",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Company Customization A mechanism is provided to customize the Origen installation to a particular\ncompany. The main customization options that this currently provides are: An internal gem server. This can be used to distribute private Origen plugins\nwithin your company. When this is defined any new Origen applications that are created\nwill automatically come configured to read from your server in addition to rubygems.org. Integration with your company’s email delivery system, allowing your applications to\neasily send transactional email to their users. Integration with your company’s LDAP user authentication system. This API may not be\ngeneric enough yet, but it is used within Freescale and we are keen to work\nwith anyone who wants to pilot it within another company. How The Configuration System Works Whenever an application is invoked, one of the first things that Origen will do is search\nfor a company configuration file called . origen_site_config.yml Starting from the application directory, the file system will be checked for the presence\nof any valid configuration files within the application’s root directory, and then in any of its parent\ndirectories until it hits the file system root directory. It will then check for a configuration file within the directory where Ruby is installed,\nand then again recursively through any of its parent directories. If multiple files are found then they will all be applied, with highest priority given\nto the files that are found first - i.e. those located closest to the current application. So for example, if everyone in your company uses a common Ruby installation, then you can put a config\nfile somewhere in Ruby’s directory and it will be globally applied. Alternatively, if all of your users have their workspaces underneath /proj or\nsimilar, then may be a good place to put it.\nThis also provides a mechanism for per-project or even per-application overrides by\nadding additional config files higher up the tree. /proj/origen_site_config.yml Creating the Configuration File To create a config file simple copy the default configuration from Origen core and edit it as required. The values present in this default file are the ones that will be applied by default in\nan installation where no custom configs are present. Testing the Configuration File To test if your configuration values are being applied, open a console within an\nOrigen application: origen i You can then query the current live values via the following API, where the method names\ncorrespond directly to the attribute names in the config file: .site_config.gem_server Origen # => nil Origen .site_config.gem_manage_bundler # => true Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/core/": {
    "title": "Core concepts",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Core concepts There are some core concepts and terminology that should be understood up front in order for\nthe rest of the documentation to make sense. Origen Application An ‘Origen Application’ is an engineering application of some sort that has been built using the Origen\nplatform. Origen Core ‘Origen Core’ refers to the Origen platform itself.\nAlthough different applications may be using different versions of Origen core at any one time,\nit does follow a single thread of development and the latest version should be able to support\nany Origen application. Origen core (or one of its plugins) should take care of all of the common tasks that are not application\nspecific. This means that an application developer should spend most of their time working\non things are unique to their particular application domain, and not worrying about how to open a file for\nwriting, or what the vector format for a given ATE is. APIs The term API stands for ‘Application Programming Interface’, which basically means a set of methods\nthat are exposed to the application to allow an engineer to programatically tell Origen what to do or build. Origen provides various APIs for different functions such as to describe the registers within a model,\nto generate pattern vectors, to build web pages, etc. Plugins The Origen platform provides a plugin system that allows 3rd parties to develop additional APIs to\nsupplement those provided by Origen core.\nThe Origen core team maintain a collection of important plugins which are considered extensions of\nOrigen core, but anyone in the community can create and share a plugin. Application owners can control what versions of what plugins are used in their application. Origen also has a mechanism for companies to maintain an internal plugin repository so that its plugin\nsystem can be used to internally distribute proprietary code such as test blocks for a given silicon\ntechnology. Ruby Ruby is the programming language that has been used to create Origen, all Origen applications are\nalso written in Ruby. Anatomy of an Origen Application An Origen application is comprised of the following main components: Models Models are the foundation of an Origen application and encapsulate all meta-data about the silicon\nobject that they represent.\nThis can include but is not limited to: registers and bits, pins, and specs. \nModels can also instantiate other models, thereby allowing a full hierarchical representation of the target\ndevice to be constructed. The models also track state (while generating a test pattern for example), with the register and pin\nobjects behaving much like their silicon counterparts. Controllers Controllers are a concept used in test engineering applications, where each model is assigned\na controller that will be responsible for defining APIs to perform pattern operations based on the\ngiven model. For example, the controller for a analog-to-digital converter (ATD) model might define a ‘convert’\nmethod. This method would define\nthe sequence of register transactions that are required to do an ATD conversion. A ‘method’ by the way, is simply a function that is associated with a given object in a object-oriented\nprogramming language. Drivers Drivers, is the term generally used to refer to objects that control a protocol (e.g. JTAG) or some\npiece of non-silicon hardware like a tester for example. There is no dedicated Driver class in Origen and these will usually be constructed from the same\nOrigen APIs as used for Models and Controllers. Indeed the drivers could well be composed of a model\nof the associated hardware and a controller for it. Target While your application could define many different models for different silicon products, the\nonly one that matters at any one time is the one that you are targeting - that is the one that the\ngiven output should be compatible with or represent. An application can have many targets where each one is responsible for instantiating a model (or models)\nthat represent a single runtime condition or context that Origen should apply when\ngenerating content. In test engineering applications, it is usual for the target to instantiate a single top-level\nmodel called , representing the device under test. $dut Generally the term ‘target’ is used to refer to the current combination of target + environment… Environment The environment can be thought of as a higher level target, which is used to define runtime setup that can\nbe used in conjunction with many different targets. In test engineering applications, it is usual to use the environment to instantiate the target\ntest platform, normally this is assigned to the global variable . $tester Templates Origen has two main ways of generating dynamic ASCII output, the first is via the use of templates.\nThis is the most flexible way of generating dynamic content - the application provides a template\nfile which has been marked up with where dynamic content should go, Origen will then process it\nwithin the context of the current target to generate a target specific version. Origen does not care about what the template represents and it could be anything from design IP, to\nweb pages, to tool configuration files. Sources The second way of generating content is via APIs. In this case the generated content comes from\ncalling Origen methods via Ruby code, rather than from compiling a pre-written template.\nFor example, when creating a test\npattern the act of writing a register can be expressed via an API - -\nwhich will then be translated into the necessary vector stream by Origen. $dut.myreg.write!(0x5) The files which co-ordinate the APIs to build a specific output are called source files. For test engineering applications, source files are used to describe patterns and test flows, though\nOrigen does also support a source-less approach to pattern generation based on the pattern name. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/gems/": {
    "title": "Understanding Gems",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Understanding Gems Ruby gems is the de facto standard package manager used by the Ruby community. This allows Ruby code\nto be packaged up so that it can be used throughout the community while being maintained from a single source. provides free, centralized hosting for these gems and anyone\ncan create a new gem and upload it there. RubyGems.org The job of a dependency manager is to resolve the gem version requirements\nof all gems used within an application (an application can depend on a gem, which may itself depend on\nother gems), so that they will all have access to a runtime environment containing the correct versions\nof the gems that they need.\nAt the time of writing, the Ruby gems system does not provide dependency management and this roll is\nfulfilled by a 3rd party tool called (though it is planned for Bundler to be integrated into Ruby\ngems in future). Bundler Origen and all of its plugins are distributed as Ruby gems and Bundler is used for the dependency\nmanagement. This guide will teach you how to use Ruby gems within your applications, tell you what you need to\nknow about using Bundler within the context of an Origen application, and give you an appreciation for\nhow the Origen runtime environment works. Specifying Gems Every Origen application has a file named Gemfile in its root directory, this is where\nthe gem dependencies for the given application will be specified. Here is an example Gemfile: source ' gem https://rubygems.org ' ' , origen ' gem ' >= 0.5 ' ' origen_debuggers ' gem ' roo gem , ' ' ' origen_testers : path ' /path/to/local/origen_testers ' gem ' origen_jtag , ' git : ' , ' https://github.com/Origen-SDK/origen_jtag.git ref : ' ad323f ' Points to note on the above: The source line specifies the gem library where the gems are hosted, in the Ruby community every\ngem is hosted on rubygems.org. Multiple sources can be used, and in practice for an Origen application this\nmeans that you can also add a company internal gem server to host private Origen plugins ( ). see below The gem import line shows how you can specify a dependency on a specific (or in this case minimum)\nversion of a given gem. See section of the RubyGems.org documentation for details on how to specify version numbers within a semantic\nversioning system. origen this section The origen_debuggers and roo lines show how to add Origen plugins and non-Origen\ngems to your application - the process is identical. Note that with no version specifier the latest production\nversion will be fetched when your gem bundle is built. The origen_testers line shows how to use a local copy of a given gem/plugin, this allows you\nto make changes to the given gem to add a feature or fix a bug, and then try it out within your application.\nOrigen will not allow execution with a path reference in production mode, since it is an inherently a non-reproducible\nenvironment for the future. Git references can also be used, here to pick up a specific commit of the gem direct from its repository. This can be used to pick up a pre-release version of a gem that contains\na specific feature or bug fix that you need immediately. origen_jtag The Gemfile system is provided by Bundler and the can be consulted for more information. Bundler guide on Gemfiles Importing Gems Origen takes care of setting up Bundler so that it will work in the common corporate scenario where the\nuser does not have the root access required to install the gems to the system Ruby installation.\nTo ensure that Bundler is properly configured, it is critical that an Origen command is run first in\na new application workspace, before any attempts are made to run Bundler directly. A common way of doing this is simply to run the origen -v command upon first setting\nup a new application workspace. This command will invoke Bundler with the required configuration\nautomatically and all of the required gems will be installed to . ~/.origen/gems Unfortunately Origen has not yet managed to completely wrap Bundler and sometimes there will be a\nneed to invoke it directly.\nThis usually occurs when you have changed the version requirements of a particular gem within\nyour Gemfile. Once you have changed the requirement you should run: bundle update <gem_name> This will tell Bundler to update the version of the given gem, but leave the versions of everything else\nas they are. Sometimes however the new version of the given gem will itself require a new version of\nsome other dependent gem, in that case you will get an error and you can try running this command\nto resolve it: bundle If you still have an error, then updating the complete bundle will resolve it: bundle update Note that this will fetch the latest version of every gem in your bundle that has an open-ended\nversion dependency. This can result in more changes to your environment than you really want/need\nand is therefore usually best kept as a last resort. Company Internal Gems As experience with Origen grows, you will begin to start creating your own plugins/gems, many of\nwhich will contain company proprietary IP that you will not want to release via the open source\ncommunity.\nTherefore a way of privately hosting these gems is required. An easy way of doing this initially is to use Git as the revision control tool for your plugins,\nthen you can use Git references within your Gemfiles as discussed above. A better solution though, is to setup a gem server within your company intranet, and we recommend this server .\nYou will likely need to work with your IT department to get this setup and maintained. When it is available, simply update your Gemfiles with the additional server like this: source source ' https://rubygems.org ' ' http://gems.mycompany.net:9292 ' gem ' origen ' gem #... ' private_test_block ' At that point you should also update your company’s Origen configuration with the details of the new server, in that way the origen new command will automatically\nconfigure your new applications with the required source reference in the Gemfiles. Gemfile.lock A file called Gemfile.lock will be created by Bundler in the application’s top-level\ndirectory and this should be checked into the revision control system. The purpose of this file is to record the absolute versions of all gems that are currently\nused by the given application. This means that when another developer, or one of your application’s\nusers, checks out a given version of your application into a new workspace, then the exact same\ngem versions will be used as when it was originally tested and checked in. This means that it safe (and in fact recommend) to leave the gem versions largely unspecified by your Gemfile,\nas it does not mean that different user environments will be running different gem versions. Executables If your gems provide command line executables that you wish to run, then these need to be invoked through\nBundler to make them run within the context of the application’s gem environment (bundle).\nSay for example that a given gem provides an executable called , then to run this from your\napplication’s command line you should do: clean bundle exec clean This applies to the executable too, however as this is cumbersome to write and\neasy to forget, Origen employs some tricks that will enforce this wrapping automatically, so Origen\ncan always be invoked with just: origen origen <command> Bundler will build wrapped executables within an application’s directory, these\ncan be invoked directly without the need for the lbin prefix, so for example the bundle exec clean executable could be correctly invoked by running: ./lbin/clean This is arguably easier to write than , but it can still be easy to forget. Therefore\nif your application has a need to run 3rd party executables a lot, then it is recommend to add\nthe application’s bundle exec directory to your path so that you can simply run: lbin clean System Origen It was noted in the Origen installation guide that the base Origen version installed to your system Ruby does not really matter, and it does not need to\nbe updated to the latest version of Origen on a regular basis. This is because the base Origen is only used to either create a new Origen application, or to initially\nboot an Origen command within an existing application. In both cases, the version used to initially boot\nOrigen is unimportant. In the case of creating a new application, Origen will always pull in the latest and greatest application generator\nand this is not statically linked to the version of Origen that is being executed to build the new app.\nSimilarly, when running an Origen application the thread will immediately switch over to run the version\nof Origen specified in the Gemfile instead of the system version. This system therefore ensures that application owners are in control of what version of Origen is used by\nthe users of their application, however neither the application owner or their users need permissions to\nupdate the system Ruby installation in order to achieve the required runtime environment.\nThey simply checkout the version of the given application that they want, and then Origen/Bundler\ntakes care of guaranteeing that the runtime environment is the correct one. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/installing/": {
    "title": "How to Install",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen How to Install Origen can be installed on Linux or Windows, this guide refers to the Linux installation. If running on windows is of interest then please see this guide instead: How to Install Origen on Windows Background Origen is distributed as a Ruby gem, which is the Ruby language’s package manager. Installation of Origen consists of the following steps: Install Pre-Requisites Install Ruby Install Origen (optional) Customize your installation Install Pre-Requisites To install Ruby, your system will need a C compiler and the Make utility. Installation of this\nwill vary depending on your particular Linux distribution, but for example on Ubuntu\nthe required build environment can be installed by running: sudo apt-get install build-essential It is also recommend to install a recent version (2.x) of Git, if you don’t know how to\ndo that, google for . “how to install Git on <your distribution>“ Install Ruby Origen requires a , you can install this or the latest version. minimum Ruby version of 2.1.0 If you are working from a personal Linux box (or VM), or if you want to install Ruby for\nyourself only, we recommend that you install it via and follow these rbenv . installation instructions This will install Ruby to your home directory and will not require you to have root access. If you are working from a corporate environment where a central Ruby installation will\nbe used by many users, we recommend that you follow the instructions on the . official Ruby installation guide Most likely building from source will be the most appropriate choice in this case, especially\nif dealing with an older Linux distribution, since the version available from your system’s\npackage manager will probably be quite old. If you have any particular problems installing Ruby, please so that we can build up a record of common problems and solutions. use this discussion thread Install Origen Once you have Ruby successfully installed, Origen can be installed very easily via: gem install origen --no-rdoc --no-ri You can then verify Origen availability by running origen -v at which point you should see something like this: Origen: 0.4.2 Congratulations, Origen is now installed! Note that the version of Origen that is installed to your Ruby installation does not need to\nbe kept up to date with the latest version of Origen. You can now consider your Ruby environment\nto be frozen for the foreseeable future. See the section on for details on\nwhy that is. Understanding Gems A Note on Nokogiri A common problem with the final step of installing Origen is to run into problems installing\na gem called Nokogiri (which is one of Origen’s dependencies). Generally the more recent your Linux distribution is, the less likely you are to have problems\nwith this. It is beyond the scope of this document to deal with likely causes and solutions, however if\nyou do run into problems google should yield plenty of hits of similar cases and hopefully\nwith guidelines on how to fix it. You can also report problems via this Origen forum thread on Nokogiri Installation Issues and we will do our best to provide help, or you can actually just comment below… Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/installwin/": {
    "title": "How to Install (Windows)",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen How to Install (Windows) Origen can be installed on Linux or Windows, this guide refers to the Windows installation. The lack of a package manager in windows makes it harder to install various packages from the command line. We recommend using chocolatey (http://chocolatey.org); an open source windows package manager. You can imagine chocolatey to be somewhat like apt-get or other package managers on Linux, but built with Windows in mind. This guide will use chocolatey as the package manager to: Install Ruby Install Ruby-Dependencies Install Ruby-Development-Kit Install RubyGems Install RubyGems-SSL-workaround Install Essential-Gems Install Utilities Note: Origen installation has been tested on Windows 7 only at this time, but we don’t think the installation process will be any different. An active internet connection is required before proceeding. If running on Linux is of interest then please see this guide instead: How to Install Origen on Linux Background Origen is distributed as a Ruby gem, which is the Ruby language’s package manager. Installation of Origen consists of the following steps: Install Ruby Install Ruby-Dependencies Install Origen Install Chocolatey All commands mentioned below need to be typed in the command prompt running as an administrator Start → run → cmd runas /user:Administrator 1. Chocolatey To install the package manager (chocolatey), please type the text below in the command prompt (running as administrator) @powershell -NoProfile -ExecutionPolicy Bypass -Command \"iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin Install Ruby With the package manager installed, Installing Ruby is a breeze. Just type the following in the command prompt window (running as administrator) cinst ruby -y --force This should install Ruby v2.1.6 (latest supported by the package manager as of writing this guide) If the package manager upgrades to the latest version (v2.2.3), it will install that latest version instead. Please check the ruby version and make a note of it. We will need it later for the RubyGems workaround. ruby -v Once the installer finishes, please close the current window and open a new one (as administrator) Install Ruby-Dependencies Install Ruby-Development-Kit In the new window, type the following cinst ruby2.devkit -y --force Install RubyGems In the same window, now type cinst rubygems -y --force Install RubyGems-SSL-workaround The latest version of Rubygems (that we installed above) is currently broken on Windows.\nHowever, there is a workaround that has been developed and it involves a series of steps.\nThe workaround also depends on which version of Ruby has been installed. The following commands will perform all the steps required for the workaround. If Ruby version installed is v2.1.X @powershell (new-object System.Net.WebClient).DownloadFile('https://github.com/rubygems/rubygems/releases/download/v2.0.15/rubygems-update-2.0.15.gem','C: ubygems-update-2.0.15.gem') && gem install --local C: ubygems-update-2.0.15.gem && update_rubygems --no-ri --no-rdoc && gem uninstall rubygems-update -x If Ruby version installed is v2.2.X @powershell (new-object System.Net.WebClient).DownloadFile('https://github.com/rubygems/rubygems/releases/download/v2.2.3/rubygems-update-2.2.3.gem’,'C: ubygems-update-2.2.3.gem') && gem install --local C: ubygems-update-2.2.3.gem && update_rubygems --no-ri --no-rdoc && gem uninstall rubygems-update -x Once the command finishes, please check the gem version installed by typing gem --version The Gem version should be v2.0.15 for Ruby v2.1.X or v2.2.3 for Ruby v2.2.X Install Origen Origen is available as a packaged gem and can be easily installed by typing: gem install origen --no-ri --no-rdoc *this can take several minutes to finish without updating the screen, so please be patient You can then verify Origen availability by running origen -v at which point you should see something like this: Origen: 0.4.2 Congratulations, Origen is now installed! Note that the version of Origen that is installed to your Ruby installation does not need to\nbe kept up to date with the latest version of Origen. You can now consider your Ruby environment\nto be frozen for the foreseeable future. See the section on for details on\nwhy that is. Understanding Gems Install Utilities It is also recommend to install a recent version (2.x) of Git We can do that easily now by typing cinst git -y This will install Git v2.5.2 (latest version available as of writing this guide) Optional: We recommend that you also install the following utilities for a more UNIX like experience on windows. UnxUtils (cinst unxutils -y) ConsoleZ (cinst consoleZ -y) Console2 (download from http://sourceforge.net/projects/console/) For your convenience, you can also watch the installation process in the video below. Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/guides/starting/introduction/": {
    "title": "Introduction",
    "subtitle": "Getting Started with Origen",
    "body": "Getting Started with Origen Introduction Welcome to the Origen guides! The Origen platform is written in Ruby\nand following this documentation will take you from a complete beginner to an\nOrigen expert. This site is focussed specifically on the Origen API, but for background on Ruby the\ninternet is your friend.\nRuby is very popular for web development and as such it is extremely easy to Google\nfor solutions to any Ruby-related problems that you may come across, or to find\ntutorials from which to learn. The official Ruby website contains a quick tutorial on Ruby to get you started: Ruby in 20 Minutes Previous engineers who have learned Ruby have recommend the following resources: Learn Ruby at rubymonk.com Learn Ruby at codeacademy.com Ruby for Newbies Video Tutorials Ruby Koans If you want to use regular expressions in your code the following website is invaluable: Regular Expression Editor Comments /* * * CONFIGURATION VARIABLES * * */\n var disqus_shortname = 'origen-sdk';\n var disqus_title;\n var disqus_url = 'http://' + window.location.hostname + window.location.pathname;\n\n disqus_title = $(\"h1\").text();\n if (disqus_title.length == 0) {\n disqus_title = $(\"h2\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"h3\").text();\n }\n if (disqus_title.length == 0) {\n disqus_title = $(\"title\").text();\n } else {\n disqus_title = disqus_title + ' (' + $(\"title\").text() + ')';\n }\n\n /* * * DON'T EDIT BELOW THIS LINE * * */\n (function() {\n var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';\n (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n })(); Please enable JavaScript to view the comments powered by Disqus."
  },
  "/plugins/": {
    "title": null,
    "subtitle": null,
    "body": ""
  },
  "/release_notes/": {
    "title": null,
    "subtitle": null,
    "body": ""
  }
}